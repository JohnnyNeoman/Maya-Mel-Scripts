global vector $ObjCurv[];
global vector $ObjVec[];
global string $GlobalObjListA[];
global string $GlobalObjOne[];
string $ConnectionSet1 = `sets -name ExistingCurveZSet`;
string $ConnectionSet2 = `sets -name CurveZSetOne`;
clear $ObjCurv;
clear $GlobalObjListA;
clear $GlobalObjOne;
clear $ObjVec;
/*
//    IMPORTANT to set if you want to use any curve scripts !
int $scriptt_jobNumConnectionChanged = `scriptJob -conditionChange delete evalVectorIndexAdditionSubtract`;
*/
print $GlobalObjListA;
proc float [] MultLenToDirAddToPoint(float $Length, float $Dir[], float $Pos[]){
	float $MultLengthDir[] = multiplyFloat($Length, $Dir);
	float $AddMultDirPos[] = AddFloats($Pos, $MultLengthDir);
	return $AddMultDirPos;
}
proc string [] GetNearest(int $Nn, string $OneObject, string $diff[]){
	string $objectList[] = $diff;
	float $pointA1[];
	$pointA1 = `xform -query -worldSpace - translation ($OneObject)`;
	float $distanceA[];
	clear  $distanceA;
	int $Indx=0;
	float $pointA2[];
	for ($eachZx in $objectList){
		if (catch($pointA2 = `xform -q -ws -t $objectList[$Indx]`)){
			$pointA2 = `pointPosition -w $objectList[$Indx]`;
		} 
		$Indx++;
		$dAx = $pointA1[0] - $pointA2[0];
		$dAy = $pointA1[1] - $pointA2[1];
		$dAz = $pointA1[2] - $pointA2[2];
		$distanceA[`size($distanceA)`] = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
	}
	string $EmptyStringX[];
	clear $EmptyStringX;
	float $NewfloatsX[];
	$NewfloatsX = SortFloatArrayAndString($distanceA, $objectList, $EmptyStringX);
	$EmptyStringX = ReverseStringArray($EmptyStringX);
	float $NewfloatsXi[] = ReverseFloatArray($NewfloatsX);
	string $returnZi[];
	int $iX= 0;
	while ($Nn > $iX){
		$returnZi[`size($returnZi)`] = $EmptyStringX[$iX];
		$iX++; 
	}
	return $returnZi;
}
// print $GlobalObjListA;
// IndexNoLongerExistingFromArray($GlobalObjListA);
proc float [] xyzRotation( float $theta, float $axis[])
//
//	Description:
//		Given an angle for rotation (in radians) and an axis about which to 
//		do the rotation, return the rotation about the X,Y,Z axes (in $rotation).
//
{
	float $rotation[] ;
	// set up the xyzw quaternion values
	//
	$theta *= 0.5;
	float $w = cos($theta);
	float $factor = sin($theta);
	float $axisLen2 = dotProduct( $axis, $axis, 0 );
	if ( $axisLen2 != 1.0 && $axisLen2 != 0.0 ) $factor /= sqrt($axisLen2);
	float $x = $factor * $axis[0];
	float $y = $factor * $axis[1];
	float $z = $factor * $axis[2];
	// setup rotation in a matrix
	//
	float $matrix[];
	float $ww = $w*$w;
	float $xx = $x*$x;
	float $yy = $y*$y;
	float $zz = $z*$z;
	float $s = 2.0 / ($ww + $xx + $yy + $zz);
	float $xy = $x*$y;
	float $xz = $x*$z;
	float $yz = $y*$z;
	float $wx = $w*$x;
	float $wy = $w*$y;
	float $wz = $w*$z;
	$matrix[0] = 1.0 - $s * ($yy + $zz);
	$matrix[1] = $s * ($xy + $wz);
	$matrix[2] = $s * ($xz - $wy);
	$matrix[5] = 1.0 - $s * ($xx + $zz);
	$matrix[6] = $s * ($yz + $wx);
	$matrix[9] = $s * ($yz - $wx);
	$matrix[10] = 1.0 - $s * ($xx + $yy);
	// get x,y,z values for rotation
	//
	float $solution1[];
	float $solution2[];
	float $cosB = sqrt($matrix[0]*$matrix[0] + $matrix[1]*$matrix[1]);
	if ( $cosB > 1.0e-10 )
	{
		float $a, $b, $c;
		float $pi = 3.14159265;

		$solution1[0] = $a = atan2( $matrix[6], $matrix[10]);
		$solution1[1] = $b = atan2(-$matrix[2], $cosB);
		$solution1[2] = $c = atan2( $matrix[1], $matrix[0]);
		$solution2[0] = $a + (($a < $pi) ? $pi : -$pi);
		$solution2[1] = (($b > -$pi) ? $pi : -$pi) - $b;
		$solution2[2] = $c + (($c < $pi) ? $pi : -$pi);    
		if ( abs($solution2[0]) + abs($solution2[1]) + abs($solution2[2]) <
				abs($solution1[0]) + abs($solution1[1]) + abs($solution1[2]) )
		{
			$rotation = $solution2;
		}
		else 
		{
			$rotation = $solution1;
		}
	}
	else
	{
		$rotation[0] = atan2(-$matrix[9], $matrix[5]);
		$rotation[1] = atan2(-$matrix[2], $cosB);
		$rotation[2] = 0.0;
	}
	return $rotation;
}
proc float roundInt(float $val,float $dec){
	if($dec==1){
		$val = $val/10;}
	$sign = `sign $val`;
	float $decB = `pow 10 $dec`;
	$val = (int) (($val + $sign*5/($decB*10)) * $decB);
	float $valB = ($val / $dec);
	if($dec==1){
		$valB = $valB *1;}
	return $valB ;
}

proc  CreateCurveFromTwoSelected(){ 
	string $selectedObjects[] = `ls -sl`;
	vector $pointOne;
	$pointOne = `xform -q -ws -sp $selectedObjects[0]`;
	vector $pointTwo;
	$pointTwo = `xform -q -ws -sp $selectedObjects[1]`;
	curve2points $pointOne $pointTwo;
	ResetTransEachSL;
}
proc ShakeHands(){
	string $itemA[] = `ls -sl`;
	string $itemBackUp[] = $itemA;
	int $Xvi =0;
	for($each in $itemBackUp){
		string $itemsToRemove[] = { $itemA[0] };
		string $diff[] = stringArrayRemoveExact($itemsToRemove, $itemA);
		for($eachOther in $diff){
			select -r $eachOther $itemsToRemove;
			playButtonStepForward;
			CreateCurveFromTwoSelected;
			playButtonStepForward;
		}
		$itemA = $diff;
	}
}
proc ForEach_To_EveryOther_OneArray(string $item[], string $command){
	//START
	string $itemBackUp[] = $item;
	string $Remove[];
	string $diff[];
	////////////////////////// 
	////////////////////////// 
	for($each in $itemBackUp)
	{
		$Remove = {$item[0]};
		$diff = stringArrayRemoveExact($Remove, $item);
		/////////////////////////
		for($eachOther in $diff){
			string $eval = ($command + $eachOther+" "+ $Remove[0]);
		}
		///////////////////////// 
		$item = $diff;
	}
	//////////////////////////////
	////////////////////////////// 
	//END
}
proc quickFix(){
	global vector $ObjVec[];
	global string $GlobalObjListA[];
	string $quickFix[] = `sets -q ExistingCurveZSet`;
	vector $FixVec[] = PointArrayT($quickFix);
	$GlobalObjListA=$quickFix;
	$ObjVec=$FixVec;
}
proc CurveIndexVecTracking(string $OBJ[]){
	string $OBJall[] = `sets -q CurveZSetOne` ;
	if(`size($OBJall)`>0){
		sets -remove CurveZSetOne $OBJall;
	}
	global string $GlobalObjOne[];
	global vector $ObjCurv[];
	sets -include CurveZSetOne $OBJ;
	eval("$GlobalObjOne= `sets -q CurveZSetOne`");
	eval("appendStringArray($GlobalObjListA,$GlobalObjOne, 1)");
	eval("vector $ObjCurv[] = PointArrayT($GlobalObjOne);");
	eval("$ObjVec[`size($ObjVec)`] =  $ObjCurv[0]");
	eval("sets -include ExistingCurveZSet $GlobalObjOne");
	sets -remove CurveZSetOne $OBJ;
}
proc evalVectorIndexAdditionSubtract(){
	global vector $ObjVec[];
	global string $GlobalObjListA[];
	vector $objVecMain[];
	$objVecMain  = $ObjVec;
	int $intIndexCurveZ[] =  CreateIntIndex(`size($objVecMain)`) ;
	vector $firstReduction[];
	clear $firstReduction;
	string $GetObjList[] = `sets -q ExistingCurveZSet`;
	string $KnowObjList[] = $GlobalObjListA;
	string $NewObjList[];
	string $diffAZ[] = stringArrayRemoveExact($GetObjList,$KnowObjList);
	string $diffCZ[] = stringArrayRemoveExact($KnowObjList, $GetObjList);
	if((`size($diffCZ)`>0)||(`size($diffAZ)`>0)){
		if(`size($diffAZ)`>0){
			string $diffBZ[] = stringArrayRemoveExact($diffAZ,$KnowObjList);
			$NewObjList= $diffBZ;
			int $indexNumberZ[] = stringArrayGmatchArrayIndex($diffBZ, $KnowObjList);
			int $indexX= 0;
			for ($eachVec in $indexNumberZ){
				$firstReduction[`size($firstReduction)`]= $objVecMain[$eachVec];
			}
		}
		if(`size($diffCZ)`>0){
			vector $newAddedVec[] = PointArrayT($diffCZ);
			int $iXn = 0;
			for ($eachVecB in $newAddedVec){
				$firstReduction[`size($firstReduction)`]=  $eachVecB ;
				stringArrayInsertAtIndex(`size($NewObjList)`, $NewObjList, $diffCZ[$iXn]); 
				$iXn++;
			}
		}
		$GlobalObjListA = $NewObjList;
		clear $ObjVec;
		$ObjVec= $firstReduction;
	}
}
//////////////////
proc vector [] RemoveVecAtIndex(vector $VecS[],int $IndeXxz[]){
	vector $newVec[];
	int $Ixx =0;
	for ($eachVc in $IndeXxz){
		if(!($Ixx==$eachVc)){
			$newVec[`size($newVec)`] = $VecS[$eachVc];
		}
		$Ixx++;
	}
	return $newVec;
}
proc string [] RemoveStringAtIndex(string $VecS[],int $IndeXz[]){
	string $newVec[];
	int $IndeXxiz[] = sort($IndeXz); 
	int $SizA = `size($IndeXz)`;
	int $Ixx =0;
	int $Ixi = 0;
	for ($eachVc in $VecS){
		if(!($Ixx== $IndeXxiz[$Ixi])){
			$newVec[`size($newVec)`] = $eachVc;
		}else{$Ixi++;}
		$Ixx++;
	}
	return $newVec;
}
proc string [] IncludeStringAtIndex(string $VecS[],int $IndeXxi[]){
	string $newVec[];
	for ($eachVcC in $IndeXxi){
		$newVec[`size($newVec)`] = $VecS[$eachVcC];
	}
	return $newVec;
}
proc int [] StringToInt( string $IndeXxz[]){
	int $newVec[];
	for ($eachVc in $IndeXxz){
		int $One = $eachVc;
		$newVec[`size($newVec)`] =$One ;
	}
	return $newVec;
}
proc vector [] RemoveVecAtOneIndex(vector $VecS[],int $IndeXxz){
	vector $newVec[];
	int $Ixx =0;
	for ($eachVc in $VecS){
		if(!($Ixx==$IndeXxz)){
			$newVec[`size($newVec)`] = $VecS[$Ixx];
		}
		$Ixx++;
	}
	return $newVec;
}
proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxz[]){
	int $newInt[];
	int $Ix = 0;
	int $Ixi = 0;
	for ($eachVc in $VecS){
		if(!($eachVc== $IndeXxz[$Ixi])){
			$newInt[`size($newInt)`] = $eachVc;
		}else{$Ixi++;}
		$Ix++;
	}
	return $newInt;
}
proc int [] RemoveINTAtIndex(int $VecS[],int $IndeXxz[]){
	int $newInt[];
	int $Ix = 0;
	int $Ixi = 0;
	for ($eachVc in $VecS){
		if(!($eachVc== $IndeXxz[$Ixi])){
			$newInt[`size($newInt)`] = $VecS[$Ix];
		}else{$Ixi++;}
		$Ix++;
	}
	return $newInt;
}
proc int EvalQueryObjListCurvesGetSmaller(){
	int $TrueorF =0;
	$TrueorF = eval("QueryObjListCurvesGetSmaller($GlobalObjListA);" );
	return $TrueorF;
}
proc int QueryObjListCurvesGetSmaller(string $GlobalObjListA[]){
	int $TorF = 0;
	string $GetObjList[] = `sets -q ExistingCurveZSet`;
	if( size($GetObjList)  <  size($GlobalObjListA)  ){
		$TorF = 1;
	}
	if( size($GetObjList) >  size($GlobalObjListA)  ){
		$TorF = 1;
	}
	return $TorF;
}
proc EvalVecindexTrackerIfcurveNumChange(){
	int $ifTrue = `EvalQueryObjListCurvesGetSmaller`;
	if($ifTrue == 1){evalVectorIndexAdditionSubtract;}
}
proc CurveIndexVecTracking(string $OBJ[]){
	string $OBJall[] = `sets -q CurveZSetOne` ;
	if(`size($OBJall)`>0){
		sets -remove CurveZSetOne $OBJall;
	}
	global string $GlobalObjOne[];
	global vector $ObjCurv[];
	sets -include CurveZSetOne $OBJ;
	eval("$GlobalObjOne= `sets -q CurveZSetOne`");
	eval("appendStringArray($GlobalObjListA,$GlobalObjOne, 1)");
	eval("vector $ObjCurv[] = PointArrayT($GlobalObjOne);");
	eval("$ObjVec[`size($ObjVec)`] =  $ObjCurv[0]");
	eval("sets -include ExistingCurveZSet $GlobalObjOne");
	sets -remove CurveZSetOne $OBJ;
}
proc int EvalQueryObjListCurvesGetSmaller(){
	int $TrueorF =0;
	$TrueorF = eval("QueryObjListCurvesGetSmaller($GlobalObjListA);" );
	return $TrueorF;
}
proc int QueryObjListCurvesGetSmaller(string $GlobalObjListA[]){
	int $TorF = 0;
	string $GetObjList[] = `sets -q ExistingCurveZSet`;
	if( size($GetObjList)  <  size($GlobalObjListA)  ){
		$TorF = 1;
	}
	if( size($GetObjList) >  size($GlobalObjListA)  ){
		$TorF = 1;
	}
	return $TorF;
}
proc EvalVecindexTrackerIfcurveNumChange(){
	int $ifTrue = `EvalQueryObjListCurvesGetSmaller`;
	if($ifTrue == 1){evalVectorIndexAdditionSubtract;}
}
proc string [] GlobalItemString(string $GlobalListA[]){
	string $GlobalListSend[] = $GlobalListA;
	return $GlobalListSend;
}
proc string GlobalsString(string $Globals){
	string $GlobalListSend = $Globals;
	return $GlobalListSend;
}
proc ItemtoGlobalString(string $NewObjLista[]){
	eval ("$GlobalObjListA= $NewObjLista");
}
proc vector [] GlobalItemVec(vector $GlobalListVecA[]){
	vector $GlobalVecSend[] = $GlobalListVecA;
	return $GlobalVecSend;
}
//
/////////////////////////////Other
proc EVALCamScripts2(){
	$runit = "MoveZSURFACEModelingCAM ($CamConeLocator);";
	eval($runit); }
///////////////////////////
//print $EdgeCurveZ1;
////////////////////////
/*
proc string[] RemoveNoLongerExistingFromArray (string $EdgeCurveZ1[]){
int $SizeOfArrayA = size($EdgeCurveZ1);
if ( $SizeOfArrayA > 0){
int $SizeOfArray = size($EdgeCurveZ1) -1;
int $i = -1;
int $E = -1;
while( $E < $SizeOfArray ){
$i++;
$E++;
if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
if ($i == 0) { $i = -1;} else { $i = $i -1;}   
}
}
int $SizeOfArrayB = size($EdgeCurveZ1);
}
return $EdgeCurveZ1;
}
*/
proc int[] IndexNoLongerExistingFromArray (string $EdgeCurveZ1[]){
	int $SizeOfArrayA = size($EdgeCurveZ1);
	int $IndeXx[];
	if ( $SizeOfArrayA > 0){
		int $SizeOfArray = size($EdgeCurveZ1) -1;
		int $i = -1;
		int $E = -1;
		while( $E < $SizeOfArray ){
			$i++;
			$E++;
			if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
				$IndeXx[`size($IndeXx)`]= $i;
			}
		}
	}
	return $IndeXx;
}
proc string[] MoveZCURVEModelingCAM(string $EdgeCurves[], string $CamConeLocator[] ){
	string $listofallcurves[];
	$listofallcurves = $EdgeCurves;
	string $ObjectsINcamLightCone[];
	string $OutofRange[];
	layerEditorRemoveObjects layerCurvesINRange1 ;
	editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
	layerEditorRemoveObjects layerCurvesOutofRange1 ;
	editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
	clear $ObjectsINcamLightCone;
	if ( `objExists LocOnLivePlaneB` == 0  ) {
		createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
		setAttr LocOnLivePlaneB.color 9;
	}
	queryLocOnLivePlaneBLayerDelete;
	queryLocCurveEndsLayerDelete;
	querylayerMidPointLayerDelete;
	string $shortnameL;
	catch ( $shortnameL = "PlaneLOC*");
	if ( `objExists $shortnameL` == 1  ) {
		catch (`delete $shortnameL`);
	}
	string $CurveItem[] = $listofallcurves;
	ResetTransEachSL;
	string $NurbplaneB = "LiveSurfaceBShape";
	vector $VecArrayRemainsZ[]; clear $VecArrayRemainsZ;
	string $ObjectsInFrontZ[]; clear $ObjectsInFrontZ;
	//$ObjVecX
	$ObjectsInFrontZ = GetObjectsInFrontOfPlane($CurveItem, $VecArrayRemainsZ);
	string $LocPointinPlane[];
	if(`size($ObjectsInFrontZ)`>0){
		vector $AllLocPositionsZ[];
		clear $AllLocPositionsZ;
		vector $AllPlaneLocPositionZ[]= VecPointsToCameraPlane($VecArrayRemainsZ);
		int $newOrderA[];
		$LocPointinPlane = PointInNurbPlane($AllPlaneLocPositionZ, $ObjectsInFrontZ, $newOrderA, 0);
	}
	if(`size($LocPointinPlane)`>0){
		string $LocCurveEnds[];
		string $AllLocCurveEnds[];
		int $indexLoc = 0;
		vector $AllCurveLocArrayVec[];
		for ($each in $LocPointinPlane){
			stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each); 
			$LocCurveEnds = LocCurveEnds({$each},$AllCurveLocArrayVec);
			appendStringArray($AllLocCurveEnds, $LocCurveEnds, size($LocCurveEnds));
		}
		vector $AllCurvePlaneLocZ[];
		clear $AllCurvePlaneLocZ;
		$AllCurvePlaneLocZ = VecPointsToCameraPlane($AllCurveLocArrayVec);
		string $CurveLocPlanePoints[];
		int $newOrderB[];
		$CurveLocPlanePoints = PointInNurbPlane($AllCurvePlaneLocZ, $AllLocCurveEnds, $newOrderB, 1);
	}
	string $shorterList[] =  stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
	$ObjectsINcamLightCone = $shorterList;
	$OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
	editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
	editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
	return $ObjectsINcamLightCone;
}
proc string[] MoveZCURVEModelingCAM2010(string $EdgeCurves[], string $CamConeLocator[], vector $ObjVecX[]){
	string $listofallcurves[];
	$listofallcurves = $EdgeCurves;
	string $ObjectsINcamLightCone[];
	string $OutofRange[];
	layerEditorRemoveObjects layerCurvesINRange1 ;
	editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
	layerEditorRemoveObjects layerCurvesOutofRange1 ;
	editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
	clear $ObjectsINcamLightCone;
	if ( `objExists LocOnLivePlaneB` == 0  ) {
		createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
		setAttr LocOnLivePlaneB.color 9;
	}
	queryLocOnLivePlaneBLayerDelete;
	queryLocCurveEndsLayerDelete;
	querylayerMidPointLayerDelete;
	string $shortnameL;
	catch ( $shortnameL = "PlaneLOC*");
	if ( `objExists $shortnameL` == 1  ) {
		catch (`delete $shortnameL`);
	}
	string $CurveItem[] = $listofallcurves;
	ResetTransEachSL;
	string $NurbplaneB = "LiveSurfaceBShape";
	vector $VecArrayRemainsZ[]; clear $VecArrayRemainsZ;
	string $ObjectsInFrontZ[]; clear $ObjectsInFrontZ;
	//$ObjVecX
	$ObjectsInFrontZ = GetObjectsInFrontOfPlane2($CurveItem, $ObjVecX, $VecArrayRemainsZ);
	string $LocPointinPlane[];
	if(`size($ObjectsInFrontZ)`>0){
		vector $AllLocPositionsZ[];
		clear $AllLocPositionsZ;
		vector $AllPlaneLocPositionZ[]= VecPointsToCameraPlane($VecArrayRemainsZ);
		int $newOrderA[];
		$LocPointinPlane = PointInNurbPlane($AllPlaneLocPositionZ, $ObjectsInFrontZ, $newOrderA, 0);
	}
	if(`size($LocPointinPlane)`>0){
		string $LocCurveEnds[];
		string $AllLocCurveEnds[];
		int $indexLoc = 0;
		vector $AllCurveLocArrayVec[];
		for ($each in $LocPointinPlane){
			stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each); 
			$LocCurveEnds = LocCurveEnds({$each},$AllCurveLocArrayVec);
			appendStringArray($AllLocCurveEnds, $LocCurveEnds, size($LocCurveEnds));
		}
		vector $AllCurvePlaneLocZ[];
		clear $AllCurvePlaneLocZ;
		$AllCurvePlaneLocZ = VecPointsToCameraPlane($AllCurveLocArrayVec);
		string $CurveLocPlanePoints[];
		int $newOrderB[];
		$CurveLocPlanePoints = PointInNurbPlane($AllCurvePlaneLocZ, $AllLocCurveEnds, $newOrderB, 1);
	}
	string $shorterList[] =  stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
	$ObjectsINcamLightCone = $shorterList;
	$OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallcurves);
	editDisplayLayerMembers -noRecurse  layerCurvesOutofRange1 $OutofRange;
	editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ObjectsINcamLightCone;
	return $ObjectsINcamLightCone;
}
// print $EdgeCurveZ2;
string $GetObjListZtest[] = `sets -q ExistingCurveZSet`;
//$EdgeCurveZ2 = `queryLayerRangeMembers`;
/*
proc EVALCamScripts(){
$runit = "CatchMoveZCURVECAM($EdgeCurveZ2, $CamConeLocator );";
eval($runit); }
*/
//print $GlobalObjListA;
//print  $ObjVec;
proc EVALCamScripts(){
	$runit = "CatchMoveZCURVECAM2010($GlobalObjListA, $CamConeLocator, $ObjVec );";
	eval($runit); }
proc CatchMoveZCURVECAM2010(string $EdgeCurveZa[], string $CamConeLocator[], vector $ObjVecX[]){
	if ( catchQuiet(MoveZCURVEModelingCAM2010 ($EdgeCurveZa, $CamConeLocator, $ObjVecX ))) {
		evalVectorIndexAdditionSubtract;
		MoveZCURVEModelingCAM2010($EdgeCurveZa, $CamConeLocator, $ObjVecX );
	} else {
		print "move Cam";
	}
}
proc CatchMoveZCURVECAM(string $EdgeCurveZ2[], string $CamConeLocator[] ){
	if ( catchQuiet(MoveZCURVEModelingCAM ($EdgeCurveZ2, $CamConeLocator ))) {
		RemoveNoLongerExistingFromArray($EdgeCurveZ2);
		MoveZCURVEModelingCAM($EdgeCurveZ2, $CamConeLocator );
	} else {
		print "move Cam";
	}
}
proc string[] queryLocOnLivePlaneBLayer(){
	string $queryLocB[];
	$queryLocB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
	int $IfemptyIsTrue = 0;
	if (`size( $queryLocB)` > 0){
		$IfemptyIsTrue = 0;
	}
	if (`size( $queryLocB)`== 0){
		$IfemptyIsTrue = 1;
	} 
	//print $IfemptyIsTrue;

	return $queryLocB;
}
proc queryLocOnLivePlaneBLayerDelete(){
	string $queryLocOnLivePlaneB[];
	$queryLocOnLivePlaneB = `editDisplayLayerMembers  -q LocOnLivePlaneB`;
	if (`size( $queryLocOnLivePlaneB)` > 0){
		delete  $queryLocOnLivePlaneB;
	}
}
proc queryLocCurveEndsLayerDelete(){
	string $queryLocCurveEnds[];
	$queryLocCurveEnds = `editDisplayLayerMembers  -q LocCurveEnds`;
	if (`size($queryLocCurveEnds)` > 0){
		delete $queryLocCurveEnds;
	}
}
proc querylayerMidPointLayerDelete(){
	string $querylayerMidPoint[];
	$querylayerMidPoint = `editDisplayLayerMembers  -q layerMidPoint`;
	if (`size($querylayerMidPoint)` > 0){
		delete $querylayerMidPoint;
	}
}
if ( `objExists layerMidPoint` == 0  ) {
	createDisplayLayer -name "layerMidPoint" - number 1 -empty;
	setAttr layerMidPoint.color 14;
}
/*
//layerMidPoint
if ( `objExists layerMidPoint` == 0  ) {
createDisplayLayer -name "layerMidPoint" - number 1 -empty;
setAttr layerMidPoint.color 14;
}
if ( `objExists LocOnLivePlaneB` == 0  ) {
createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
setAttr LocOnLivePlaneB.color 9;
}
if ( `objExists LocCurveEnds` == 0  ) {
createDisplayLayer -name "LocCurveEnds" - number 1 -empty;
setAttr LocCurveEnds.color 13;
}
string $CurveItem[] =`ls -sl`;
ResetTransEachSL;
string $NurbplaneB = "LiveSurfaceBShape";
vector $VecArrayRemainsZ[]; clear $VecArrayRemainsZ;
string $ObjectsInFrontZ[]; clear $ObjectsInFrontZ;
$ObjectsInFrontZ = GetObjectsInFrontOfPlane($CurveItem, $VecArrayRemainsZ);
string $LocPointinPlane[];
if(`size($VecArrayRemainsZ)`>0){
vector $AllLocPositionsZ[];
clear $AllLocPositionsZ;
vector $AllPlaneLocPositionZ[]= VecPointsToCameraPlane($VecArrayRemainsZ);
$LocPointinPlane = PointInNurbPlane($AllPlaneLocPositionZ, $ObjectsInFrontZ);
}
return $LocPointinPlane;
for ($each in $AllPlaneLocPosition){
spaceLocator -p 0 0 0;
MoveObject2($each);
scale -r 0.05 0.05 0.05;
editDisplayLayerMembers -noRecurse layer1 `ls -selection`;
}
LocCurveEnds(`ls -sl`)
*/
proc string[] LocCurveEnds(string $CurveItem[], vector $CurveLocArrayVec[]){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[]; float $EACHCVposBZ[]; int $numIntZB = 0; string $MakeXBetweenB[];
	float $eachCVpos[];	
	for ($eachZA in $CurveSelection) {       
		$eachCVpos = `pointPosition -w ($eachZA)`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
		if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
	}
	string $NameStart = ("LOC"+$CurveItem[0]+"START");
	string $NameEnd = ("LOC"+$CurveItem[0]+"END");
	string $LocSTART[] = `spaceLocator -p 0 0 0 -n $NameStart`;
	MoveObject2($EACHCVposAZ);
	string $LocEND[] = `spaceLocator -p 0 0 0 -n $NameEnd`;
	MoveObject2($EACHCVposBZ);
	string $STARTENDcurveLocs[] = { $LocSTART[0], $LocEND[0]};
	$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
	editDisplayLayerMembers -noRecurse LocCurveEnds  $STARTENDcurveLocs;
	return $STARTENDcurveLocs;
}
///////////////////////
proc vector [] VecCurveEnds(string $CurveItem[]){
	vector $CurveLocArrayVec[];
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[]; float $EACHCVposBZ[]; int $numIntZB = 0; string $MakeXBetweenB[];
	float $eachCVpos[];	
	for ($eachZA in $CurveSelection) {       
		$eachCVpos = `pointPosition -w ($eachZA)`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
		if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
	}
	$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;
	return $CurveLocArrayVec;
}
///////////////////////
proc vector [] VecCurveEps(string $CurveItem ){
	vector $CurveLocArrayVec[];
	string $CurveSelection[];
	$CurveSelection = `ls -fl ($CurveItem+".ep[0:*]")`; 
	float $EACHCVposAZ[];	
	for ($eachZA in $CurveSelection) {       
		$EACHCVposAZ = `pointPosition -w ($eachZA)`;
		$CurveLocArrayVec[`size($CurveLocArrayVec)`]= << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	}
	return $CurveLocArrayVec;
}
///////////////////////
proc float [] TransObjSelectedWorld(){
	string $ItemSel[] = `ls -sl`;
	float $pointAZ1[] = `xform -q -ws -t $ItemSel[0]`;
	return $pointAZ1;
}
////
proc vector[] PointArrayT(string $ObjectList[]){
	float $pointAZ1[];
	vector $VecArray[];
	int $XiV = 0;
	for ($each in $ObjectList){
		if (catch($pointAZ1 = `xform -q -ws -t ($each)`)){
			$pointAZ1 = `pointPosition -w ($each)`;
		} 
		$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
		$XiV++;
	}
	return $VecArray;
}
proc vector[] PointArray(string $ObjectList[]){
	float $pointAZ1[];
	vector $VecArray[];
	int $XiV = 0;
	for ($each in $ObjectList){
		if (catch($pointAZ1 = `pointPosition -w ($each)`)){
			$pointAZ1 = `xform -q -ws -rp ($each)`;
		} 
		$VecArray[$XiV] = <<$pointAZ1[0], $pointAZ1[1], $pointAZ1[2]>>;
		$XiV++;
	}
	return $VecArray;
}
////////////////////////////////////////
proc string [] GetObjectsInFrontOfPlane2(string $Loc[], vector $VecArray[], vector $VecArrayRemainsB[] ){
	float $CamPlane1[];
	//$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	$CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	string $ObjectList[];
	int $IndexVec = 0;
	vector $VecArrayRemains[];
	int $IndexVecRemain = 0;
	string $ObjectsInFrontOfPlane[];
	clear $ObjectsInFrontOfPlane;
	for ($eachPoint in $VecArray){
		float $ObjectToCam = distance2Pts( $CamPlane1, $VecArray[$IndexVec]);
		float $ObjectToCamShiftA[] = MovePointDirectionAndDistance( $CamerasDirectionVectorNormal, 10.5, $VecArray[$IndexVec]);
		float $ObjToCamdistShiftDiff = distance2Pts( $CamPlane1, $ObjectToCamShiftA);
		if($ObjToCamdistShiftDiff<$ObjectToCam){
			stringArrayInsertAtIndex(`size($ObjectsInFrontOfPlane)`, $ObjectsInFrontOfPlane, $Loc[$IndexVec]);
			$VecArrayRemains[$IndexVecRemain]= $VecArray[$IndexVec];
			$IndexVecRemain++;
		}
		$IndexVec++;
	}
	$VecArrayRemainsB = $VecArrayRemains;
	return $ObjectsInFrontOfPlane;
}
proc string [] GetObjectsInFrontOfPlane(string $Loc[], vector $VecArrayRemainsB[] ){
	float $CamPlane1[];
	//$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	$CamPlane1 = `xform -q -ws -t LiveSurfaceB`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	string $ObjectList[];
	vector $VecArray[] = PointArrayT($Loc);
	int $IndexVec = 0;
	vector $VecArrayRemains[];
	int $IndexVecRemain = 0;
	string $ObjectsInFrontOfPlane[];
	clear $ObjectsInFrontOfPlane;
	for ($eachPoint in $VecArray){
		float $ObjectToCam = distance2Pts( $CamPlane1, $VecArray[$IndexVec]);
		float $ObjectToCamShiftA[] = MovePointDirectionAndDistance( $CamerasDirectionVectorNormal, 10.5, $VecArray[$IndexVec]);
		float $ObjToCamdistShiftDiff = distance2Pts( $CamPlane1, $ObjectToCamShiftA);
		if($ObjToCamdistShiftDiff<$ObjectToCam){
			stringArrayInsertAtIndex(`size($ObjectsInFrontOfPlane)`, $ObjectsInFrontOfPlane, $Loc[$IndexVec]);
			$VecArrayRemains[$IndexVecRemain]= $VecArray[$IndexVec];
			$IndexVecRemain++;
		}
		$IndexVec++;
	}
	$VecArrayRemainsB = $VecArrayRemains;
	return $ObjectsInFrontOfPlane;
}
/////////////////////
//vector $AllPlaneLocPositions[]
proc int [] CreateIntIndex(int $ArraySize){
	int $iNdex = 0;
	int $IntArrayInex[];
	while($iNdex < $ArraySize){
		$IntArrayInex[$iNdex] = $iNdex;
		$iNdex++;
	}
	return $IntArrayInex;
}
proc DisRotPiv(){
	string $CurveItemZ[]=`ls -sl`;
	setAttr ($CurveItemZ[0]+".displayRotatePivot") 1;
}
proc string [] PointInNurbPlane(vector $AllPlaneLocPosition[], string $ObjectsInFront[], int $Newindex[], int $Locint ){
	string $EdgesSurface[];
	clear $EdgesSurface;
	$EdgesSurface[0] = "LiveSurfaceBShape.cv[0][0]" ;
	$EdgesSurface[1] = "LiveSurfaceBShape.cv[0][3]" ;
	$EdgesSurface[2] = "LiveSurfaceBShape.cv[3][3]" ;
	$EdgesSurface[3] = "LiveSurfaceBShape.cv[3][0]" ;
	///////////////////////////////
	vector $SurfEnds[] = PointArray($EdgesSurface);
	/////////////////
	vector $MiddlePointA[];
	//you only need to points but oh well....
	$MiddlePointA[0] = FloatToVec(MidPoint($SurfEnds[0], $SurfEnds[1]));
	$MiddlePointA[1] = FloatToVec(MidPoint($SurfEnds[1], $SurfEnds[2]));
	$MiddlePointA[2] = FloatToVec(MidPoint($SurfEnds[2], $SurfEnds[3]));
	$MiddlePointA[3] = FloatToVec(MidPoint($SurfEnds[3], $SurfEnds[0]));
	//float $AveragePoints[] =  AverageVectorPoint( $MiddlePointA);
	float $AveragePoints[] = `xform -q -ws -t LiveSurfaceB`;
	vector $DirectionsToCent[];
	clear $DirectionsToCent;
	for ($each in $MiddlePointA){
		float $Direct[] = DirectionF( $each, $AveragePoints);
		$DirectionsToCent[size($DirectionsToCent)] = <<$Direct[0], $Direct[1], $Direct[2]>>;
	}
	float $PlaneDimentionsV = distance2Pts( $SurfEnds[0], $SurfEnds[1]);
	float $PlaneDimentionsH = distance2Pts( $SurfEnds[1],$SurfEnds[3]);
	int $IndexV[] = CreateIntIndex(`size($AllPlaneLocPosition)`);
	float $RadiusMax = distance2Pts( $AveragePoints, $SurfEnds[0]);
	int $IndexReduced[];
	float $FoundDistance;
	int $indexRecord = 0;
	vector $firstReduction[];
	for ($eachVec in $AllPlaneLocPosition){
		$FoundDistance = distance2Pts( $AveragePoints, $eachVec);
		if($FoundDistance<=$RadiusMax){
			$IndexReduced[`size($IndexReduced)`] = $IndexV[$indexRecord];
			$firstReduction[`size($firstReduction)`]= $eachVec;
		}
		$indexRecord++;
	}
	float $PlaneDimentionsVH = $PlaneDimentionsV/100;
	float $PlaneDimentionsHH = $PlaneDimentionsH/100;
	int $indexPoints = 0;
	vector $PointsZ[] = $firstReduction;
	vector $AllPointsInplane[];
	int $Lastindex = 0;
	int $lastIntIndex[];
	int $indexM = 0;
	int $FourDiections = 0;
	for ($eachPoint in $firstReduction){
		float $LocPoint[] = $eachPoint;
		$indexM = 0;
		$FourDiections = 0;
		float $MultDirAV[];
		for ($each in  $DirectionsToCent){
			float $DistanceA = distance2Pts( $MiddlePointA[$indexM],  $LocPoint);
			if(($indexM==0)||($indexM==2)){
				$MultDirAV= multiplyFloat($PlaneDimentionsVH, $each);
			}
			if(($indexM==1)||($indexM==3)){
				$MultDirAV= multiplyFloat($PlaneDimentionsHH, $each);
			}
			float $FloatDirectionPointz[] = AddFloats($MultDirAV, $LocPoint);
			float $DistanceB = distance2Pts( $MiddlePointA[$indexM],  $FloatDirectionPointz);
			if( $DistanceB > $DistanceA){
				$FourDiections++;
			}
			$indexM++;
		}
		if( $FourDiections == 4 ){
			$AllPointsInplane[`size($AllPointsInplane)`]= $eachPoint;
			$lastIntIndex[$Lastindex]=  $IndexReduced[$indexPoints];
			$Lastindex++;
		}
		$indexPoints++;
	}
	string $allObjectsInPlane[];
	for ($eachNumber in $lastIntIndex){
		stringArrayInsertAtIndex(`size($allObjectsInPlane)`, $allObjectsInPlane, $ObjectsInFront[$eachNumber]);
	}
	$Newindex = $lastIntIndex;
	vector $NewVecArray[];
	for ($eachNumber in $lastIntIndex){
		$NewVecArray[`size($NewVecArray)`] =$AllPlaneLocPosition[$eachNumber];
	}
	$AllPlaneLocPosition=$NewVecArray;
	//Adaption here to create 2d plane Locators from 3d Locators with original name appended to the new ones
	if($Locint==1){
		int $inDexName =0;
		for ($each in $AllPointsInplane){
			string $stringName = ("Plane"+ $allObjectsInPlane[$inDexName]);
			spaceLocator -p 0 0 0 -n $stringName;
			MoveObject2($each);
			scale -r 0.01 0.01 0.01;
			editDisplayLayerMembers -noRecurse LocOnLivePlaneB $stringName;
			$inDexName++;
		}
	}
	return $allObjectsInPlane;
	//END
}
//string $allPointToPlane[] = EachPointToCameraPlane;
proc string [] EachPointToCameraPlane(){
	string $AllPointsInplaneX[];
	string $selectionlist[] = `ls -sl -fl`;
	for ($each in $selectionlist){
		string $PlanePointA = `PointToCameraPlane $each`;
		stringArrayInsertAtIndex(`size $AllPointsInplaneX`, $AllPointsInplaneX, $PlanePointA);
	}
	return $AllPointsInplaneX;
}
/*
//build comp
string $CurveItemAa[] = `ls -sl`;
flaot $FLoatCurveStart[];
IfstraitFindCurveOthoDirection($CurveItemAa);
*/
proc float [] IfstraitFindCurveOthoDirection(string $CurveItemA[]){
	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	float $MultDirCam[] = multiplyFloat(-3, $CamerasDirectionVector);
	float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
	float $DirectionVectorXn[] = {-2,0,0};
	float $DirectionVectorX[] = {2,0,0};
	float $DirectionVectorYn[] = {0,2,0};
	float $DirectionVectorY[] = {0,-2,0};
	float $DirectionVectorZn[] = {0,0,-2};
	float $DirectionVectorZ[] = {0,0,2};
	vector $VecDirectionXYZ[];
	$VecDirectionXYZ[0] = <<-1,0,0>>;
	$VecDirectionXYZ[1] = <<1,0,0>>;
	$VecDirectionXYZ[2] = <<0,1,0>>;
	$VecDirectionXYZ[3] = <<0,-1,0>>;
	$VecDirectionXYZ[4] = <<0,0,-1>>;
	$VecDirectionXYZ[5] = <<0,0,1>>;
	float $FloatPointDirectionXn[] = AddFloats($CamPos1, $DirectionVectorXn);
	float $FloatPointDirectionX[] = AddFloats($CamPos1, $DirectionVectorX);
	float $FloatPointDirectionY[] = AddFloats($CamPos1, $DirectionVectorY);
	float $FloatPointDirectionYn[] = AddFloats($CamPos1, $DirectionVectorYn);
	float $FloatPointDirectionZn[] = AddFloats($CamPos1, $DirectionVectorZn);
	float $FloatPointDirectionZ[] = AddFloats($CamPos1, $DirectionVectorZ);
	vector $VecXYZs[5];
	clear $VecXYZs;
	$VecXYZs[0] = FloatToVec($FloatPointDirectionXn);
	$VecXYZs[1] = FloatToVec($FloatPointDirectionX);
	$VecXYZs[2] = FloatToVec($FloatPointDirectionY);
	$VecXYZs[3] = FloatToVec($FloatPointDirectionYn);
	$VecXYZs[4] = FloatToVec($FloatPointDirectionZn);
	$VecXYZs[5] = FloatToVec($FloatPointDirectionZ);
	vector $VecXYZsOnPlane[]= VecPointsToCameraPlane($VecXYZs);
	float $AverageVecXYZsOnP[] =  AverageVectorPoint($VecXYZsOnPlane);
	/*
float $FloatDirXn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[0]);
float $FloatDirX[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[1]);
float $FloatDirY[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[2]);
float $FloatDirYn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[3]);
float $FloatDirZn[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[4]);
float $FloatDirZ[] = DirectionF($AverageVecXYZsOnP, $VecXYZs[5]);
*/
	string $DirectionsZ[] = { "Xn", "X", "Y", "Yn", "Zn", "Z"};
	vector $FloatDirxyz[5];
	$FloatDirxyz[0] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[0]));
	$FloatDirxyz[1] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[1]));
	$FloatDirxyz[2] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[3]));
	$FloatDirxyz[3] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[2]));
	$FloatDirxyz[4] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[4]));
	$FloatDirxyz[5] = FloatToVec (DirectionF($AverageVecXYZsOnP, $VecXYZs[5]));
	//string $CurveItemA[] = `ls -sl`;
	vector $VecCurEnds[] = VecCurveEnds($CurveItemA);
	// $FLoatCurveStart = $VecCurEnds[0];
	float $CurveDirectionZ[] = DirectionF($VecCurEnds[0], $VecCurEnds[1]);
	vector $CurveDirVec[];
	$CurveDirVec[0] = FloatToVec($CurveDirectionZ);
	float $DistDirsZz[];
	clear $DistDirsZz;
	for ($eachVec in $FloatDirxyz){
		$DistDirsZz[`size($DistDirsZz)`] = distance2Pts( $CurveDirectionZ, $eachVec );
	}
	string $DirIndex[] = { "0", "1", "2", "3", "4", "5"};
	string $EmptyStringNewOrderxyZA[];
	float $NewfloatsZ[];
	$NewfloatsZ = SortFloatArrayAndString($DistDirsZz, $DirIndex, $EmptyStringNewOrderxyZA);
	int $indexN = $EmptyStringNewOrderxyZA[0];
	float $directionIs[] = $VecDirectionXYZ[$indexN];
	return $directionIs;
}
proc string PointToCameraPlane(string $ObjectLocZx){
	//Demo Locator to see that the code is doing ####
	//string $LocA2[] ;
	//clear $LocA2;
	//Loc {0, 0, 0};
	//string $LocA2[] = `ls -sl`;
	//Demo Locator to see that the code is doing ####
	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	string $Loc[0] = {$ObjectLocZx};
	float $LocPos1[];
	$LocPos1 = `xform -q -ws -t $Loc[0]`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	float $MultDirCam[] = multiplyFloat(3, $CamerasDirectionVector);
	float $FloatDirectionCamNormalA[] = AddFloats($CamPos1, $MultDirCam);
	float $FloatDirectionA[] = DirectionF($CamPos1, $LocPos1);
	float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
	float $DistanceLocA = $DistanceLoc;
	$DistanceLoc = $DistanceLoc * -1;
	float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
	float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
	float $CamerasDirectionVectorA[] = DirectionF($FloatDirectionCamNormal, $CamPos1);
	//MoveItemToPoint($LocA2[0], $CamerasDirectionVectorA);
	//Now True Normal..
	float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
	$FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
	float $p1[] = $CamPos1;
	float $p2[] = $LocPos1;
	float $p3[] = $FloatDirectionCamNormal;
	float $center[]; 
	float $normal[];
	// Get the vector p1-p2, p1-p3	
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
	// Get the normal to the plane formed by p1, p2, p3, which is the
	// cross prod of p1-p2 and p1-p3	
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
	/////////////////////
	//float $OrthoCenterC = midPoint2Pts( $FloatPos1, $p3 );
	float $FloatPosZero[] = {0, 0, 0};
	float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
	///////////////////////
	// Get the mid pts on each vector (the average of two pts)
	float $mid1[3], $mid2[3], $mid3[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );
	$mid3 = midPoint2Pts( $p2, $p3 );
	//$mid1 a-b $mid2 a-c $mid3 b-c
	// Get the perp. vectors to p1-p2 and p1-p3, which is the
	// cross prod of the normal vector with p1-p2 and p1-p3. Get these
	// as normalized vectors before sending them to lineIntersection	 
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
	// Intersect the persp. vectors going through the mid pts.// The intersection is the center of the arc.	
	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
	//FloatDirPerpCenter is FloatDirPerpCenterA
	float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
	float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
	float $FloatDirPointAC[] = DirectionF($p1, $p3);
	float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );	
	float $FloatDirLocToPerpIntersect[] = DirectionF($p2, $center8);
	float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
	float $LivePlanePos[];
	$LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
	float $FloatDirLocToPerpIntersect[] = DirectionF($center8,$p2);
	//float $FloatDirectionB[] = DirectionF($CamPos1,$LocPos1);
	float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );	
	spaceLocator -p 0 0 0;
	MoveObject2($OnPlane);
	string $LocB2[] = `ls -sl`;
	setAttr ($LocB2[0]+".scale") .01 .01 .01;
	// Find the radius for the circle and return the radius.
	//float $radiusZ = distance2Pts( $p1, $center );
	//string $circlesItem[];
	//$circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);
	return $LocB2[0];
}
/*
float $LivePlanePos[];
$LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
*/
proc vector [] VecPointsToCameraPlane(vector $LocPositions[]){
	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	float $LivePlanePos[];
	$LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	int $indexVecs = 0;
	vector $LocsToPlane[];
	for ($LocPos1 in $LocPositions){
		float $FloatDirectionA[] = DirectionF($CamPos1, $LocPos1);
		float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
		float $DistanceLocA = $DistanceLoc;
		$DistanceLoc = $DistanceLoc * -1;
		float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
		float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
		float $CamerasDirectionVectorA[] = DirectionF($FloatDirectionCamNormal, $CamPos1);
		//Now True Normal..
		float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
		$FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
		float $p1[] = $CamPos1;
		float $p2[] = $LocPos1;
		float $p3[] = $FloatDirectionCamNormal;
		float $center[]; 
		float $normal[];
		// Get the vector p1-p2, p1-p3	
		float $p1p2[3];
		float $p1p3[3];
		$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
		$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
		// Get the normal to the plane formed by p1, p2, p3, which is the
		// cross prod of p1-p2 and p1-p3	
		float $normal[3];
		$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
		/////////////////////
		//float $OrthoCenterC = midPoint2Pts( $FloatPos1, $p3 );
		float $FloatPosZero[] = {0, 0, 0};
		float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
		// Get the mid pts on each vector (the average of two pts)
		float $mid1[3], $mid2[3], $mid3[3];
		$mid1 = midPoint2Pts( $p1, $p2 );
		$mid2 = midPoint2Pts( $p1, $p3 );
		$mid3 = midPoint2Pts( $p2, $p3 );
		//$mid1 a-b $mid2 a-c $mid3 b-c
		// Get the perp. vectors to p1-p2 and p1-p3, which is the
		// cross prod of the normal vector with p1-p2 and p1-p3. Get these
		// as normalized vectors before sending them to lineIntersection	 
		float $perp_p1p2[3];
		float $perp_p1p3[3];
		$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
		$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
		// Intersect the persp. vectors going through the mid pts.// The intersection is the center of the arc.	
		float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
		//FloatDirPerpCenter is FloatDirPerpCenterA
		//float $FloatDirPerpCenter[] = DirectionF($center, $mid3);
		float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
		float $FloatDirPointAC[] = DirectionF($p1, $p3);
		float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );	
		float $FloatDirLocToPerpIntersect[] = DirectionF($p2, $center8);
		float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
		//string $C = curve2points($center, $mid1);
		//editDisplayLayerMembers -noRecurse layerMidPoint $C;
		//string $D = curve2points($center,$mid2);
		//editDisplayLayerMembers -noRecurse layerMidPoint $D;
		//string $E = curve2points($center,$mid3);
		//editDisplayLayerMembers -noRecurse layerMidPoint $E;
		//float $radiusZ = distance2Pts( $p1, $center );
		//string $circlesItem[];
		//$circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);
		//editDisplayLayerMembers -noRecurse layerMidPoint $circlesItem[0];
		float $FloatDirLocToPerpIntersect[] = DirectionF($center8,$p2);
		//float $FloatDirectionB[] = DirectionF($CamPos1,$LocPos1);
		float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );	
		$LocsToPlane[$indexVecs] = << $OnPlane[0], $OnPlane[1], $OnPlane[2] >>;
		$indexVecs++;
	}
	return $LocsToPlane;
}
proc float[] MirrorFloatXYZ(int $XYZ, float $ThreeFLoatArrays[]){
	float $Zx[] = $ThreeFLoatArrays;
	$Zx[$XYZ] *= -1.0;
	return $Zx;
}
proc float [] FloatPointsToCamPlane(float $LocPos1[]){
	float $Pi = 3.1415926535;
	float $pi = 3.1415926535;
	float $CamPos1[];
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	float $LivePlanePos[];
	$LivePlanePos = `xform -q -ws -t LiveSurfaceB`;
	float $CamerasDirectionVectorNormal[] =  nurbsViewDirectionVectorCam("ZCURVEModelingCAM", 0);
	float $CamerasDirectionVector[] = $CamerasDirectionVectorNormal;
	float $FloatDirectionA[] = DirectionF($CamPos1, $LocPos1);
	float $DistanceLoc = distance2Pts( $LocPos1, $CamPos1 );
	float $DistanceLocA = $DistanceLoc;
	$DistanceLoc = $DistanceLoc * -1;
	float $MultDirPC1[] = multiplyFloat($DistanceLoc, $CamerasDirectionVector);
	float $FloatDirectionCamNormal[] = AddFloats($CamPos1, $MultDirPC1);
	float $CamerasDirectionVectorA[] = DirectionF($FloatDirectionCamNormal, $CamPos1);
	//Now True Normal..
	float $MultDirPC1A[] = multiplyFloat($DistanceLoc, $CamerasDirectionVectorA);
	$FloatDirectionCamNormal = AddFloats($CamPos1, $MultDirPC1A);
	float $p1[] = $CamPos1;
	float $p2[] = $LocPos1;
	float $p3[] = $FloatDirectionCamNormal;
	float $center[]; 
	float $normal[];
	// Get the vector p1-p2, p1-p3	
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; 		$p1p2[1] = $p2[1]-$p1[1]; 		$p1p2[2]= $p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; 		$p1p3[1] = $p3[1]-$p1[1]; 		$p1p3[2]= $p3[2]-$p1[2];
	// Get the normal to the plane formed by p1, p2, p3, which is the
	// cross prod of p1-p2 and p1-p3	
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );
	/////////////////////
	//float $OrthoCenterC = midPoint2Pts( $FloatPos1, $p3 );
	float $FloatPosZero[] = {0, 0, 0};
	float $FloatDirection[] = DirectionF($FloatPosZero, $normal);
	// Get the mid pts on each vector (the average of two pts)
	float $mid1[3], $mid2[3], $mid3[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );
	$mid3 = midPoint2Pts( $p2, $p3 );
	//$mid1 a-b $mid2 a-c $mid3 b-c
	// Get the perp. vectors to p1-p2 and p1-p3, which is the
	// cross prod of the normal vector with p1-p2 and p1-p3. Get these
	// as normalized vectors before sending them to lineIntersection	 
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );
	// Intersect the persp. vectors going through the mid pts.// The intersection is the center of the arc.	
	float $center[] = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );
	float $FloatDirPerpCenterC[] = DirectionF($center,$mid2);
	float $FloatDirPointAC[] = DirectionF($p1, $p3);
	float $center8[] = lineIntersection( $p2,  $FloatDirPerpCenterC, $p1, $FloatDirPointAC );	
	float $DistanceLocToToPerpIntersect = distance2Pts( $p2, $center8);
	float $FloatDirLocToPerpIntersect[] = DirectionF($center8,$p2);
	float $OnPlane[] = lineIntersection( $LivePlanePos, $FloatDirLocToPerpIntersect, $CamPos1, $FloatDirectionA );	
	return $OnPlane;
}
proc string [] EachPointToCameraPlaneString(string $selectionlist[]){
	string $AllPointsInplaneX[];
	for ($each in $selectionlist){
		string $PlanePointA = `PointToCameraPlane $each`;
		stringArrayInsertAtIndex(`size $AllPointsInplaneX`, $AllPointsInplaneX, $PlanePointA);
	}
	return $AllPointsInplaneX;
}
/*
// Find the radius for the circle and return the radius.
//float $radiusZ = distance2Pts( $p1, $center );
//string $circlesItem[];
//$circlesItem[0] = Circles_Direction($center, $FloatDirection, $radiusZ);
//////////////////////
*/
proc float[] nurbsViewDirectionVectorCam( string $cameraName , int $onlyOrtho )
//  Description :
//      Get camera view direction as a normalized vector.
//      If $onlyOrtho flag is set to true, this is done for the orthogonal
//      cameras only; the perspective cameras get the default up direction
//      returned as the result.
//
{
	float $result[];
	string $isitYup = `upAxis -q -ax $cameraName`;
	if( "y" == $isitYup ) {
		$result[0] = 0.0 ;
		$result[1] = 1.0 ;
		$result[2] = 0.0 ;
	}
	else {
		$result[0] = 0.0 ;
		$result[1] = 0.0 ;
		$result[2] = 1.0 ;
	}
	string $forTheWarning = "Failed to compute active camera view direction." +
	"  Using the default (" + $result[0] + "," +
	$result[1] + "," + $result[2] + ")";
	
	if( $onlyOrtho && !`camera -q -o $cameraName` ) {
		// Don't do anything for perspective cameras...
		return $result;
	}
	float $coiDistance = 0.0 ;
	if( catch( $coiDistance = `camera -q -coi $cameraName` )) {
		warning $forTheWarning;
		return $result ;
	}
	// save the selection list because createNode changes it.
	// Later, we need this to restore the selection list.
	string $selectionList[] = `ls -sl`;
	string $ppm ;
	if( catch($ppm = `createNode pointMatrixMult`) ) {
		warning $forTheWarning;
		select -r $selectionList;
		return $result ;
	}
	// restore the selection list
	//
	select -r $selectionList;
	// compute the view direction.
	//
	setAttr ($ppm +".inPoint") -type double3 0.0 0.0 (-$coiDistance) ;
	setAttr ($ppm +".vectorMultiply") true ;
	connectAttr ($cameraName+".worldMatrix[0]") ($ppm+".inMatrix") ;
	float $coi[] = `getAttr ($ppm+".output")` ;
	delete $ppm ;
	// fill up the result.
	//
	int $i ;
	float $sum = 0;
	for( $i = 0 ; $i < 3 ; $i++ ) {
		$sum += ($coi[$i] * $coi[$i]);
		$result[$i] = $coi[$i];
	}
	if( $sum > 0 ) {
		$sum = -1.0/sqrt($sum);
		for( $i = 0 ; $i < 3 ; $i++ ) {
			$result[$i] = $result[$i] * $sum;
		}
	}
	return $result ;
}
//END of Procs
///////////////////////
///////////////////////
///////////////////////
proc string Loc(float $Points[]){
	string $LocObjects[] = `spaceLocator -p 0 0 0`;
	setAttr ($LocObjects[0]+".translate")  $Points[0] $Points[1] $Points[2];
	return $LocObjects[0];
}
proc string [] FloatArrayToStringArray(float $FloatArray[]){
	string $floatnumbers;
	int $xIi =0;
	for($each in $FloatArray){
		$floatnumbers +=  $FloatArray[$xIi]+" ";
		$xIi++;
	}
	string $array[];
	$array = stringToStringArray($floatnumbers, " ");
	return $array;
}
///////////////////////////////////////////////
proc float [] SortFloatArrayAndString(float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[]){
	int $ArrayIndexTrack[] = CreateIntIndex(`size($allFloatToSort)`);
	int $OriginalIndexTrack[] = $ArrayIndexTrack;
	float $Floatlist[] = $allFloatToSort;
	string $stringFloat[]= FloatArrayToStringArray($Floatlist);
	string $stringIndexTrack[]= IntArrayToStringArray($ArrayIndexTrack);
	float $FloatlistIterat[0];
	//Start Default Best in best of each alg
	//
	$FloatlistIterat[0]=$Floatlist[0];
	int $TotalsizeIndex=(`size($Floatlist)`)-1;
	float $FloatlistAll[]=$Floatlist;
	string $arrayElement;
	string $IndexElement;
	int $NextIndex =0;
	int $allsize=0;
	int $ix =0;
	int $iix =0;
	int $NewIndex = 0;
	float $FloatlistNew[];
	//////////////////////////
	for ($All in $Floatlist){
		$ix =1;
		$iix =0;
		$NewIndex = 0;
		$allsize =(`size($FloatlistAll)`-1);
		if($allsize==0){break;}
		for ($eachNumber in $FloatlistAll){
			if($ix<$allsize){
				if($FloatlistAll[$ix]<$FloatlistIterat[0]){
					//remove at idex ix and place at index 0// 
					$NewIndex = $NextIndex+$ix;
					$arrayElement = $stringFloat[$NewIndex];
					$FloatlistIterat[0] = $arrayElement;
					stringArrayRemoveAtIndex($NewIndex, $stringFloat);
					stringArrayInsertAtIndex($NextIndex, $stringFloat, $arrayElement);
					/////////////////////////////////////////////
					$IndexElement = $stringIndexTrack[$NewIndex];
					stringArrayRemoveAtIndex($NewIndex, $stringIndexTrack);
					stringArrayInsertAtIndex($NextIndex, $stringIndexTrack, $IndexElement);
					//print $stringIndexTrack[$NewIndex];
					//print $stringIndexTrack[$NextIndex];
					/////////////////////////////////////////////
				}
			}
			$ix++;
		}
		$FloatlistNew = StringArrayToFloatArray($stringFloat);
		int $Siz =`size($FloatlistNew)`;
		int $iEnd =0;
		int $iNext=1;
		int $iNext2=2;
		for ($eachNumber in $FloatlistNew){
			if( $iEnd==$Siz ){
				break;
			}
			if(!($FloatlistNew[$iEnd]< $FloatlistNew[$iNext])){
				break;
			}
			if(($FloatlistNew[$iEnd]< $FloatlistNew[$iNext])){
				$iNext++;
				$iNext2++;
				$iEnd++;
			}
			if(!($FloatlistNew[$iEnd]< $FloatlistNew[$iNext])){
				break;
			}
		}
		if(!($iEnd==$TotalsizeIndex)){ 
			string $stringArrayRemaining[] = $stringFloat;
			$StringFloatlist = StringArrayToFloatArray($stringArrayRemaining);
			stringArrayRemoveToIndex($iEnd, $stringArrayRemaining);
			clear $FloatlistAll;
			$FloatlistAll = StringArrayToFloatArray($stringArrayRemaining);
			$FloatlistIterat = $FloatlistAll;
			$NextIndex = $iEnd;
			$iix++;
		}else{break;}
	}
	string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
	$EmptyStringNewOrder = $newOrderArray;
	float $OrderedFloat[] = StringArrayToFloatArray($stringFloat);
	return $OrderedFloat;
}
/*
for ($eachNumber in $FloatlistNew){
if( $iEnd==$Siz ){
break;
}
if(!($FloatlistNew[$iNext]< $FloatlistNew[$iNext2])){
break;
}
$iNext++;
$iNext2++;
$iEnd++;
}
*/
proc float [] SortFloatArrayAndString(float $allFloatToSort[], string $ObjsCurve[], string $EmptyStringNewOrder[]){
	int $ArrayIndexTrack[] = CreateIntIndex(`size($allFloatToSort)`);
	int $OriginalIndexTrack[] = $ArrayIndexTrack;
	float $Floatlist[] = $allFloatToSort;
	string $stringFloat[]= FloatArrayToStringArray($Floatlist);
	string $stringIndexTrack[]= IntArrayToStringArray($ArrayIndexTrack);
	float $FloatlistIterat[0];
	//Start Default Best in best of each alg
	//
	$FloatlistIterat[0]=$Floatlist[0];
	int $TotalsizeIndex=(`size($Floatlist)`)-1;
	float $FloatlistAll[]=$Floatlist;
	string $arrayElement;
	string $IndexElement;
	int $NextIndex =0;
	int $allsize=0;
	int $ix =0;
	int $iix =0;
	int $NewIndex = 0;
	float $FloatlistNew[];
	//////////////////////////
	for ($All in $Floatlist){
		$ix =1;
		$iix =0;
		$NewIndex = 0;
		$allsize =(`size($FloatlistAll)`-1);
		if($allsize==0){break;}
		for ($eachNumber in $FloatlistAll){
			if($ix<=$allsize){
				if($FloatlistAll[$ix]<$FloatlistIterat[0]){
					//remove at idex ix and place at index 0// 
					$NewIndex = $NextIndex+$ix;
					$arrayElement = $stringFloat[$NewIndex];
					$FloatlistIterat[0] = $arrayElement;
					stringArrayRemoveAtIndex($NewIndex, $stringFloat);
					stringArrayInsertAtIndex($NextIndex, $stringFloat, $arrayElement);
					/////////////////////////////////////////////
					$IndexElement = $stringIndexTrack[$NewIndex];
					stringArrayRemoveAtIndex($NewIndex, $stringIndexTrack);
					stringArrayInsertAtIndex($NextIndex, $stringIndexTrack, $IndexElement);
					//print $stringIndexTrack[$NewIndex];
					//print $stringIndexTrack[$NextIndex];
					/////////////////////////////////////////////
				}
			}
			$ix++;
		}
		$FloatlistNew = StringArrayToFloatArray($stringFloat);
		int $iEnd =0;
		int $iNext=1;
		for ($eachNumber in $FloatlistNew){
			if(!($FloatlistNew[$iEnd]< $FloatlistNew[$iNext])){
				break;
			}
			$iNext++;
			$iEnd++;
		}
		if(!($iEnd==$TotalsizeIndex)){ 
			string $stringArrayRemaining[] = $stringFloat;
			$StringFloatlist = StringArrayToFloatArray($stringArrayRemaining);
			stringArrayRemoveToIndex($iEnd, $stringArrayRemaining);
			clear $FloatlistAll;
			$FloatlistAll = StringArrayToFloatArray($stringArrayRemaining);
			$FloatlistIterat = $FloatlistAll;
			$NextIndex = $iEnd;
			$iix++;
		}else{break;}
	}
	string $newOrderArray[] = NewArrayOrderWithIndexKey($stringIndexTrack, $ObjsCurve);
	$EmptyStringNewOrder = $newOrderArray;
	float $OrderedFloat[] = StringArrayToFloatArray($stringFloat);
	return $OrderedFloat;
}
//print $stringIndexTrack;
//print $stringFloat;
//print $ObjsCurve;
//print $newOrderArray;
proc string [] NewArrayOrderWithIndexKey(string $stringIndexTrack[], string $ObjsCurve[]){
	string $newOrderArray[];
	int $iNew;
	for($each in $stringIndexTrack){
		$iNew = $each;
		stringArrayInsertAtIndex(`size($newOrderArray)`, $newOrderArray, $ObjsCurve[$iNew]);
	}
	return $newOrderArray;
}
proc vector[] NewVecOrderWithIndexKey(string $stringIndexTrack[], vector $ObjsCurve[]){
	vector $newOrderVec[];
	for($eachV in $stringIndexTrack){
		int $iNew = $eachV;
		$newOrderVec[`size($newOrderVec)`] = $ObjsCurve[$iNew];
	}
	return $newOrderVec;
}
proc string [] IntArrayToStringArray(int $IntArray[]){
	string $Intnumbers;
	for($each in $IntArray){
		$Intnumbers += $each+" ";
	}
	string $array[];
	$array = stringToStringArray($Intnumbers, " ");
	return $array;
}
proc stringArrayRemoveToIndex(int $ix, string $stringArray[]){
	int $ixX= 0;
	while($ixX<$ix){
		stringArrayRemoveAtIndex(0, $stringArray);
		$ixX++;
	}
}
proc MatchCurveLengthToCurve(){
	string $Objs[] =`ls -sl`;
	int $sizeCs = (`size($Objs)`)-1;
	string $ObjsEnd[] =`ls -tl $sizeCs $Objs`;
	string $ObjsFirst[] =`ls -hd 1 $Objs`;
	float $compare = `arclen $ObjsFirst`;
	float $ArcLengthAdd;
	for($each in $ObjsEnd){
		$ArcLengths = `arclen $each`;
		$ArcLengthAdd = $compare - $ArcLengths;
		if($ArcLengthAdd>0){
			extendCurve -cos 0 -ch 1 -em 0 -et 0 -d $ArcLengthAdd  -s 0 -jn true -rmk true -rpo on $each ;
		}
	}
}
proc CurveLengthToFloat(float $Number){
	string $Objs[] =`ls -sl`;
	for($each in $Objs){
		$ArcLengths = `arclen $each`;
		$ArcLengthAdd = $Number - $ArcLengths;
		if($ArcLengthAdd>0){
			extendCurve -cos 0 -ch 1 -em 0 -et 0 -d $ArcLengthAdd  -s 0 -jn true -rmk true -rpo on $each ;
		}
	}
}
proc float TotalArcLength(){
	string $Objs[] =`ls -sl`;
	float $ArcLengths = 0.0;
	for($each in $Objs){
		$ArcLengths += `arclen $each`;
	}
	return $ArcLengths;
}
proc float [] ArcLengthArray(string $Objs[]){
	float $ArcLengths[];
	for($each in $Objs){
		$ArcLengths[`size($ArcLengths)`]= `arclen $each`;
	}
	return $ArcLengths;
}
/////////////nodeType -inherited///////VERY USEFUL Below...  computers are blind, teach them to see
proc string getSelectionType(){
	string $selectionFindType[] = `ls -sl -fl`;
	string $idnodeType2;
	string $Relativesselection[];
	$Relativesselection = `listRelatives $selectionFindType[0]`;
	if (`size($Relativesselection)` == 0){ string $idnodeType3[] = `nodeType -inherited $selectionFindType[0]`;
		int $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
		if($Value == 1){ $idnodeType2="controlPoint";}else{ $idnodeType2=$idnodeType3[(`size($idnodeType3)`)-1];}
	}else{ $idnodeType2 = `nodeType $Relativesselection[0]`;}
	return $idnodeType2;
}
proc string getTypeItemString(string $selectionFindType[]){
	$selectionFindType= `ls -fl $selectionFindType`;
	string $idnodeType2;
	string $Relativesselection[];
	$Relativesselection = `listRelatives $selectionFindType[0]`;
	if (`size($Relativesselection)` == 0){ string $idnodeType3[] = `nodeType -inherited $selectionFindType[0]`;
		int $Value = stringArrayGmatchFind($idnodeType3, "controlPoint");
		if($Value == 1){ $idnodeType2="controlPoint";}else{ $idnodeType2=$idnodeType3[(`size($idnodeType3)`)-1];}
	}else{ $idnodeType2 = `nodeType $Relativesselection[0]`;}
	return $idnodeType2;
}
proc CreateVectorInfoAtSelected(){
	string $oneItemz[] = `ls -sl -fl`;
	for ($each in $oneItemz){
		xform -cp $each;
		vector $worldPos = `xform -q -ws -t  $each`;
		string $type = getTypeItemString({$each});
		if(!($type == "controlPoint")){
			move -rpr 0 0 0 $each;
			makeIdentity -apply true  -t 1 -r 0 -s 0 $each;
			xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $each;
		}
		float $worldPosF[] = `xform -q -ws -t $each`;
		string $resultZa =("<< " +  $worldPos+" >>");
		string $textN[] = `textCurves -ch 0 -f "Times New Roman|h-2|w400|c0" -t $resultZa`;
		toggle -cv -state 0 -ep  -hull -normal -sf -origin;
		move -ws $worldPosF[0] $worldPosF[1] $worldPosF[2] $textN;
		string $UserCaM = `modelEditor -q -camera modelPanel4`; 
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $UserCaM $textN;
	}
}
////////////////////////////////////
proc int [] stringArrayGmatchArrayIndex(string  $itemA[], string $list[]){
	int $sizeitem = `size($itemA)`;
	int $result = false;	
	int $ResultIndex[];
	int $Index = 0;	
	int $BreakTrigger = 0;
	string $listItem;	
	for ($EachlistItem in $list) {
		for ($EachlistA in $itemA) {
			if ( $EachlistItem == $EachlistA ){
				$result = true; $ResultIndex[`size($ResultIndex)`] =  $Index;
				$BreakTrigger++;
				if ( $BreakTrigger == $sizeitem ){	break;	}
			}
		}
		$Index++;
	}	
	return $ResultIndex;
}
////////////////////////////////////
////////////////////////////////////
proc int stringArrayGmatchFind(string $itemsA[], string $Item){
	int $result = false;	
	for ($EachlistA in $itemsA) {
		if ( $EachlistA == $Item ){
			$result = true; 
			break;	}
	}	return $result;
}
proc float [] ArrayDistancesFloatsTofloat(float $allfloats[], float $point[]){
	float $AllDistances[];
	for ($each in $allfloats){
		$AllDistances[`size($AllDistances)`] = distance2Pts( {$each}, {$point[0]});
	}
	return $AllDistances;
}
////////////////////////////////////
//This is stupid ..not sure that the hell I used it in have to fix###########################################################
//####################################################@@@@@@@@@@@@@@@@%%%%***********^^^^!~~~!!!~!~!~!~!~!
//####################################################@@@@@@@@@@@@@@@@%%%%***********^^^^!~~~!!!~!~!~!~!~!
//II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II
//==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==
//II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II
//==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==
//II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II
//==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==II==
proc float PercentDiff(float $a, float $b){
	float $c;
	float $d;
	if($a>$b){ $c=$a; $d=$b;}else{$c=$b; $d=$a;}
	float $percent =  100/($c/$d);
	if($a==$b){$percent=0;}
	return $percent ;
}
////////////////////////////////////
if ( `objExists LocOnLivePlaneB` == 0  ) {
	createDisplayLayer -name "LocOnLivePlaneB" - number 1 -empty;
	setAttr LocOnLivePlaneB.color 9;
}
if ( `objExists LocCurveEnds` == 0  ) {
	createDisplayLayer -name "LocCurveEnds" - number 1 -empty;
	setAttr LocCurveEnds.color 13;
}
proc string [] NewArrayOrderWithIndexKey(string $stringIndexTrack[], string $ObjsCurve[]){
	string $newOrderArray[];
	int $iNew;
	for($each in $stringIndexTrack){
		$iNew = $each;
		stringArrayInsertAtIndex(`size($newOrderArray)`, $newOrderArray, $ObjsCurve[$iNew]);
	}
	return $newOrderArray;
}
///////////////////
proc string [] IntArrayToStringArray(int $IntArray[]){
	string $Intnumbers;
	for($each in $IntArray){
		$Intnumbers += $each+" ";
	}
	string $array[];
	$array = stringToStringArray($Intnumbers, " ");
	return $array;
}
////////////////
proc stringArrayRemoveToIndex(int $ix, string $stringArray[]){
	int $ixX= 0;
	while($ixX<$ix){
		stringArrayRemoveAtIndex(0, $stringArray);
		$ixX++;
	}
}
////////////////
proc string [] FloatArrayToStringArray(float $FloatArray[]){
	string $floatnumbers;
	for($each in $FloatArray){
		$floatnumbers += $each+" ";
	}
	string $array[];
	$array = stringToStringArray($floatnumbers, " ");
	return $array;
}
proc float[] StringArrayToFloatArray(string $FloatArray[]){
	float $floatnumbers[];
	for($each in $FloatArray){
		$floatnumbers[`size($floatnumbers)`]= $each;
	}
	return $floatnumbers;
}
proc stringArrayRemoveToIndex(int $ix, string $stringArray[]){
	int $ixX= 0;
	while($ixX<$ix){
		stringArrayRemoveAtIndex(0, $stringArray);
		$ixX++;
	}
}
proc float [] ArrayDistancesVecTofloat(vector $allVec[], float $point[]){
	float $AllDistances[];
	for ($each in $allVec){
		$AllDistances[`size($AllDistances)`] = distance2Pts( $each, $point);
	}
	return $AllDistances;
}
proc string[] ArrayFromAllinString(string $list){
	string $singleStringItemB[];
	string $singleStringItemA[];
	int $i = 0;
	int $Indexi = 0;
	int $triggerends = 0;
	string $listA = $list; 
	while ( $triggerends < 1 ) { 
		$i++;
		$singleStringItemA = {`substring $listA $i $i`};
		if (size($singleStringItemA[0]) == 0){
			$triggerends = 2; } else {
			appendStringArray($singleStringItemB, $singleStringItemA, 1);
		}
		$Indexi++;
		if ($Indexi == 20){ $triggerends = 2;}
	}
	return $singleStringItemB;
}
proc float [] MovePointDirectionAndDistance( float $Direction[], float $Distance, float $PointA[]){
	float $MultDirDist[] = multiplyFloat($Distance ,$Direction);
	float $FloatPointLoc[] = AddFloats($PointA, $MultDirDist);
	return $FloatPointLoc;
}
proc string makeCurvePointDirectionLength(float $Length, float $Direction[], float $posA[]){
	float $MultDir[] = multiplyFloat($Length,  $Direction);
	float $FloatDirectionNormalA[] = AddFloats($posA, $MultDir);
	string $CurveBetween;
	$CurveBetween = curve2points($posA,  $FloatDirectionNormalA);
	return $CurveBetween;
}
proc int [] CreateIntIndex(int $ArraySize){
	int $iNdex = 0;
	int $IntArrayInex[];
	while($iNdex < $ArraySize){
		$IntArrayInex[$iNdex] = $iNdex;
		$iNdex++;
	}
	return $IntArrayInex;
}
proc SetItemColor( string $isSelectedZx[], int $Color ){
	if ( `objExists $isSelectedZx` == 1  ) {
		$ColorN = $Color;
		if ( $Color > 31  ) { $ColorN = $ColorN -31;}
		$isSelectedZx = `listRelatives $isSelectedZx`;
		setAttr ($isSelectedZx[0]+".overrideEnabled ") 1;
		setAttr ($isSelectedZx[0]+".overrideColor ") $Color ;
	}
}
proc SetItemColorString( string $isSelectedZz, int $Color ){
	if ( `objExists $isSelectedZz` == 1  ) {
		$ColorN = $Color;
		if ( $Color > 31  ) { $ColorN = $ColorN -31;}
		string $isSelectedZx[];
		$isSelectedZx = `listRelatives $isSelectedZz`;
		setAttr ($isSelectedZx[0]+".overrideEnabled ") 1;
		if (catch (`setAttr ($isSelectedZx[0]+".overrideColor ") $ColorN `)){
			setAttr ($isSelectedZx[0]+".overrideColor ") 1;}
	}
}
proc ExtrudeMove(){
	performPolyExtrude 0;
	MoveTool;
}
proc MoveObject2(float $FloatPos[]){
	move -ws $FloatPos[0] $FloatPos[1] $FloatPos[2] ;
}
proc selectEdge(){
	changeSelectMode -component;
	setComponentPickMask "Line" true;
}
proc selectVert(){
	changeSelectMode -component;
	setComponentPickMask "Point" true;
}
proc selectFace(){
	changeSelectMode -component;
	setComponentPickMask "Facet" true;
}
proc float [] GetRotationFromDirection(float $P[], float $T[], float $N[]){
	float $p[3];
	float $t[3];
	float $n[3];
	vector $tan;
	vector $norm;
	vector $bi;
	string $locator[];
	string $AllLocatorZi[];
	matrix $m[4][4] = << 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	
	$p = $P;  
	$t = $T;
	$n = $N;
	$p[0] = linearToInternal( $p[0] );
	$p[1] = linearToInternal( $p[1] );
	$p[2] = linearToInternal( $p[2] );
	$tan  = `unit << $t[0], $t[1], $t[2] >>`;
	$norm = `unit << $n[0], $n[1], $n[2] >>`;
	
	// Calculate the binormal.
	$bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
	<< ($norm.x), ($norm.y), ($norm.z) >>`;

	$bi = `unit $bi`;
	// Create a matrix, using normal for the X axis and 
	// tangent for the Z axis.   
	$m = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
	($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
	($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
	$p[0],     $p[1],     $p[2],     1.0 >>;  // Position
	// Create a locator and assign its world-space matrix.
	$locator = `spaceLocator`;
	xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3]) 
	($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3]) 
	($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3]) 
	($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $locator[0];
	float $rotation[] = `getAttr ($locator[0]+".rotate")`;
	return $rotation;
}
///////////////////////////////////////////////// ///////////////////////
proc string[] Strait_ARC_or_FreeForm (string $renamed[], float $ArcN, float $StraitN  ){
	string $nameString = $renamed[0];
	string $ParentArc[];
	float $objectAcurve01 = arclen ($renamed);
	string $objectB[];
	string $objectC[];
	string $DeleteCurveA[];
	string $DeleteCurveB[];
	string $CurveBetween[];
	vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);
	float $posA[] =  $VectorCurveEndZ[0];
	float $posB[] =  $VectorCurveEndZ[1];
	$CurveBetween = MakeCurveBetweenFloats($posA,  $posB);
	ResetTranslation($CurveBetween);
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
	$ParentArc = $CurveBetween; $DeleteCurveA =  $renamed; 
	delete $DeleteCurveA;
	rename $ParentArc $nameString;
	$ParentArc[0] = $nameString;
	return $ParentArc; 
}
///////////////////////////////////////////////// ///////////////////////
proc string[] Strait_ARC_or_FreeForm (string $renamed[], float $ArcN, float $StraitN  ){
	int $free = 0;
	string $nameString = $renamed[0];
	SetCurveRotation($nameString);
	string $ParentArc[];
	//smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString  +".cv[*]");
	float $objectAcurve01 = arclen ($renamed);
	select -r $nameString;
	int $TrueorFalseCircle = `IsCircle`;
	if ($TrueorFalseCircle == 1){
		string $newCircle[] = `MakeCIRCLE($renamed)`;
		$ParentArc = $newCircle;
		makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
	}else{
		float $curveEndsDis01 =  GetDistanceBetweenCurveEnds($renamed);
		float $PercentENDsDiffL = XpercentLess_thenY ($objectAcurve01, $curveEndsDis01);
		int $straitTrigger = 0;
		if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1;  }
		float $objectAcurveD01 = $objectAcurve01 / 1.5;
		int $Cvz = $objectAcurveD01;
		if( $objectAcurve01 < 1.0){ $Cvz = 4; }
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;
		string $objectB[];
		string $objectC[];
		string $DeleteCurveA[];
		string $DeleteCurveB[];
		string $CurveBetween[];
		float $PercentDiffS;
		if ($straitTrigger == 1){
			vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);
			float $posA[] =  $VectorCurveEndZ[0];
			float $posB[] =  $VectorCurveEndZ[1];
			$CurveBetween[0] = curve2points($posA,  $posB);
			ResetTranslation($CurveBetween);
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
			$ParentArc = $CurveBetween; $DeleteCurveA =  $renamed; $DeleteCurveB = $objectB;
		}
		if ( $straitTrigger == 0 ){
			string $objectB[] =  Make_Middle_of_Curve_ParamlocatorZ($renamed);
			ResetTranslation($objectB);
			string $objectC[] = {$renamed[0], $objectB[0]};
			ResetTranslationEach($objectC);
			float $objectAcurveL = arclen ($renamed);
			float $objectBcurveL = arclen ($objectB);
			float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
			if ($PercentDiffL  < $ArcN){
				$ParentArc = $objectB;  $DeleteCurveA = $renamed; 
			}else{ 
				$free = 1;
				$ParentArc = $renamed; $DeleteCurveA = $objectB;  }
		}
		delete $DeleteCurveA;
		rename $ParentArc $nameString;
		$ParentArc[0] = $nameString;
		if ( $free == 1 ){ select -r $ParentArc;  EvalSmoothCurves;
			//modifySelectedCurves smooth 20 0;
			string $nameString = $ParentArc[0];
			float $objectAcurve02 = arclen ($renamed);
			float $objectAcurveD02 = $objectAcurve02 / 1.5;
			int $Cvz2 = $objectAcurveD02;
			if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
			//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001  $renamed;
		}
	}
	makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
	return $ParentArc; 
}
///////////////////////////////////////////////// ///////////////////////
proc string[] Strait_ARC_or_FreeForm (string $renamed[], float $ArcN, float $StraitN  ){
	int $free = 0;
	string $nameString = $renamed[0];
	SetCurveRotation($nameString);
	string $ParentArc[];
	//smoothCurve -ch 1 -rpo 1 -s 6.60 ($nameString  +".cv[*]");
	float $objectAcurve01 = arclen ($renamed);
	select -r $nameString;
	int $TrueorFalseCircle = `IsCircle`;
	if ($TrueorFalseCircle == 1){
		string $newCircle[] = `MakeCIRCLE($renamed)`;
		$ParentArc = $newCircle;
		makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
	}else{
		float $curveEndsDis01 =  GetDistanceBetweenCurveEnds($renamed);
		float $PercentENDsDiffL = XpercentLess_thenY ($objectAcurve01, $curveEndsDis01);
		int $straitTrigger = 0;
		if ( $PercentENDsDiffL < 2 ){ $straitTrigger = 1;  }
		float $objectAcurveD01 = $objectAcurve01 / 1.5;
		int $Cvz = $objectAcurveD01;
		if( $objectAcurve01 < 1.0){ $Cvz = 8; }
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001 $renamed;
		string $objectB[];
		string $objectC[];
		string $DeleteCurveA[];
		string $DeleteCurveB[];
		string $CurveBetween[];
		float $PercentDiffS;
		if ($straitTrigger == 1){
			vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);
			float $posA[] =  $VectorCurveEndZ[0];
			float $posB[] =  $VectorCurveEndZ[1];
			$CurveBetween[0] = curve2points($posA,  $posB);
			ResetTranslation($CurveBetween);
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
			$ParentArc = $CurveBetween; $DeleteCurveA =  $renamed; $DeleteCurveB = $objectB;
		}
		if ( $straitTrigger == 0 ){
			string $objectB[] =  Make_Middle_of_Curve_ParamlocatorZ($renamed);
			ResetTranslation($objectB);
			string $objectC[] = {$renamed[0], $objectB[0]};
			ResetTranslationEach($objectC);
			float $objectAcurveL = arclen ($renamed);
			float $objectBcurveL = arclen ($objectB);
			float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
			if ($PercentDiffL  < $ArcN){
				$ParentArc = $objectB;  $DeleteCurveA = $renamed; 
			}else{ 
				$free = 1;
				$ParentArc = $renamed; $DeleteCurveA = $objectB;  }
		}
		delete $DeleteCurveA;
		rename $ParentArc $nameString;
		$ParentArc[0] = $nameString;
		if ( $free == 1 ){ select -r $ParentArc;  //EvalSmoothCurves;
			modifySelectedCurves smooth 20 0;
			string $nameString = $ParentArc[0];
			float $objectAcurve02 = arclen ($renamed);
			float $objectAcurveD02 = $objectAcurve02 / 1.5;
			int $Cvz2 = $objectAcurveD02;
			if( $objectAcurve01 < 1.0){ $Cvz2 = 4; }
			//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s $Cvz -d 3 -tol 0.001  $renamed;
		}
	}
	makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $ParentArc;
	return $ParentArc; 
}
//SmoothCurvatureB3 12;
proc string[] SmoothCurvatureB3(float $curveM ){
	string $curves[] = `ls -sl`;
	string $myCurve = $curves[0];
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
	//smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	int $numEPrealNum2 = ($numEPrealNum * 8); 
	//Above was Times * 4 
	string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
	string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
	$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
	int $Par = 0;
	int $a;
	int $ii = 0;	
	for($a = 0; $a <= $step;$a++){
		$ii = $ii + 1;
		$t =  $a/$step;
		$Par = ($a/$step);
		setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
		float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
		float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi <=  $curveMin){   
			$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
		}
		if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
			$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		}
		if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
			$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		}
	}
	string $Newcurvez = `eval($curve)`;
	string $Newcurve[] = {$Newcurvez};
	delete $paramlocatorpointOnCurvex $spaceLocatorB; 
	delete $curves;
	rename $Newcurve $myCurve;  
	$Newcurve = {$myCurve};
	return $Newcurve; 
}
proc SetCurveRotation( string $curve )
{
	float $p[3];
	float $t[3];
	float $n[3];
	vector $tan;
	vector $norm;
	vector $bi;
	string $locator[];
	string $AllLocatorZi[];
	matrix $m[4][4] = << 1.0, 0.0, 0.0, 0.0;
	0.0, 1.0, 0.0, 0.0;
	0.0, 0.0, 1.0, 0.0;
	0.0, 0.0, 0.0, 1.0 >>;
	float $u;
	float $span = 0.1;
	float $maxU = `getAttr ( $curve + ".maxValue" )`;
	$u = 0.0;  $u += $span; 

	$p = `pointOnCurve -ch off -pr $u -p $curve`;
	//$t is just a direction....
	$t = `pointOnCurve -ch off -pr $u -nt $curve`;
	$n = `pointOnCurve -ch off -pr $u -nn $curve`;
	// Translational coordinates in a Maya matrix are always represented
	// in Maya's internal units. Convert position to (cm) units.
	$p[0] = linearToInternal( $p[0] );
	$p[1] = linearToInternal( $p[1] );
	$p[2] = linearToInternal( $p[2] );
	// Maya promises normalized tangent and normal,
	// but they really aren't.
	//
	$tan  = `unit << $t[0], $t[1], $t[2] >>`;
	$norm = `unit << $n[0], $n[1], $n[2] >>`;
	
	// Calculate the binormal.
	//
	$bi = `cross << ($tan.x),  ($tan.y),  ($tan.z)  >>
	<< ($norm.x), ($norm.y), ($norm.z) >>`;
	// Normalize our vector.
	//
	$bi = `unit $bi`;
	// Create a matrix, using normal for the X axis and 
	// tangent for the Z axis.
	//
	$m = << ($norm.x), ($norm.y), ($norm.z), 0.0;     // X axis
	($bi.x),   ($bi.y),   ($bi.z),   0.0;     // Y axis
	($tan.x),  ($tan.y),  ($tan.z),  0.0;     // Z axis
	$p[0],     $p[1],     $p[2],     1.0 >>;  // Position
	// Create a locator and assign its world-space matrix.
	//
	$locator = `spaceLocator`;
	
	xform -ws -m ($m[0][0]) ($m[0][1]) ($m[0][2]) ($m[0][3]) 
	($m[1][0]) ($m[1][1]) ($m[1][2]) ($m[1][3]) 
	($m[2][0]) ($m[2][1]) ($m[2][2]) ($m[2][3]) 
	($m[3][0]) ($m[3][1]) ($m[3][2]) ($m[3][3]) $locator[0];
	float $rotation[] = `getAttr ($locator[0]+".rotate")`;
	string $objNameA[0] = {$curve};
	setRotationAxisFloat($objNameA, $rotation);
	//delete $locator;
}
proc appendAll(string $to[], string $from[]){
	appendStringArray($to, $from, size($from));
}
proc CPOC(){
	string $TwoItemz[] = `ls -sl`;
	string $LocatorTrans[] = `spaceLocator`;
	string $LocatorCPOC= ClosestPOC($TwoItemz[0], $LocatorTrans[0]);
	select -r $LocatorTrans $LocatorCPOC;
	pm_connectWithCurve;
	select -r $LocatorTrans;
}
proc CPOS(){
	string $TwoItemz[] = `ls -sl`;
	string $LocatorTrans[] = `spaceLocator`;
	string $LocatorCPOC= ClosestPOS($TwoItemz[0], $LocatorTrans[0]);
	select -r $LocatorTrans $LocatorCPOC;
	//pm_connectWithCurve;
	select -r $LocatorTrans;
}
proc Move(float $Point[], string $name){
	move  -ws $Point[0] $Point[1] $Point[2] $name;
}
proc string curve2points(float $TanEnd1[], float $intersectposD1[]){
	float $CircleDistanceAB = `getDistance $TanEnd1 $intersectposD1`;
	int $RDistAB = RoundFloat($CircleDistanceAB, 0.0);
	float $MiddlePoint1[] = MidPoint($TanEnd1, $intersectposD1);
	float $CircleDistanceAM1 = `getDistance $TanEnd1 $MiddlePoint1`;
	float $RDistM1 = $CircleDistanceAM1;
	//int $RDistM1 =  RoundFloat($CircleDistanceAM1, 0.0);
	float $MiddlePointA1[] = MidPoint($TanEnd1, $MiddlePoint1);
	float $MiddlePointB1[] = MidPoint($MiddlePoint1, $intersectposD1);
	string $CurveMade = `curve -d 3 
	-p $TanEnd1[0] $TanEnd1[1] $TanEnd1[2] 
	-p $MiddlePointA1[0] $MiddlePointA1[1] $MiddlePointA1[2] 
	-p $MiddlePoint1[0] $MiddlePoint1[1] $MiddlePoint1[2] 
	-p $MiddlePointB1[0] $MiddlePointB1[1] $MiddlePointB1[2]  
	-p $intersectposD1[0] $intersectposD1[1] $intersectposD1[2]  -k 0 -k 0 -k 0 -k $RDistM1 -k $RDistAB -k $RDistAB -k $RDistAB` ;
	return $CurveMade;
}
proc string curve2points(float $TanEnd1[], float $intersectposD1[]){
	vector $FixVec[];
	$FixVec[0]  = << $TanEnd1[0], $TanEnd1[1], $TanEnd1[2]>>;
	$FixVec[1]  = <<$intersectposD1[0], $intersectposD1[1], $intersectposD1[2]>>;
	int $sIZes = 2;
	int $NUmers[] = CreateIntIndex($sIZes);
	string $K = "";
	for ($eachN in $NUmers){
		$K += "\-k"+" "+$eachN+" ";
	}
	print $K;
	string $curve = "curve -d 1";
	for ($eachVeCx in $FixVec){
		float $valuesBi[] = $eachVeCx;
		$curve += " -p "+$valuesBi[0]+"  "+$valuesBi[1]+" "+$valuesBi[2];
	}
	$curve += " "+ $K;
	string $Newcurvez = `eval($curve)`;
	return $Newcurvez;
}
proc string ClosestPOS(string $mySurf, string $toObject){
	$myCPOC = `createNode closestPointOnMesh`;
	makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $mySurf;
	connectAttr ($mySurf+".worldMesh") ($myCPOC+".inMesh");
	string $Locator[] = `spaceLocator`;      
	connectAttr ($myCPOC+".position") ($Locator[0]+".translate");  
	connectAttr ($toObject+".translate") ($myCPOC+".inPosition");
	select -r $toObject;
	return $myCPOC;
}
proc string ClosestPOC(string $myCurve, string $toObject){
	$myCPOC = `createNode closestPointOnCurve`;
	connectAttr ($myCurve+".worldSpace") ($myCPOC+".inCurve");
	string $Locator[] = `spaceLocator`;      
	connectAttr ($myCPOC+".position") ($Locator[0]+".translate");  
	connectAttr ($toObject+".translate") ($myCPOC+".inPosition");
	return $Locator[0];
}
proc float[] DirectionF(float $EACHCVposAZ[], float $EACHCVposBZ[]){
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	$EACHCVposHigher = $EACHCVposBZ;
	$EACHCVposLower = $EACHCVposAZ;
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec2[];
	$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
	vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
	float $UnitDirection[] = $vectorUnit;
	///////////////////////////////////////////////// ////
	return $UnitDirection;
}
proc float[] DirectionFString(string $twoItem[]){
	string $twoItem[];
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];	
	int $numIntZB = 0;
	for ($eachZA in $twoItem) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){
			$EACHCVposAZ = $eachCVpos;
		}
		if ( $numIntZB == 2 ){
			$EACHCVposBZ = $eachCVpos;
		}
	}
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	$EACHCVposHigher = $EACHCVposBZ;
	$EACHCVposLower = $EACHCVposAZ;
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec2[];
	$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
	vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
	float $UnitDirection[] = $vectorUnit;
	///////////////////////////////////////////////// ////
	return $UnitDirection;
}
proc float[] DirectionTwoPoints(float $EACHCVposAZ[], float $EACHCVposBZ[]){
	string $CurveItem[];
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	$EACHCVposHigher = $EACHCVposBZ;
	$EACHCVposLower = $EACHCVposAZ;
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec2[];
	$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
	vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
	float $UnitDirection[] = $vectorUnit;
	///////////////////////////////////////////////// ////
	return $UnitDirection;
}
proc float[] DirectionFromFirst2SecondPoint(){
	string $CurveItem[];
	$twoItem = `ls -sl -fl`;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];	
	int $numIntZB = 0;
	for ($eachZA in $twoItem) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){
			$EACHCVposAZ = $eachCVpos;
		}
		if ( $numIntZB == 2 ){
			$EACHCVposBZ = $eachCVpos;
		}
	}
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	$EACHCVposHigher = $EACHCVposBZ;
	$EACHCVposLower = $EACHCVposAZ;
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposHigher, $EACHCVposLower);
	float $vector_SubUnitMagVec2[];
	$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
	vector $vectorUnit = `unit <<$vector_SubUnitMagVec1[0], $vector_SubUnitMagVec1[1], $vector_SubUnitMagVec1[2]>>`;
	float $UnitDirection[] = $vectorUnit;
	///////////////////////////////////////////////// ////
	return $UnitDirection;
}
proc float getCurveLength( string $curve){
	string $arcLenNode = `createNode arcLengthDimension`;
	connectAttr -f ( $curve + ".worldSpace[0]" ) ( $arcLenNode + ".nurbsGeometry" );
	setAttr ( $arcLenNode + ".uParamValue" ) `getAttr ( $curve + ".maxValue" )`;
	float $curveLength = `getAttr ( $arcLenNode + ".arcLength" )`;
	string $parent[] = `listRelatives -p $arcLenNode`;
	//delete $parent;
	return $curveLength;
}
proc vector[] getpositions(string $objectlist[]){
	vector $pointsV[];
	string $objectlistF[] = `ls -fl $objectlist`;
	int $iX = 0;
	for ($each in $objectlistF){
		if (catch($pointsV[$iX] = `pointPosition -w  $each`)){
			$pointsV[$iX] = `xform -q -ws - rp $each`;
		} 
		$iX++;
	}
	return $pointsV; 
}
proc float[] Matrix4ToFloat(matrix $m[][]){
	float $MatrixPoints[];
	$MatrixPoints = {($m[0][0]), ($m[0][1]), ($m[0][2]), ($m[0][3]), 
		($m[1][0]), ($m[1][1]), ($m[1][2]), ($m[1][3]), 
		($m[2][0]), ($m[2][1]), ($m[2][2]), ($m[2][3]), 
		($m[3][0]), ($m[3][1]), ($m[3][2]), ($m[3][3])};
	return $MatrixPoints;
}
proc CurveExtrude(){
	xform -cp;
	string $selectedCurves[] = `ls -sl`;
	string $allCurve[];
	for ($each in $selectedCurves){
		string $newcurves[] = `duplicate -rr $each `;
		scaleConstraint -offset 1 1 1 -weight 1 $each $newcurves[0];
		appendStringArray ($allCurve, $newcurves, 1);
		loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true $each $newcurves[0];
	}
	select -r $allCurve;
	xform -cp;
}
//CurveExtrude;
proc float linearToInternal( float $linear )
{
	float $factor = 1.0;
	string $pref = `currentUnit -q -l`;
	if ( "mm" == $pref ) $factor = 0.1;
	if ( "m" == $pref ) $factor = 100.0;
	if ( "inch" == $pref ) $factor = 2.54;
	if ( "ft" == $pref ) $factor = 30.48;
	if ( "yard" == $pref ) $factor = 91.44;
	return ( $linear * $factor );
}
proc float linear_to_internal( float $linear )
{
	float $factor = 1.0;
	string $pref = `currentUnit -q -l`;
	if ( "mm" == $pref ) $factor = 0.1;
	if ( "m" == $pref ) $factor = 100.0;
	if ( "inch" == $pref ) $factor = 2.54;
	if ( "ft" == $pref ) $factor = 30.48;
	if ( "yard" == $pref ) $factor = 91.44;
	return ( $linear * $factor );
}
proc float linear_to_ui( float $linear )
{
	float $factor = 1.0;
	string $pref = `currentUnit -q -l`;
	if ( "mm" == $pref ) $factor = 10.0;
	if ( "m" == $pref ) $factor = 0.01;
	if ( "inch" == $pref ) $factor = 0.3937007874;
	if ( "ft" == $pref ) $factor = 0.03280839895;
	if ( "yard" == $pref ) $factor = 0.01093613298;
	return ( $linear * $factor );
}
proc float angle_to_internal( float $angle )
{
	string $pref = `currentUnit -q -a`;
	if ( "deg" == $pref )
	{
		$angle = $angle * 0.0174532925;
	}
	return $angle;
}
proc appendAll(string $to[], string $from[]){
	appendStringArray($to, $from, size($from));
}
proc float[] facenormal(string $selObj[]){
	string $stringFaceNormalZ[] = `polyInfo -faceNormals $selObj[0]`;
	string $buffer[];
	int $numTokens;
	$numTokens = `tokenize $stringFaceNormalZ[0] ":" $buffer`;
	string $stringFaceNormalZ2[] = {$buffer[1]};
	string $stringFaceNor = $buffer[1];
	string $buffer2[];
	int $numTokens2;
	$numTokens2 = `tokenize $stringFaceNor " " $buffer2`;
	float $TheNormal[] = stringtofloat($buffer2);
	return $TheNormal;
}
proc float[] stringtofloat(string $bufferA[]){
	string $buffer1 = $bufferA[0];
	string $buffer2 = $bufferA[1];
	string $buffer3 = $bufferA[2];
	float $TheNormalX = $buffer1;
	float $TheNormalY = $buffer2;
	float $TheNormalZ = $buffer3;
	float $TheNormalAll[] = { $TheNormalX, $TheNormalY, $TheNormalZ };
	return $TheNormalAll;
}
proc int CurveEPnumber(string $myCurve){
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	return $numEPrealNum;
}
proc string[] StartofCurveScriptRetopo2(string  $captureCurveName[], string $myCPOM){
	Removefromsurface;
	string $objectcurv[];
	$objectcurv = `ls -sl`;
	string $myCurve = $objectcurv[0];
	//int $curveTypeSwitchC = `IsCircle`;
	//if ( $curveTypeSwitchC == 1 ){
	//string $newCircle[] = `CIRCLESCRIPTZ ($objectcurv)`;
	///rotate -r -os 90 0 0 ;
	///}
	float $CamPos1[];
	float $ZeroPos1[] = {0.0 ,0.0, 0.0};
	$CamPos1 = `xform -q -ws -t ZCURVEModelingCAM`;
	setAttr ($myCPOM+".inPosition") $CamPos1[0] $CamPos1[1] $CamPos1[2];
	float $valuesB[] = `getAttr  ($myCPOM+".position")`;
	float $DistanceLocOnMesh = distance2Pts($CamPos1, $valuesB );
	//Mag
	float $DistanceZeroToCam = distance2Pts($CamPos1, $ZeroPos1 );
	float $DistanceZeroToPoint = distance2Pts($valuesB, $ZeroPos1 );
	float $CurveDistanceAv = (($DistanceLocOnMesh+$DistanceZeroToCam+$DistanceZeroToPoint)/3)*2;
	float $arcL1 = `arclen $myCurve`;
	//float $arcL2 = ( $arcL1 / 1.5 );
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	int $numEPRebuildNum = ($numEPrealNum * 2 );  
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s $numEPRebuildNum -d 3 -tol  0.001 $myCurve;
	//CopySelected;  DUPLICATE IT 
	string $DupicateZ[] = `duplicate -rr $myCurve`;
	select -r $myCurve;
	SmoothCurvatureB3(0.1);
	float $arcL2 = `arclen $myCurve`;
	select -r $DupicateZ;
	float $percentDIffZ = PercentDiff_Curve_to_Arc($arcL2,$arcL1);
	int $curveEPsZ = CurveEPnumber($myCurve);
	if (($percentDIffZ < 98.0)||($curveEPsZ < 5)) {  delete $myCurve;
		rename $DupicateZ[0] $myCurve;
		$DupicateZ = `duplicate -rr $myCurve`;
		select -r $myCurve;
		SmoothCurvatureB3($arcL1);
		float $arcL3 = `arclen $myCurve`;
		int $curveEPsZ2 = CurveEPnumber($myCurve);
		float $percentDIffZ2 = PercentDiff_Curve_to_Arc($arcL3,$arcL1);
		//ERROR here
		if ($percentDIffZ2 > 98.0){ delete $DupicateZ[0];
			select -r $myCurve;} else {
			delete $myCurve;
			rename $DupicateZ[0] $myCurve;
			select -r $myCurve;
		}
	}else{  delete $DupicateZ[0];
		select -r $myCurve;}
	string $digitalSkeleton[];
	$numInts = size($digitalSkeleton);
	if ( $numInts > 0 ){
		clear $digitalSkeleton;
	}
	string $CurveItemA = $objectcurv[0];
	string $CurveSelection[] = `ls -fl  ($CurveItemA+".ep[0:*]")`; 
	string $CurveEPzCount = size ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	//float $arcL4 = `arclen $myCurve`;
	///////////////GATHER ALL BUILDING  STRUCTURE/////////##
	appendStringArray($digitalSkeleton, $objectcurv,  1);
	///////////////////////////////////////////////// ////##
	float $EACHCVposA[];
	float $EACHCVposB[];	
	string $AllIntersectCurveZ[];
	$numInts = size($AllIntersectCurveZ);
	if ( $numInts > 0 ){
		clear $AllIntersectCurveZ;
	}
	string $MakeIntersectCurvez[];
	float $eachCVpos[];
	string $each;
	for ($each in $CurveSelection) {     	
		$eachCVpos = `pointPosition -w  $each`;
		$MakeIntersectCurvez[0] = makeCurvePointDirectionLength($CurveDistanceAv, {1.0, 0.0, 0.0}, $ZeroPos1);
		appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp  0 -kep 1 -kt 0 -s 22 -d 3 -tol 0.001 ;
		move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos[2] $MakeIntersectCurvez[0];
		aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM    $MakeIntersectCurvez[0];
	}
	$captureCurveName = $objectcurv;
	select -r $captureCurveName;
	delete $objectcurv;
	return $AllIntersectCurveZ;
}
/*
proc string[] SmoothCurvatureB3(float $curveM ){
string $curves[] = `ls -sl`;
string $myCurve = $curves[0];
//rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
//smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPrealNum2 = ($numEPrealNum * 4 ); 
//Above was Times * 4 
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
int $Par = 0;
int $a;
int $ii = 0;	
for($a = 0; $a <= $step;$a++){
$ii = $ii + 1;
	$t =  $a/$step;
	$Par = ($a/$step);
	setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
	float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
	float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi <=  $curveMin){ 
	$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
	}
if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}
if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
}
}
string $Newcurvez = `eval($curve)`;
string $Newcurve[] = {$Newcurvez};
delete $paramlocatorpointOnCurvex $spaceLocatorB; 
delete $curves;
rename $Newcurve $myCurve;  
$Newcurve = {$myCurve};
return $Newcurve; 
}
*/
proc float PercentDiff_Curve_to_Arc(float  $arclenghtzARC, float $arclenghtzDRAWN){
	float $FLOAT1;
	float $FLOAT2;
	if($arclenghtzARC < $arclenghtzDRAWN){
		$FLOAT1 = $arclenghtzARC; $FLOAT2 = $arclenghtzDRAWN;}
	if($arclenghtzARC > $arclenghtzDRAWN){
		$FLOAT1 = $arclenghtzDRAWN; $FLOAT2 = $arclenghtzARC; }
	float $PercentA;
	if($arclenghtzARC == $arclenghtzDRAWN){
		$PercentA = 0;}else{
		$PercentA = ((float($FLOAT1) / $FLOAT2) * (100) ); }
	return $PercentA;
}
/*
//print ("cycle "+$XiX);
//print ("Gate2 "+$Gate2);
//print ("a "+$a);
print $a;
//$a3 = $A2;
//print $a;
//PointsGetDistanceFLOAT($valuesC, $valuesA);
// Result: 0.127273 // 
//Editing Here <=  float $OneUnitFirstStep =   112/10.181818;    float $UnitLOne = 10.181818 /  2; //0.127273
//float $UnitLOneTest2 = ($UnitLOne / 40);
//68.398615 58.339062
// float $UnitLOneTest = 0.127273 * 40;
//############################  
// float $UnitLOneTest2 = ($UnitLOne / 40);
//############################
//$UnitDistance  = $UnitDistanceA;
// 10.181818 // 
//$UnitDistanceHalf = $UnitDistance/2;
// 5.090909 // 
//  float $OneUnitFirstStepB =  $UnitLOne/11;   float $OneUnitFirstStepC = (($OneUnitFirstStepB)  /($OneUnitFirstStep))*(110)/2; 
print ($UnitDistance + "\n");
print ($DistanceAB   + "\n");
print ($DivideTotalWithUnit + "\n");
print ($PercentDistanceZ + "\n");
print ($RDivideTotalWithUnit + "\n");
print ($a + "\n");
print ($A2 + "\n");
//if ( $DistanceAB <= $DistanceFourth ){  polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 - ch 1; 
//print ("0000  At One Fourth Distance  0000" +  "\n");  }
print ($switchN  + "\n");
print ($triggerA  + "\n");
print ($DistanceAB   + "\n");
print ($DistanceCD   + "\n");
print ($DivideTotalWithUnit   + "\n"); 
*/
if ( `objExists NurbsPlanes` == 0  ) {
	createDisplayLayer -name "NurbsPlanes" - number 1 -empty;
	setAttr NurbsPlanes.color 30;
}
if ( `objExists IntersectFormLayer` == 0  ) {
	createDisplayLayer -name "IntersectFormLayer" - number 1 -empty;
	setAttr IntersectFormLayer.color 30;
}
if ( `objExists IntersectFormLayerOutofRange` ==  0  ) {
	createDisplayLayer -name  "IntersectFormLayerOutofRange" -number 1 -empty;
	setAttr IntersectFormLayerOutofRange.color 2;
}
if ( `objExists IntersectFormLayerINRange` == 0   ) {
	createDisplayLayer -name  "IntersectFormLayerINRange" -number 1 -empty;
	setAttr IntersectFormLayerINRange.color 3;
}
if ( `objExists layerYZYXPlains` == 0  ) {
	createDisplayLayer -name "layerYZYXPlains" - number 1 -empty;
}
if ( `objExists layerAllCurves1` == 0  ) {
	createDisplayLayer -name "layerAllCurves1" - number 1 -empty;
}
if ( `objExists layerEdgeCurveZ1` == 0  ) {
	createDisplayLayer -name "layerEdgeCurveZ1" - number 1 -empty;
}
if ( `objExists layerCurvesOutofRange1` == 0  ) {
	createDisplayLayer -name "layerCurvesOutofRange1"  -number 1 -empty;
	setAttr layerCurvesOutofRange1.color 12;
}
if ( `objExists layerCurvesINRange1` == 0  ) {
	createDisplayLayer -name "layerCurvesINRange1" - number 1 -empty;
	setAttr layerCurvesINRange1.color 6;
}
if ( `objExists TheLastCurvesSet` == 0  ) {
	string $newSet3 = `sets -name TheLastCurvesSet`;
}
if ( `objExists ZEdgeCurvesSet` == 0  ) {
	string $newSet1 = `sets -name ZEdgeCurvesSet`;
}
if ( `objExists ZPlaneCurvesSet` == 0  ) {
	string $newSet2 = `sets -name ZPlaneCurvesSet`;
}
//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//
global int $xii;
global int $xii = 0;
int $script_jobToolChangedNum1 = 505;
int $script_jobToolChangedNum2 = 606;
int $scriptt_jobAllCurvesToolsNumA;
int $scriptt_jobAllCurvesToolsNumB;
//WHat it does : scriptjob that runs when camera is translated or rotated //
int $jobNumtranslateCAM;
int $jobNumrotateCAM;
//WHat it does :  keeps track on number of curve strokes drawn //
int $addNumbersA;
$addNumbersA = 0;
global int $script_jobNumIdle_MoveZCURVEM;
global string $dialogBoxWin;
//WHat it does : string collects all curves created with script //
global string $EdgeCurveZ2[];
global int $plainNum;
clear $EdgeCurveZ2;
//string $EdgeCurveZ2 = `ls -sl`;
//WHat it does : draw a strait line in some otho direction... draw a wiggly line.. draw a circle and see what happens
global int $plainNum = 0;
//////////////////
global string $CamConeLocator[];
string $newCAMSet1;
/////////////////
//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//
//ALL GLOBAL INT#######################//
proc int AddorSubtract(int $Number, int $AorS){
	if ($AorS == 1){ $Number++; return $Number; } 
	if ($AorS == 0){ $Number--; return $Number; }
	if ($AorS == 2){ $Number = 0; return $Number; }  
}
proc int CurveEPnumber(string $myCurve){
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	return $numEPrealNum;
}
/*
proc string[] StartofCurveScriptRetopo2(string  $captureCurveName[]){
Removefromsurface;
string $objectcurv[];
$objectcurv = `ls -sl`;
string $myCurve = $objectcurv[0];
float $arcL1 = `arclen $myCurve`;
//float $arcL2 = ( $arcL1 / 1.5 );
string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
int $numEPRebuildNum = ($numEPrealNum * 2 );  
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s $numEPRebuildNum -d 3 -tol  0.001 $myCurve;
//CopySelected;  DUPLICATE IT 
string $DupicateZ[] = `duplicate -rr $myCurve`;
select -r $myCurve;
SmoothCurvatureB3(0.1);
float $arcL2 = `arclen $myCurve`;
print $arcL1;
print $arcL2;
print $myCurve;
print $DupicateZ;
select -r $DupicateZ;
float $percentDIffZ = PercentDiff_Curve_to_Arc($arcL2,$arcL1);
int $curveEPsZ = CurveEPnumber($myCurve);
if (($percentDIffZ < 98.0)||($curveEPsZ < 5)) {  delete $myCurve;
rename $DupicateZ[0] $myCurve;
$DupicateZ = `duplicate -rr $myCurve`;
select -r $myCurve;
SmoothCurvatureB3($arcL1);
float $arcL3 = `arclen $myCurve`;
int $curveEPsZ2 = CurveEPnumber($myCurve);
float $percentDIffZ2 = PercentDiff_Curve_to_Arc($arcL3,$arcL1);
//ERROR here
if ($percentDIffZ2 > 98.0){ delete $DupicateZ[0];
select -r $myCurve;} else {
delete $myCurve;
rename $DupicateZ[0] $myCurve;
select -r $myCurve;
}
}else{  delete $DupicateZ[0];
select -r $myCurve;}
string $digitalSkeleton[];
$numInts = size($digitalSkeleton);
if ( $numInts > 0 ){
clear $digitalSkeleton;
}
string $CurveItemA = $objectcurv[0];
string $CurveSelection[] = `ls -fl  ($CurveItemA+".ep[0:*]")`; 
string $CurveEPzCount = size ($CurveSelection);
int $numEPs = size ($CurveSelection);
int $numEPrealNum = ( $numEPs -1 );
//float $arcL4 = `arclen $myCurve`;
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
appendStringArray($digitalSkeleton, $objectcurv,  1);
///////////////////////////////////////////////// ////##
float $EACHCVposA[];
float $EACHCVposB[];	
string $AllIntersectCurveZ[];
$numInts = size($AllIntersectCurveZ);
if ( $numInts > 0 ){
clear $AllIntersectCurveZ;
}
string $IntersectCurves[];
string $MakeExtrudeSurface[];
string $MakeBirailSurface[];
string $MakeXBetween[];
string $MakeIntersectCurvez[];
string $MakespaceLocator[];
float $eachCVpos[];
	string $each;
for ($each in $CurveSelection) {     	
	$eachCVpos = `pointPosition -w  $each`;
$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
$numInts = size($AllIntersectCurveZ);
extendCurvePresetArgList( "2", {"0",  "0","0","0","100","0","0","0","0","1","1","1"} );
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp  0 -kep 1 -kt 0 -s 22 -d 3 -tol 0.001 ;
move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
//PAUSE;
aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM    $MakeIntersectCurvez[0];
//PAUSE;
}
$captureCurveName = $objectcurv;
select -r $captureCurveName;
delete $objectcurv;
return $AllIntersectCurveZ;
}
proc string[] StartofCurveScriptRetopo3 (string $PolygonShapeZ[], string  $ProjectionCurves[], string $CurveName[]){
string $PolygonShape[];
$PolygonShape[0] = $PolygonShapeZ[0];
string $AllIntersectCurveZA[] =  $ProjectionCurves;
//$PolygonShape[0] = $PolygonShapeZA[0]; 
//string $AllIntersectCurveZA[] =  $retopoProjectionCurves;
//print $retopoProjectionCurves;
makeIdentity -apply true -t 0 -r 0 -s 1 -n 0  $PolygonShape;
int $KillScript = 1;
string $curve = "curve -d 3";
string $Allcurves[];
$Allcurves = $AllIntersectCurveZA;
int $curvesNumber = size($Allcurves) -1;
int $iY = -1; 
float $ZeroDistanceAB = 0.0;
int $switchN = 0;
int $Xi = 1;
string $curvePoints = "";
float $step = 1;  
string $crShape[];
string $myCurve;
while ($curvesNumber > $iY ){
if ($KillScript == 0 ){$iY = 1000;}
$iY++;
int $a = 1;
int $ADDSUB = 1;
int $ADDSUB2 = 2;
$b = 0;
///////////////////
$switchN = 0;
//////////////////
$Xi = 1;
$step = 1;  
float $arclenghtOne = `arclen $Allcurves[0]`;
$myCurve =  $Allcurves[$iY];
	$cube = $PolygonShape[0];
	$myCPOM = `createNode closestPointOnMesh`;
	connectAttr ($cube+".worldMesh")  ($myCPOM+".inMesh");
	$LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
	$LocA = $LocatorResultA[0];
	connectAttr ($myCPOM+".position")  ($LocA+".translate");
	$LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
	$LocB = $LocatorResultB[0];
	connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");
string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position") ($LocB  + ".translate")`;
$crShape = `listRelatives -s $myCurve`;
int $XiX = 0;
float $DistanceFourth;
int $triggerA = 0;
float $UnitDistance;
float $DivideTotalWithUnit;
int $RDivideTotalWithUnit;
int $A2;
float $UnitDistanceA;
int $Gate2 = 0;
int $Gate1 = 0;
float $UnitDistanceFourth;
float $UnitDistanceHalf;
int $a3 = 1;
int $Demo = 0;
int $PassedTargetNum = 0;
while($Xi > 0 ){
$XiX++;
if ($XiX == 1000){$Xi = 0; $KillScript = 0;}
float $valuesC[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
float $valuesD[] = `getAttr  ($myCPOM+".position")`;
float $DistanceCD  = PointsGetDistanceFLOAT ($valuesC, $valuesD);
////IF triggered ----- "$step = 40; $a = $a * 40" 
// then --- $a = AddorSubtract($a ,$ADDSUB) which  adds 1 making t = 80/40 t = 81/40
$a = AddorSubtract($a ,$ADDSUB);
	$t =  $a/$step;
setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t;
$para = `getAttr ($paramlocatorpointOnCurvex +  ".parameter")`;
float $valuesA[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
float $valuesB[] = `getAttr  ($myCPOM+".position")`;
float $DistanceAB  = PointsGetDistanceFLOAT ($valuesA, $valuesB);
if ($XiX < 32){ $Gate1 = $XiX;}
if ($XiX == 1){ $Gate2 = 1;
$UnitDistanceFourth = $DistanceAB/4;
$UnitDistanceA  = PointsGetDistanceFLOAT ($valuesC, $valuesA);
}
/////////////////////////////////////
if ($XiX == $Gate2){ $Gate2 = $Gate1;
$UnitDistance  = $UnitDistanceA;
$UnitDistanceHalf = $UnitDistance/2;
$DivideTotalWithUnit = ($DistanceAB/2) /  $UnitDistanceHalf;
$A2 = ($DivideTotalWithUnit +1);
if ($A2 >= 1){
$a = $a + $A2;
}else{ int $IFequivalent = equivalentTol ($DistanceAB, $ZeroDistanceAB, 0.1);
	if ($IFequivalent == 1){  
		$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
select -r $LocB $LocA;
delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
$Xi = 0; 
	}}
}
///////////////////////////////////
//if ( $DistanceAB > $DistanceCD ) { print ("0000  Passed Target Distance  0000" +  "\n"); $PassedTargetNum++;}
//0000  Passed Target Distance  0000
if ($switchN == 0){
if ($triggerA == 0){
if (( $DistanceAB <= $UnitDistanceHalf ) && (  $DistanceAB < $DistanceCD )) {$ADDSUB = 1; $step  = 40; $a = $a * 40; 
$triggerA = 1; } 
}
if (!($XiX == $Gate2)){
if($PassedTargetNum<1){
if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 0;  $step = 20; $a = $a * 20; $switchN = 1;  
print ("0000  Passed Target Distance  0000" +  "\n"); }
}
}
}
if ($switchN == 2){ 
if ( $DistanceAB > 4){ $ADDSUB = 1;  $step = 1; $a = $a / 20; $switchN = 0; $PassedTargetNum++; print ("0000  Passed False Target  0000" +  "\n");}else{
if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 1;  $step = 40; $a = $a * 40;  $switchN = 3; 
$ADDSUB2 = 1; }
}
}
if ($switchN == 1){ $switchN = 2; }
int $IFequivalent = equivalentTol($DistanceAB,  $ZeroDistanceAB, 0.1);
	if ($IFequivalent == 1){  
		$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
select -r $LocB $LocA;
delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
$Xi = 0; 
	}
$b = AddorSubtract($b ,$ADDSUB2);
if ( $b > 10 ){ delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;
$Xi = 0; }
//////////////////////////////////
}
}
string $Newcurvez = `eval($curve)`;
rename $Newcurvez $CurveName[0];
string $Newcurve[] = $CurveName;
string $NewcurveA[] = `ls -sl`;
delete $ProjectionCurves; 
return $Newcurve; 
}
*/
////////////////////////////////
proc float[] AverageVectorPoint(vector $worldPosZ[]) {
	int $vectorSize = `size($worldPosZ)`;
	int $vecCount = `size($worldPosZ)` ;
	float $Added_floats[] = { 0.0, 0.0, 0.0};
	float $FloatFromVec[];
	float $VposA;
	float $VposB;
	float $VposC;
	int $Vii = 0;
	while ($Vii < $vecCount){
		float $FloatFromVecA[] = $worldPosZ[$Vii];
		$VposA = $FloatFromVecA[0];
		$VposB =  $FloatFromVecA[1];
		$VposC =  $FloatFromVecA[2];
		$Added_floats = {($FloatFromVecA[0] +  $Added_floats[0]), ($FloatFromVecA[1] +  $Added_floats[1]), ($FloatFromVecA[2] +  $Added_floats[2])} ;
		$Vii++;
	}	
	float $a = ($Added_floats[0]) /  $vectorSize;
	float $b = ($Added_floats[1]) /  $vectorSize;
	float $c = ($Added_floats[2]) /  $vectorSize;
	float $PointsAverage[] = {$a , $b , $c};
	return $PointsAverage;
}
proc float[] AverageVectorPointABS(vector $worldPosZ[]) {
	int $vectorSize = `size($worldPosZ)`;
	int $vecCount = `size($worldPosZ)` ;
	float $Added_floats[] = { 0.0, 0.0, 0.0};
	float $FloatFromVec[];
	float $VposA;
	float $VposB;
	float $VposC;
	int $Vii = 0;
	while ($Vii < $vecCount){
		float $FloatFromVecA[] = $worldPosZ[$Vii];
		$VposA = `abs $FloatFromVecA[0]`;
		$VposB = `abs $FloatFromVecA[1]`;
		$VposC = `abs $FloatFromVecA[2]`;
		$Added_floats = {($FloatFromVecA[0] +  $Added_floats[0]), ($FloatFromVecA[1] +  $Added_floats[1]), ($FloatFromVecA[2] +  $Added_floats[2])} ;
		$Vii++;
	}	
	float $a = ($Added_floats[0]) /  $vectorSize;
	float $b = ($Added_floats[1]) /  $vectorSize;
	float $c = ($Added_floats[2]) /  $vectorSize;
	float $PointsAverage[] = {$a , $b , $c};
	return $PointsAverage;
}
proc int CurveEPnumber(string $myCurve){
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	return $numEPrealNum;
}
global proc string[] IntersectItems(string  $initialArray[], string $IntersectArrayItems[] ){
	string $myIntersector = `stringArrayIntersector`;
	stringArrayIntersector -edit -intersect  $initialArray $myIntersector;
	stringArrayIntersector -edit -intersect  $IntersectArrayItems $myIntersector;
	string $results[] = `stringArrayIntersector - query $myIntersector`;
	stringArrayIntersector -edit -reset  $myIntersector;
	return $results;
}
proc float[] GetCenterPointofFace(float  $CurveXYZ[]){
	int $Cnsize= `size $CurveXYZ`;
	int $Cnsize_p= ($Cnsize/3) -1;
	int $ix = -1;
	int $Xii = -3; int $Yii = -2; int $Zii = -1;
	vector $points[];
	clear $points;
	while ($ix < $Cnsize_p){
		$ix++;
		$Xii = $Xii + 3;
		$Yii = $Yii + 3;
		$Zii = $Zii + 3;
		$points[$ix] = <<$CurveXYZ[$Xii], $CurveXYZ [$Yii], $CurveXYZ[$Zii]>>;
	}
	float $FacePoint[] = AverageVectorPoint($points);
	return $FacePoint;
}
proc ConnectMesh(string $selectOUT[], string  $selectIN[]){
	$outmmesh = ($selectOUT[0] + ".outMesh"); 
	$inmmesh = ($selectIN[0] + ".inMesh");
	$connect = `connectAttr -f $outmmesh $inmmesh`;
}
proc ConnectMeshScale(string $selectOUT[], string  $selectIN[]){
	$outmmesh = ($selectOUT[0] + ".scale"); 
	$inmmesh = ($selectIN[0] + ".scale");
	$connect = `connectAttr -f $outmmesh $inmmesh`;
}
proc int FaceEdgeNumber(string $face){
	string $PolyEg[] = `polyListComponentConversion  -fromFace -toEdge $face`; 
	$PolyEg = `ls -fl $PolyEg`;
	int $EdgeNumber = `size($PolyEg)`;
	return $EdgeNumber;
}
proc string CreateCurve(float $CurveLength, int  $CurveNSpans, string $Curvename)
{
	string $CurvenextSel[] = `ls -sl`;
	float $CurveLengthC = $CurveLength;
	int $CurveNSpansC = $CurveNSpans;
	global string $CurvenameCobj;
	string $CurvenameCobj = $Curvename;
	$CurveNSpansC = $CurveNSpansC - 1;
	float $CurveCurvPart = $CurveLengthC/ $CurveNSpansC;
	string $CurvecurveP = "";
	float $Curvei = 0;
	while ($Curvei <= $CurveLengthC) 
	{
		$CurvecurveP = ($CurvecurveP+"-p 0 "+$Curvei+" 0  ");
		$Curvei = $Curvei + $CurveCurvPart;
	}
	$CurvecurveP = ("curve -d 3 "+$CurvecurveP+";");
	eval $CurvecurveP;
	string $renamed = `rename $CurvenameCobj`;
	//select $CurvenextSel;
	return $renamed ;
}
// string $selection[]=`ls -sl`; string $sel=$selection[0]; if(size($sel)>0 && `attributeExists "Speed" $sel`) getAttr $sel.Speed;
global proc string[] stringArrayMatchToArray (string $item, string $list[]){
	string $FoundMatchedItem[];
	int $resultZ = false;	
	string $MatchedItem[];	
	for ($each in $list) {
		string $OneiteminArrayList = $each;
		string $matchedItem[];
		$matchedItem = {`match $item $OneiteminArrayList `};
		int $sizeMatchedItems = `size($matchedItem)`;
		int $matchedBlankN = isValidString($matchedItem[0], "([a-zA-Z]+)([a-zA-Z0-9_])*");
		if (($sizeMatchedItems >  0) && ($matchedBlankN > 0)){
			$resultZ = true;
			if ($resultZ == true ){ $FoundMatchedItem[0] = ($OneiteminArrayList); }
			break;	}
	}		
	return  $FoundMatchedItem;
}
proc PrintAllNodeTypes(){
	string $arrayListType[];
	$arrayListType = `ls -nodeTypes`;
	int $size = size($arrayListType);
	float $CollumsA = float($size)/4.0;
	float $CollumsB = float($size)/3.0;
	string $commandPrint = "";
	int $iXiA = 0;
	int $iXiB = 0;
	int $iXiC = 0;
	while ($iXiA < ($CollumsB-1)){
		
		$iXiB = $iXiA +1;
		$iXiC = $iXiB +1;
		print ("// " + $arrayListType[$iXiA] + "          "); print ("// " + $arrayListType[$iXiB] + "          "); print ("// " + $arrayListType[$iXiC] + "\n");
		//$commandPrint = "print" + " " + "(" + "\""+ $arrayListType[$iXiA] + " "+ "\""+")" + ";"+"\n";
		//eval($commandPrint);
		$iXiA++;
	}
}
/*
proc replaceObjectsAndKeepOriginalConnections(  int $rot, int $scale, int $inst, int  $keepOriginal )
{
int $rot = 1; int $scale= 1; int $inst= 1; int $keepOriginal = 1;
	string $list[] = `ls -sl -tr`;
	int $size = `size $list`;
string $replacmentObject[0] = {$list[$size-1]};
	
	if ($size<2){
		error (uiRes ("m_replaceObjects.kReplaceObjectsErrorInvalid"))  ;
	}
	int $i = 0;
string $duplicateObject[];
	while ($i < ($size-1))
	{
		select -r ($list[$size-1]);
		if ($inst == 1){
			$duplicateObject = `duplicate -rr $list[$size-1]`; 
		}else if ($inst == 2){
			instance; 
		}else{
			//confirm object is a  reference
			int $reference =  `reference -q -isNodeReferenced`;
			if ($reference){
				duplicateReference 0 "";
			} else {
				error (uiRes ("m_replaceObjects.kReplaceObjectsErrorReference" )) ;
			}
		}
		
		//string $new[] = `ls -sl`;
string $polyFaceSelected[0] = {$list[$i]};
string $shapes[] = `listRelatives -s -path  $polyFaceSelected`;
string $shapesOne[0] = {$shapes[0]};
string $stringNames = $shapesOne[0];
string $arrayItems[];
string $matchitem[] = {`match "\\|" $stringNames`};
string $newList[];
if (size($matchitem)>0){    
	$arrayItems = stringToStringArray($stringNames , "|");
	$newList = stringArrayMatchToArray($item, $arrayItems);
}
string $AllConnections[] = `listConnections  $shapes[0]`;
listConnections group1|brick1|brick1Shape;
int $Vii = 0;
string $ConnectionsToMeshALL = `connectionInfo -isSource $AllConnections[$Vii]`;
$Vii++;
//string $list[] = `listConnections -type wire  $shapes[0]`;
string $oneshapeZ  = $shapes[0];
$oneshapeZ  += ".inMesh";
print $oneshapeZ;
string $ConnectionsToMeshZ = `connectionInfo -sfd  $oneshapeZ`;
string $item = "Shape";
deformer -e -g $new[0] ffd1;
print $duplicateObject
//listConnections
string $arrayONE[];
	$arrayONE = stringToStringArray ($ConnectionsToMeshZ, ".");
if (size($arrayONE) > 0){
string $polyFaceSelectedDup[0] = {$duplicateObject[0]};
string $Duplicateshapes[] = `listRelatives -s - path $polyFaceSelectedDup`;
string $oneDuplicateshapeZ = $Duplicateshapes[0];
//$oneDuplicateshapeZ += ".inMesh";
//connectAttr -force $arrayONE  $oneDuplicateshapeZ;
substituteGeometry $shapes[0] $Duplicateshapes [0];
}
}
		//Get and set Worldspace values	-  use rotate pivot in case translate has been  frozen	
		float $trans[] = `xform -q -ws - rotatePivot $list[$i]`; 	
		xform -a -ws -t $trans[0] $trans [1] $trans[2] $new[0];
		if ($rot) 
		{
			float $rotate[] =  `getAttr ($list[$i]+".r")`; 	
			setAttr ($new[0]+".r") 	 $rotate[0] $rotate[1] $rotate[2];
		}
		if ($scale)
		{
			float $scale[] = `getAttr  ($list[$i]+".s")`; 	
			setAttr ($new[0]+".s") 	 $scale[0] $scale[1] $scale[2];
		}
		string $parent[] = `listRelatives  -parent $list[$i]`;
		
		if ($parent[0] != ""){
			string $selection[] = `ls  -sl`;
			parent $selection[0]  $parent[0];			
		}
		
		delete $list[$i];
		$i++;
	}
	// if copy or instance
	//if (($inst != 3) && ($keepOriginal ==  0))
		//delete ($list[$size-1]);
	select -cl;
}
commandEcho -state on;
polyDuplicateAndConnect pPlane1;
//select -r $shapes;
string $polyFaceSelected[] = `ls -sl`;
string $shapes[] = `listRelatives -s -path  $polyFaceSelected`;
//string $list[] = `listConnections -type wire  $shapes[0]`;
string $oneshapeZ  = $shapes[0];
$oneshapeZ  += ".inMesh";
print $oneshapeZ;
string $ConnectionsToMeshZ = `connectionInfo -sfd  $oneshapeZ`;
string $arrayONE[];
	$arrayONE = stringToStringArray ($ConnectionsToMeshZ, " ");
if (size($arrayONE) > 0){
string $polyFaceSelectedDup[] = `ls -sl`;
string $Duplicateshapes[] = `listRelatives -s - path $polyFaceSelectedDup`;
string $oneDuplicateshapeZ = $Duplicateshapes[0];
//$oneDuplicateshapeZ += ".inMesh";
//connectAttr -force $arrayONE  $oneDuplicateshapeZ;
substituteGeometry -reWeightDistTolerance 50.0  $shapes[0] $Duplicateshapes[0];
}
substituteGeometry -retainOldGeometry - oldGeometryToLayer $shapes[0] $Duplicateshapes [0];
-oldGeometryToLayer
if (size($list) > 0){
if (size($list) == 1){
}
}
isConnected wire1.outputGeometry[0]  polySurfaceShape3.inMesh;
connectionInfo -is $oneshapeZ; 
connectionInfo -dfs $oneshapeZ;
string $ConnectionsToMeshZ = `connectionInfo -sfd  $oneshapeZ`;
string $arrayONE[];
	$arrayONE = stringToStringArray ($ConnectionsToMeshZ, " ");
connectAttr -force ffd1.outputGeometry[0]  |pCube1|pCubeShape1.inMesh;
string $ConnectionsZ =  destinationNodeNameFromConnection($oneshapeZ);
print $ConnectionsZ;
polyExtrudeFacet 
-constructionHistory 1 
-keepFacesTogether 1 
-pvx 1.956866086 
-pvy 0 
-pvz -3.265890372 
-divisions 1 
-twist 0 
-taper 1 
-off 0 
-smoothingAngle 30 $polyFaceSelected[0];
polySelectSp -ring; ConvertSelectionToFaces;
setAttr ($polyFaceSelected[1]+".translate") -type  double3 0 0 -0.475 ;
setAttr ($polyFaceSelected[1]+".localScale") - type double3 1 1 1.016687 ;
setAttr ($polyFaceSelected[1]+".localScale") - type double3 1.35 1.35 1.372527 ;
setAttr ($polyFaceSelected[1]+".localTranslate")  -type double3 0 0 0.0766679 ;
setAttr ($polyFaceSelected[1]+".localTranslate")  -type double3 0 0 0.147452 ;
proc AdvancedCurveMODprojectOnSurface(string  $AllIntersectCurveSA[], string $INarrayA[],  string $PolygonShapeXi[]){
int $Error = 0;
$Error++;
print ("error Here "+$Error);
string $polyShapRetopo[] = $PolygonShapeXi;
float $eachCVposSTART[];
float $eachCVposEND[];
string $MakespaceLocatorSTART[];
string $MakespaceLocatorEND[];
string $digitalSkeletonA[];
string $NewStraitCurve[];
int $numInts;
$numInts = size($digitalSkeletonA);
if ( $numInts > 0 ){
clear $digitalSkeletonA;
}
string $AllIntersectCurveS[] =  $AllIntersectCurveSA;
//EvalSmoothCurves;
//$digitalSkeletonA =  `StartofCurveScriptIntersectZX`;
string $AllCurveZ[];
$numInts = size($AllCurveZ);
if ( $numInts > 0 ){
clear $AllCurveZ;
} 
string $AllSpaceLocatorZ[];
$numInts = size($AllSpaceLocatorZ);
if ( $numInts > 0 ){
clear $AllSpaceLocatorZ;
} 
string $renamed[];
string $rebuildit[];
string $ZIntersectionCurveZA[];
string $intersectionCurve[]; 
string $MakeSpaceLocator[];
string $objectLocaterz[];
string $AllparamlocatorZ[];
int $numparam;
string $MakespaceLocatorZSE[];
string $SEspaceLocSetofSetz; 
string $paramANDCurve3[];
string $paramANDCurve2[];
string $paramANDCurve[];
string $paramCurveNAMES[];
string $paramlocatorZ[];
$numInts = size($paramlocatorZ);
if ( $numInts > 0 ){
clear $paramlocatorZ;
} 
string $intersectZ[];
string $ZBetween[];
string $objectCurveA[];
string $objectCurve[];
clear  $objectCurve;
float $EACHCVposA[];
float $EACHCVposB[];
float $p1Z; 	
int $moveCurve = 0;
string $objectSelection[];
$numInts = size($objectSelection);
if ( $numInts > 0 ){
clear $objectSelection;
} 
$objectSelection = `editDisplayLayerMembers -q  layerCurvesINRange1`;
int $numparam;
int $EdgecurvesizeNUM = size($objectSelection);
///errors here
if ($EdgecurvesizeNUM > 0){
float $tol = 0.45;
float $dir[3] ;	
		$dir = nurbsViewDirectionVector (0) ;
float $dirX, $dirY, $dirZ;
$dirX = $dir[0];
$dirY = $dir[1];
$dirZ = $dir[2];
string $eachZ;
string $curveIntersectZA;
int $Xxi = -1;
for ( $eachZ in $objectSelection ){
$objectCurve[0] = $eachZ;	
$Xxi++;
print $Xxi ;
$curveIntersectZA = `curveIntersect -ch off - useDirection on -direction $dirX $dirY $dirZ  $objectSelection[$Xxi] $AllIntersectCurveS`;
int $numTokens;		
string $tokens[];
$numTokens = `tokenize $curveIntersectZA " "  $tokens`;
print $numTokens;
if ($numTokens == 2){
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
$objectCurve[0] = $eachZ;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $buffer[];
$numTokens = `tokenize $curveIntersectZA " "  $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[0] + "]");
appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
		float $intersectposA[];	
	$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
clear $objectCurve; 
}
}
appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, size($AllSpaceLocatorZ));
string $shorterList[] =  stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterList;
int $CurvesCUTinto = size($AllCurveZ);
if ($CurvesCUTinto == 1){string $oneLocatorZ[] =  {$AllparamlocatorZ[0]}; $AllparamlocatorZ =  $oneLocatorZ; }
$numparam = size($AllparamlocatorZ);
if (($CurvesCUTinto == 2) && ($numparam == 4)){
string $oneLocatorZa[] = {$AllparamlocatorZ[0]}; 
string $oneLocatorZb[] = {$AllparamlocatorZ[1]}; 
$AllparamlocatorZ = {$oneLocatorZa[0],  $oneLocatorZb[0]}; 
}
$numparam = size($AllparamlocatorZ);
int $numInts = size($AllSpaceLocatorZ);
if (($CurvesCUTinto == 2) && ($numInts == 4)){
string $oneLocatorZ2a[] = {$AllSpaceLocatorZ[0]}; 
string $oneLocatorZ2b[] = {$AllSpaceLocatorZ[1]}; 
$AllSpaceLocatorZ = {$oneLocatorZ2a[0],  $oneLocatorZ2b[0]}; 
}
$numInts = size($AllSpaceLocatorZ);
if ( $numparam > 0 ){
string $shorterList[] =  stringArrayRemoveDuplicates($AllparamlocatorZ);
$AllparamlocatorZ = $shorterList;
}
$numparam = size($AllparamlocatorZ);
$numInts = size($AllSpaceLocatorZ);
select -cl  ;
$SEspaceLocSetofSetz = `sets -name  SEspaceLocSetofSets`;	
$paramANDCurve3 = `paramToCurvePts3(  $AllparamlocatorZ )`;
$paramANDCurve2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
$paramANDCurve = `paramToCurvePts(  $AllparamlocatorZ )`;
$paramCurveNAMES = `tokenizeparam( $paramANDCurve  )`;
$MakespaceLocatorZSE = EvalMoveCurvesTOend ($paramANDCurve, $paramCurveNAMES,  $paramANDCurve3, $AllparamlocatorZ,  $SEspaceLocSetofSetz);
if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
int $setsNumber = `sets -q -size  $SEspaceLocSetofSetz`;
if ($setsNumber > 0){
string $subsets[];
$subsets = `sets -q $SEspaceLocSetofSetz`;
//appendStringArray($digitalSkeletonA, $subsets,  size($subsets));
}
/////////////////////
// end of if Size of Curves are greater then ONE 
}
print $numparam;
/////////////////////
/////////////////////
/////////////////////
	if ( $numparam == 0 ){
int $trueORfalse = 0;
int $trueORfalse2 = 0;
string $oldName = $AllIntersectCurveS[0];
$trueORfalse = FindIfCurveCrossesZ ($AllIntersectCurveS);
string $newname[]; 
if ($trueORfalse == 1){
$newname = CutCurveIFConditionTRUETransitZ ($AllIntersectCurveS);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $oldName;
$AllIntersectCurveS = {$oldName}; 
}
if ($trueORfalse == 0){
ResetTranslation($AllIntersectCurveS);
}
MirrorANDrename($AllIntersectCurveS);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $AllIntersectCurveS;
//if($intZplainF > 0)  {
//select -r $ParentArc;
//MirrorANDrename($AllIntersectCurveS);
//}
} else if ( $numparam == 1 ){
string $renamed[]; 
$renamed[0] = $AllIntersectCurveS[0];
ResetTranslation($renamed);
float $arclenghtDrawCurve = `arclen  $AllIntersectCurveS[0]`;
float $arcLenCurveFrac = $arclenghtDrawCurve/5;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($renamed[0] + ".cv[0]") ;		 	
$CurveSelection[1] = ($renamed[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
if (size($MakespaceLocatorZSE) > 0){
int $ZEROorONE;
int $foundA = stringArrayGmatch ("SEspaceLocatorSTART3DZ*",  $MakespaceLocatorZSE);
int $foundB = stringArrayGmatch ("SEspaceLocatorEND3DZ*", $MakespaceLocatorZSE);
if (( $foundA == 1 ) || ( $foundB == 1 )) {
float $eachCVposSTART[] = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
float $movePIVOT[];
$ZEROorONE = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTART);
string $pointEP;
if ( $ZEROorONE == 0){ $movePIVOT = $EACHCVposAZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[0];  }
if ( $ZEROorONE == 1){ $movePIVOT = $EACHCVposBZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[1];  }
//ADD SOFT SELECT HERE
select -r $pointEP;
softSelect -e -softSelectEnabled true;
softSelect -e -softSelectDistance  $arcLenCurveFrac;
move -rpr $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2];
xform -cp $renamed[0];
softSelect -e -softSelectEnabled false;
FlattenCurveOnMesh( $AllIntersectCurveS,  $polyShapRetopo);
}
}
if (size($MakespaceLocatorZSE) == 0){
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $AllCurveZA = ("A"+ $AllCurveZ[0]+"A");
delete $AllCurveZA;
delete $AllCurveZ;
string $AllCurveZ2[];
string $newCurveZA[];
string $newCurveBB[];
for ($each in $detachCurve1){
$newCurveBB[0] = `rename $each Curve`;
MirrorANDrename($newCurveBB);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveBB[0];
ArrayInsertAtEnd( $newCurveZA, $newCurveBB[0]);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurveZA[0]);
ArrayInsertAtEnd( $INarrayA,$newCurveZA[1]);
string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurveZA;
}
delete $digitalSkeletonA;
ResetTranslation($renamed);
string $renamed2[];
$renamed2 = $renamed;
///////////////////////////////////////////////// ///////
// IF Drawn Curve is connected to the end of  another curve thast is in EdgeSet
// the curve drawn can be on a edge curve which  is eather protruding from the ZY plain 
// or it lies on the ZY plain. if it is at one of  the two ends of a protruding EdgeCurve
// then the drawn curve intersecting at  EdgeCurves Ends is eather also protruding from ZY  plain or 
// is positioned freely at the other end.. which  means it could be crossing the ZY plain which  means     
// It would need to be cut
$Error++;
print ("error Here "+$Error);
int $ifNearEnds = size($MakespaceLocatorZSE);
int $AllCurveCVsZeroAndLast = FindIfCurveISonZ ($AllCurveZ);
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $ZeroX = 0;
if (( $ifNearEnds == 1) && (  $AllCurveCVsZeroAndLast == 1) && ( $edgeZsetA ==  1)) {
vector $AllCurveCVENDs[] = `VecCurveEnds ($AllCurveZ)`;
vector $renamed2CVENDs[] = `VecCurveEnds ($renamed2)`;
float $renamed2CVENDAs[] = $renamed2CVENDs[0];
float $renamed2CVENDBs[] = $renamed2CVENDs[1];
float $AllCurveCVENDAs[] = $AllCurveCVENDs[0];
float $AllCurveCVENDBs[] = $AllCurveCVENDs[1];
float $FloatZ1[] = $renamed2CVENDAs;
float $FloatZ2[] = $renamed2CVENDBs;
float $FloatZ3[] = $AllCurveCVENDAs;
float $FloatZ4[] = $AllCurveCVENDBs;
$renamed2CVENDAs = `MakeCleanFloats($FloatZ1)`;
$renamed2CVENDBs = `MakeCleanFloats($FloatZ2)`;
$AllCurveCVENDAs = `MakeCleanFloats($FloatZ3)`;
$AllCurveCVENDBs = `MakeCleanFloats($FloatZ4)`;
int $CombA = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDAs);
int $CombB = PointsEquivalentTol ($renamed2CVENDBs, $AllCurveCVENDBs);
int $CombC = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDBs);
float $intersectFloat[];
if ($CombA == 3 ){ $intersectFloat =  $AllCurveCVENDAs;}
if ($CombB == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
if ($CombC == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
float $Zero0x = 0.0;
$ZeroX = equivalentTol($Zero0x, $intersectFloat [0], 0.001);
}
$intZplainF = 1;
if ($ZeroX == 1){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}
if ($AllCurveCVsZeroAndLast == 2){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed2);
}
}
int $trueORfalse = 0;
int $trueORfalse2 = 0;
if ($ZeroX == 0){
$trueORfalse = FindIfCurveCrossesZ($renamed2);
string $newname[]; 
if (($trueORfalse == 1) && ($ZeroX == 0)){
$newname = CutCurveIFConditionTRUETransitZ ($renamed2);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $renamed2; 
}
}  
string $newnamed[0] = {$renamed2[0]};
ResetTranslation($newnamed);
//string $ParentArc[];
//$ParentArc = Strait_ARC_or_FreeForm($newnamed,  5.5, 2.5 );
if($intZplainF > 0)  {
select -r $newnamed;
MirrorANDrename($newnamed);
}
if (($ZeroX == 1) || ($trueORfalse2 == 1)){
sets -include ZEdgeCurvesSet $newnamed;
}
//ArrayInsertAtEnd( $INarrayA, $newnamed[0]);
print "check Here6";
ResetTranslation($newnamed);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newnamed;
select -r $newnamed[0];
EvalAddingCurves;
EvalcreatSphere;
//////////////////////////////////////END OF ONE  CURVE
} else if ( $numparam > 2 ){
// Buffers of u para of DrawnCurve placed in a  Array then Sorted. ///
if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
delete $digitalSkeletonA;
} else if ( $numparam == 2 ){
//////////////////////////////////////
////NEW NEW NEW
$rebuildit = $AllIntersectCurveS;
//NEW START//
//ResetTranslation($rebuildit);
select -r $AllIntersectCurveS $AllCurveZ[0];
	string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;
cutCurvePreset(1,1,0.01,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}		
}
if (catch(`select -r $bufferCutCurve[0]  $AllCurveZ[1]`)){
select -r $AllIntersectCurveS $AllCurveZ[1];
	} else { print "hereCUT2"; }
cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
	$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
}		
}
$renamed[0] = `rename $ZIntersectionCurveZ[0]  Curve`;
string $ZIntersectionCurveZB[];
$ZIntersectionCurveZB = `listRelatives -shapes  $renamed`;
if (size($ZIntersectionCurveZB) > 0 ){
string $ListCONCurveZA[];
$ListCONCurveZA = `listConnections  $ZIntersectionCurveZB`;
if (size( $ListCONCurveZA) > 0){
string $ListCONCurveZB[];
$ListCONCurveZB = `listConnections -shapes 0 - source 0 $ListCONCurveZA`;
delete  $ListCONCurveZA $ListCONCurveZB;
}
}
$rebuildit = $renamed;
ResetTranslation($rebuildit);
if ( size($MakespaceLocatorZSE) == 0  ) {
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $detachCurve2[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[1]`;
delete $AllCurveZ;
string $newCurves1[];
string $newCurves2[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}
for ($each in $detachCurve2){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves2, $newCurve);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[1]);
ResetTranslationEach($newCurves1);
ResetTranslationEach($newCurves2);
string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurves1;
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[0]);
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[1]);
}
int $ONEspaceLOC = 0;
string $newCurves1[];
if (size($MakespaceLocatorZSE) == 1){
$ONEspaceLOC = 1;
string $subsetsA[];
$subsetsA = `sets -q $SEspaceLocSetofSetz`;
string $subsetsB[]; string $subsetsB2[];
$subsetsB = `sets -q $subsetsA`;
$subsetsB2[0] = $subsetsB[0];
$subsetsB3[0] = $subsetsB[1];
string $SetItemA = ($subsetsB2[0]);
string $SetItemB = ($subsetsB3[0]);
string $subsetItemNeeded[];
int $setATrueFalse = `gmatch $SetItemA "*->*"`;
int $setBTrueFalse = `gmatch $SetItemB "*->*"`;
if ($setATrueFalse == 1){
$subsetItemNeeded[0] = $subsetsB2[0];
}else{ $subsetItemNeeded[0] = $subsetsB3[0]; }
string $bufferZ[];
$numTokensX = `tokenize $subsetItemNeeded[0] "->"  $bufferZ`;
print $bufferZ; 
string $CurveLOCZ[] =  {$bufferZ[1]};
string $paramANDCurveA02[];
$paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ  )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA02[0]`;
delete $subsetsB[0];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
delete $AllparamlocatorZ; 
}
if ( size($MakespaceLocatorZSE) > 0  ) {
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
$MakeXBetweenB[0] = `curve -d 1 -p $EACHCVposAZ [0] $EACHCVposAZ[1] $EACHCVposAZ[2] -p  $EACHCVposBZ[0] $EACHCVposBZ[1] $EACHCVposBZ[2]  -k 0 -k 2 -n                        XCurveBetweenB`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 1 -tol 0.001  $MakeXBetweenB[0];
appendStringArray($digitalSkeletonA,  $MakeXBetweenB, 1);
}
}
wire -gw false -en 1.000000 -ce 0.000000 -li  1.000000 -w $MakeXBetweenB[0] -dds 0 50.000000  $rebuildit[0];

string $CurveSelection[]; 
int $numCVs = `getAttr -size ($MakeXBetweenB[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($MakeXBetweenB[0] + ".cv [0]") ;			
$CurveSelection[1] = ($MakeXBetweenB[0] + ".cv["  + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
				}
int $ZEROorONEA;
int $ZEROorONEB;
string $locZSE0[];
string $locZSE1[];
int $foundAZ0;
int $foundBZ0;
int $foundAX1;
int $foundBX1;
int $i = 0;
int $iX = 0;
float $eachCVpos1[];
float $eachCVpos2[];
float $movePIVOT1[];
float $movePIVOT2[];
	if (size($MakespaceLocatorZSE) == 1){	 $i = 1; }
	if (size($MakespaceLocatorZSE) == 2){ 	 $iX = 2; }
	if (( $i == 1) || ( $iX == 2)){
$locZSE0[0] = $MakespaceLocatorZSE[0];
$eachCVpos1 = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
	if ( $iX == 2){
$locZSE1[0] = $MakespaceLocatorZSE[1];
$eachCVpos2 = `pointPosition -w  ($MakespaceLocatorZSE[1])`;
	}
	if (( $i == 1) || ( $iX == 2)) {
$ZEROorONEA = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos1);
if ( $ZEROorONEA == 0){ $movePIVOT1 =  $eachCVpos1; print "cv ZERO"; }
if ( $ZEROorONEA == 1){ $movePIVOT1 =  $eachCVpos1; print "cv LAST"; }
if ( $iX == 2){
$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos2);
if ( $ZEROorONEB == 0){ $movePIVOT2 =  $eachCVpos2; print "cv ZERO"; }
if ( $ZEROorONEB == 1){ $movePIVOT2 =  $eachCVpos2; print "cv LAST"; }
move -ws $movePIVOT2[0] $movePIVOT2[1]  $movePIVOT2[2] $CurveSelection[$ZEROorONEB];
	}
move -ws $movePIVOT1[0] $movePIVOT1[1]  $movePIVOT1[2] $CurveSelection[$ZEROorONEA];
				}
delete -ch $rebuildit;
delete $digitalSkeletonA; 				 	}
}
/////////////////////////////
int $CVsZeroAndLast;
if ( size($MakespaceLocatorZSE) > 0  ) {
if ( `objExists ZEdgeCurvesSet` == 1  ) {
if ( $ONEspaceLOC == 0  ) {
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $edgeZsetB = `sets -im ZEdgeCurvesSet  $AllCurveZ[1]`;
$CVsZeroAndLast = FindIfCurveISonZ($rebuildit);
if (($edgeZsetA == 1) && ($edgeZsetB == 1)){
print "Intersects edgeZset Curves";
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($rebuildit[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;
if ($CVsZeroAndLast == 2){
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
xform -cp;
}
}
}
}
ResetTranslation($rebuildit);
select -r $rebuildit;
//string $ParentArc[];
//$ParentArc = Strait_ARC_or_FreeForm($rebuildit,  5.5, 2.5 );
print $CVsZeroAndLast;
//FROM HERE DOWN all -- $rebuildit -- strings[]  WERE $ParentArc  
if($CVsZeroAndLast < 2){
select -r $rebuildit;
MirrorANDrename($rebuildit);
}
if ( $CVsZeroAndLast > 0){ 
sets -include ZEdgeCurvesSet $rebuildit;
}
ArrayInsertAtEnd( $INarrayA, $rebuildit[0]);
ResetTranslation($rebuildit);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $rebuildit;
select -r $rebuildit[0];
EvalAddingCurves;
EvalcreatSphere;
////////////////////TRIGGER###################### #######////////////////
}
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 
if ( `objExists $SEspaceLocSetofSetz` == 1  ) { 	
select -r -ne $SEspaceLocSetofSetz;
delete;
}
}
*/
proc string ConvertPolyFacesIntoNurbSurface(){
	string $PolyFaceslist[] = `ls -sl`;
	string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft  1 -dup 0 -off 0 $PolyFaceslist`;
	print $NewPolyFaces;
	string $HistoryConnections[] = ` listHistory - future true -pruneDagObjects false  $NewPolyFaces`;
	string $polySep[] = `polySeparate -rs 1 -ch 0  $HistoryConnections[1]`;
	select -r $polySep[1];
	string $PolygonNew[0] = {$polySep[1]};
	parent -w $PolygonNew;
	string $PolyFaces = ( $PolygonNew[0] +".f[*]");
	string $AllPolyFaces[] = `ls -fl $PolyFaces`;
	string $AllPolyFaces2[] = `ls $PolyFaces`;
	string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
	string $ReturnObjects = "";
	float $valuesP[];
	for ($eachP in $diffEdgeVertz){
		$valuesP = `pointPosition -w ($eachP)`;	
		string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorCX`; 
		move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
		$ReturnObjects += $spaceLocatorB[0]+" ";
	}
	string $DiffPolyBorderEdges[] =  GetdiffEdgesOfBorder($PolygonNew);
	string $SelectedPolyBorderEdges[] =  PolyBorderEdges($PolygonNew);
	int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
	string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
	stringArrayRemoveAtIndex(0, $diffEdgeVertz);
	string $NearEdges[] = GetNearEdges ($EdgeVertzStart);
	string $NearEdgesOne[0] = {$NearEdges[0]};
	string $NearEdgesSecond[0] = {$NearEdges[1]};
	appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
	string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
	string $orderedArray[0] = {$NearEdgesOne[0]};
	int $Xi = 1;
	while ($Xi < $sizeBorderEdges){
		$Xi++;
		string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
		appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
		string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
		string $EdgesVertex[] = ls(" -fl",polyListComponentConversion(" -toVertex",$diffB[0]));
		int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
		appendStringArray($orderedArray, $diffB, 1);
		$NearEdgesOne = $diffB;
	}
	appendStringArray($orderedArray,  $NearEdgesSecond, 1);
	$EdgeLists = "";
	int $iix = 0;
	int $iiV = 0;
	for ($each in $orderedArray){
		string $oneItem[0] = {$each};
		string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
		if ( $iix > 0){
			$ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
			if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
					$EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
			if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
		}
		if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
		$iix++;
	}
	string $bufferList[];
	$numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
	string $EdgeCurves[];
	clear $EdgeCurves;
	string $EdgesVertexEach[];
	string $ListA[];
	for($eachBuffer in $bufferList){
		string $ListA[] = `stringToStringArray  $eachBuffer " "`;
		//string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
		string $EdgesVertexEachOrder[] =  VertLoopEdgeLoop($ListA);
		$curve = "curve -d 1";	
		float $values[];
		for($eachVert in $EdgesVertexEachOrder){ 
			$values = `pointPosition -w ($eachVert)`;		
			$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
		}
		string $Newcurvez = `eval($curve)`;
		string $NewcurveX[];
		$NewcurveX = {$Newcurvez};
		appendStringArray($EdgeCurves, $NewcurveX, 1);
	}
	select -r $EdgeCurves;
	string $NurbSurfaceFromPolyFaces =  `alternativeBoundry`;
	delete -ch $EdgeCurves;
	delete $PolygonNew;
	$ReturnObjects += $NurbSurfaceFromPolyFaces;
	$ReturnObjects += " "+$EdgeCurves[0] +"  "+$EdgeCurves[1] +" "+$EdgeCurves[2] +"  "+$EdgeCurves[3] ;
	select -r $EdgeCurves;
	print $ReturnObjects;
	return $ReturnObjects;
}
/////////////////////
//whatIs polyDuplicateAndConnect;
proc TempRemoveCurveOnSurf(){
	string $ObjectItemXi[] = `ls -sl`;
	string $ObjectCurveXi[] = `duplicateCurve -ch 0 -rn 0 -local 0 "LiveSurfaceBShape->curve2" `;
	delete $ObjectItemXi;
	rename $ObjectCurveXi[0] curve;
}
//string $ObjectItemXi[] = `ls -sl`;
//xform -q -boundingBox $ObjectItemXi
proc string[] CreatePolyFromFloats(float $BoxPointsX[]){
	float $bbox[] = $BoxPointsX;
	float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
	float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
	float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
	float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
	///
	vector $BoxPointZ[];
	$BoxPointZ[0] = <<$bbox[0], $bbox[4], $bbox[2]>>;
	$BoxPointZ[1] = <<$bbox[3], $bbox[4], $bbox[2]>>;
	$BoxPointZ[2] = <<$bbox[3], $bbox[4], $bbox[5]>>;
	$BoxPointZ[3] = <<$bbox[0], $bbox[4], $bbox[5]>>;
	int $sizeVecBox = size($BoxPointZ);
	string $polyZ = "polyCreateFacet";
	int $ZiI = 0;
	progressWindow -ii true -title "Working" -status  "Moving Verts" -max (size($BoxPointZ)) -progress  0;
	while ($ZiI < $sizeVecBox){
		float $values[] = $BoxPointZ[$ZiI];
		$polyZ += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		$ZiI++;
		progressWindow -e -s 1;
		if (`progressWindow -q -ic`)
		{
			progressWindow -endProgress;
			error  "User Interupt.";
		}
	}
	print $polyZ;
	string $NewPolyZz[0] = `eval($polyZ)`;
	progressWindow -endProgress;
	select -r $NewPolyZz;
	ResetTranslation($NewPolyZz);
	return $NewPolyZz;
}
///////////////////////////////////////////////// /////////////////////////////////
global proc float GetDistancePointPositionFLOAT (string $objectFirst, string $objectSecond){
	float $pointAZ1[]; float $pointAZ2[];
	if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
		print "using Xform"; $pointAZ1 = `xform -q -ws -rp ($objectFirst)`;
	} 
	if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
		print "using Xform"; $pointAZ1 = `xform -q -ws -rp ($objectSecond)`;
	} 
	$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
	$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
	float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
	return $distanceA2; 
}
///////////////////////////////////////////////// ////////////
proc string alternativeBoundry(){
	int $hist = `constructionHistory -q - tgl`;
	global int $gSelectNurbsCurvesBit;
	global int $gSelectIsoparmsBit;
	global int $gSelectCurvesOnSurfacesBit;
	global int $gSelectSurfaceEdgeBit;
	string $curves[] = `filterExpand -ex true  -sm $gSelectNurbsCurvesBit -sm  $gSelectIsoparmsBit -sm  $gSelectCurvesOnSurfacesBit -sm    $gSelectSurfaceEdgeBit`;
	string $surface = "";
	int $n = size($curves);
	int $i;
	if( $n < 4 ) return $surface;
	string $cmd = "boundary -or 0 -ep 0 -rn 1  -po 0 -ept 0.001 -ch  " + $hist + " ";
	// Rebuild them into linears (keep cvs):
	for( $i=0; $i<$n; $i+=1 ) {
		string $now[] = `rebuildCurve -ch  0 -rpo 1 -kcp on -d 1 -rt 0 $curves[$i]`;
		$curves[$i] = $now[0];
		$cmd = $cmd + $curves[$i] + " ";
	}
	// Convert back into cubic:
	string $res[] = eval($cmd);
	if( size($res) > 0 ) {
		$surface = $res[0];
		rebuildSurface -ch $hist -rpo 1 -rt 0 -end 1 -kr  0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.001  -fr 0  -dir 2 $surface;		
	}
	if( !$hist ) {
		for( $i=0; $i<$n; $i+=1 ) {
			delete $curves[$i];
		}
	}
	select -r $curves;
	return $surface;
}
///////////////////////////////////////////////// //////////////

global proc CreateCircleINpolyFaces(){
	//string $FirstPolyFaceslistAll[] = `ls -sl`;
	//for ($each in $FirstPolyFaceslistAll){
	//select -r $each;
	GrowPolygonSelectionRegion;
	string $FirstPolyFaceslist[] = `ls -sl`;
	string $bufferListShape[];
	$numTokensA = `tokenize $FirstPolyFaceslist[0]  "." $bufferListShape`;
	print  $bufferListShape;
	string $PolyName[0] = {$bufferListShape[0]};
	string $nurbSurfaceSelectionC  =  `ConvertPolyFacesIntoNurbSurface`;
	string $ListofItemConvert[] =  `stringToStringArray $nurbSurfaceSelectionC " "`;
	print $nurbSurfaceSelectionC ;
	string $FirstPolyEdgelist[] = `ls -sl`;
	select -r $FirstPolyEdgelist;
	print $FirstPolyEdgelist;
	int $CurveEPzCount[];
	int $Xiii = 0;
	string $CurveEPzCountS[];
	for ($eachEP in $FirstPolyEdgelist){
		string $CurveSelection[] = `ls -fl  ($eachEP+".ep[0:*]")`; 
		$CurveEPzCountS[$Xiii] = size ($CurveSelection);
		$Xiii++;
	}
	print  $CurveEPzCountS;
	string $CurveEPNumbersList[] =  stringArrayRemoveDuplicates( $CurveEPzCountS);
	//$CurveEPNumbersList = `sort  $CurveEPNumbersList`;
	int $SpanX = $CurveEPNumbersList[0];
	$SpanX = $SpanX - 1;
	int $SpanZ = $CurveEPNumbersList[1];
	$SpanZ = $SpanZ - 1;
	int $ifEqual = 0;
	if ($SpanX == $SpanZ ){ $ifEqual = 1;}
	//boundarySurface2.v[0] in V $NurbsBorderCv  Number
	//LOC
	string $CLocators[] = { $ListofItemConvert[0],  $ListofItemConvert[1], $ListofItemConvert[2],  $ListofItemConvert[3]};
	//SURF
	string $nurbSurfaceSelectionZ[] =   {$ListofItemConvert[4]} ;
	string $MiddleNurbSurface = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.5]");
	float $middlePoint[] = `pointPosition -w  $MiddleNurbSurface`;
	string $FourPointsNurbSurA = (  $nurbSurfaceSelectionZ[0] +".uv[0.9][0.5]");
	string $FourPointsNurbSurB = (  $nurbSurfaceSelectionZ[0] +".uv[0.1][0.5]");
	string $FourPointsNurbSurC = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.9]");
	string $FourPointsNurbSurD = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.1]");
	float $distancePointZ[] =  {GetDistancePointPositionFLOAT ($FourPointsNurbSurA, $FourPointsNurbSurB),  GetDistancePointPositionFLOAT   ($FourPointsNurbSurC, $FourPointsNurbSurD)};
	int $AB = 0; 
	int $surfaceAB;
	int $surfaceCD;
	$surfaceAB = $SpanZ;
	$surfaceCD = $SpanX;
	if ($distancePointZ[0] > $distancePointZ[1]){ 
		$AB = 1;
	} else { $AB = 0; }
	/*
if ( $AB == 1 ){
$surfaceAB = $SpanX;
$surfaceCD = $SpanZ; } else { $surfaceAB =  $SpanZ;
$surfaceCD = $SpanX; }
*/
	float $newdistance[] = `sort $distancePointZ`;
	print $distancePointZ;
	float $CircleDZ = $newdistance[0] / 2.75;
	string $circleshape[];
	clear $circleshape;
	string $circleshape[] = `circle -c 0 0 0 -nr 0 1  0 -sw 360 -r $CircleDZ -d 3 -ut 0 -tol 0.001 -s 8  -ch 1`;
	move -ws $middlePoint[0] $middlePoint[1]  $middlePoint[2] $circleshape;
	normalConstraint -weight 1 -aimVector 0 1 0 - upVector 0 1 0 -worldUpType "vector" - worldUpVector 0 1 0 $nurbSurfaceSelectionZ  $circleshape;
	string $myCurve =  $circleshape[0];
	string $allcurvesB[];
	clear $allcurvesB;
	for($eachLOC in $CLocators){
		$myCPOC = `createNode closestPointOnCurve`;
		connectAttr ($myCurve+".worldSpace")  ($myCPOC+".inCurve");
		//delete THIS when done/////////////
		$spaceResultA = `spaceLocator -p 0 0 0 -n  LocatorC`; 
		$LOCB = $spaceResultA[0];
		connectAttr ($myCPOC+".position")  ($LOCB+".translate");
		$LocA = $eachLOC;
		connectAttr ($LocA+".translate")  ($myCPOC+".inPosition");
		float $valuesZ1[] = getAttr  ($myCPOC+".position");
		float $valuesZ2[];
		$valuesZ2 = `pointPosition -w ($LocA)`;	
		string $curveBetween[] = MakeCurveBetweenFloats ($valuesZ1, $valuesZ2);
		appendStringArray($allcurvesB, $curveBetween,1);
		delete $LOCB $myCPOC;
	}
	///////////////////////////////////
	string $ProjecCurvs = "";
	for($eachCurvB in $allcurvesB){
		string $proJCurv[] = `projectCurve -ch true -rn  false -un  true  -tol 0.001 $eachCurvB  $nurbSurfaceSelectionZ `;
		$ProjecCurvs += $proJCurv[1]+"\+"+" "; }
	string $ProjecCurvresultA =  substituteAllString($ProjecCurvs, "jectC",  "jectionC");
	print $ProjecCurvresultA;
	string $ProjecCurvsB = $ProjecCurvresultA;
	string $ProjecCurvresultB = substituteAllString ($ProjecCurvsB, "+", "_Shape1");  
	print $ProjecCurvresultB;    
	string $ListProjecCurv[] = `stringToStringArray  $ProjecCurvresultB " "`;
	//## End of Corner Curves Start of Circle  Projection //
	string $proJCurvA[] = `projectCurve -ch true -rn  false -un  true  -tol 0.001 $circleshape[0]  $nurbSurfaceSelectionZ `;
	string $ProjecCurvsA = "";
	$ProjecCurvsA += $proJCurvA[1]+"\+"+" ";
	string $ProjecCurvresultC =  substituteAllString($ProjecCurvsA, "jectC",  "jectionC");
	string $ProjecCurvsD = $ProjecCurvresultC;
	string $ProjecCurvresultE =  substituteAllString($ProjecCurvsD, "+",  "_Shape1");
	string $ListProjecCurvF[] = `stringToStringArray  $ProjecCurvresultE " "`;
	print $ProjecCurvsD ;
	print $ListProjecCurvF;
	string $boundZ1[];
	string $thelist[] = { $ListProjecCurv[0],  $ListProjecCurv[1], $ListProjecCurv[2],  $ListProjecCurv[3], $ListProjecCurvF[0] };
	string $FourPointsNurbSurA = (  $nurbSurfaceSelectionZ[0] +".uv[0.9][0.5]");
	string $FourPointsNurbSurB = (  $nurbSurfaceSelectionZ[0] +".uv[0.1][0.5]");
	string $FourPointsNurbSurC = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.9]");
	string $FourPointsNurbSurD = (  $nurbSurfaceSelectionZ[0] +".uv[0.5][0.1]");
	string $surfaceA[] = `trim -ch on -o on -rpo off  -lu 0.9 -lv 0.5 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
	string $surfaceB[] = `trim -ch on -o on -rpo off  -lu 0.1 -lv 0.5 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
	string $surfaceC[] = `trim -ch on -o on -rpo off  -lu 0.5 -lv 0.9 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
	string $surfaceD[] = `trim -ch on -o on -rpo off  -lu 0.5 -lv 0.1 $nurbSurfaceSelectionZ[0]  $thelist[0] $thelist[0] $thelist[1] $thelist[2]    $thelist[3] $thelist[4]`;
	string $AllsurfaceA_D[] = {$surfaceA[0],  $surfaceB[0], $surfaceC[0], $surfaceD[0]};
	string $trimedSurfA[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceAB -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceA[0]`;
	string $trimedSurfB[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceAB -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceB[0]`;
	string $trimedSurfC[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceCD -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceC[0]`; 
	string $trimedSurfD[] = `rebuildSurface -ch 1 - rpo 1 -rt 6 -end 1 -kr 2 -kcp 0 -kc 0 -su 3 -du 0  -sv $surfaceCD -dv 0 -tol 0.001 -fr 0  -dir 2    $surfaceD[0]`;
	string $finalSurface[] = `makeSingleSurface -mnd  1  -ch 1 -f 2 -pt 1 -pc 58 -chr 0.9 -ft 0.01 -mel  0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -   ucr 0 -cht 0.01 -es 0 -ntr 0 -stitchTolerance  0.6099 $trimedSurfA[0] $trimedSurfB[0]  $trimedSurfC[0] $trimedSurfD[0]`;
	delete -ch $finalSurface[0] $thelist  $nurbSurfaceSelectionZ $allcurvesB;
	delete $allcurvesB;
	delete $thelist;
	delete $CLocators $nurbSurfaceSelectionZ ;
	delete -ch $AllsurfaceA_D;
	delete $AllsurfaceA_D;
	delete $FirstPolyEdgelist;
	string $combinedPolys[] = `polyUnite -ch 0  $PolyName $finalSurface[0]`;
	//polyMergeVertex  -d 0.475 -am 1 -ch 0  $combinedPolys[0];
	print $finalSurface;
	print $PolyName;
	print $circleshape;
	//}
}
/////////////////////END
global proc int FindifArraysContain(string  $FirstList[], string $array2[]){
	int $found;
	int $Trigger;
	for ($each in $FirstList){
		string $oneItemz = $each;
		$found = stringArrayContains($oneItemz, $array2);
		if ( $found == 1 ){ $Trigger = 1; break; }
	}
	return $Trigger;
}
proc ArrayToVertexFaceNormal(){
	$list = `ls -sl`;
	$surface = $list[0];
	$object = $list[1];
	string $PolyFaceZ = ( $surface +".f[*]");
	string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
	select -r $AllPolyFaceZ;
	ShrinkPolygonSelectionRegion;
	string $EdgePolyFaceZ[] = `ls -sl -fl`;
	string $PolyEdgelistA[] = ls("- fl",polyListComponentConversion(  "-toVertex",  "-fromFace",$EdgePolyFaceZ));
	select -cl  ;
	string $newobject[];
	//
	for ($eachV in $PolyEdgelistA){
		string $Vert = $eachV;
		$newobject = `duplicate -rr -un $object`;	
		float $pos[];	
		$pos = `pointPosition -w $Vert`;	
		move  -ws $pos[0] $pos[1] $pos[2]  $newobject;
		normalConstraint -weight 1 -aimVector 0 1 0 - upVector 0 1 0 -worldUpType "vector" - worldUpVector 0 1 0 $surface $newobject; 
	}
}
proc string[] ConvertPolyPlaneIntoNurbSurfaceZ (string $PolygonNew[]){
	string $PolyFaces = ( $PolygonNew[0] +".f[*]");
	string $AllPolyFaces[] = `ls -fl $PolyFaces`;
	string $AllPolyFaces2[] = `ls $PolyFaces`;
	string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
	string $ReturnObjects = "";
	float $valuesP[];
	for ($eachP in $diffEdgeVertz){
		$valuesP = `pointPosition -w ($eachP)`;	
		string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorCX`; 
		move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
		$ReturnObjects += $spaceLocatorB[0]+" ";
	}
	string $DiffPolyBorderEdges[] =  GetdiffEdgesOfBorder($PolygonNew);
	string $SelectedPolyBorderEdges[] =  PolyBorderEdges($PolygonNew);
	int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
	string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
	stringArrayRemoveAtIndex(0, $diffEdgeVertz);
	string $NearEdges[] = GetNearEdges ($EdgeVertzStart);
	string $NearEdgesOne[0] = {$NearEdges[0]};
	string $NearEdgesSecond[0] = {$NearEdges[1]};
	appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
	string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
	string $orderedArray[0] = {$NearEdgesOne[0]};
	int $Xi = 1;
	while ($Xi < $sizeBorderEdges){
		$Xi++;
		string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
		select -r $NearEdgesA;
		appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
		string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
		select -r $diffB;
		string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("- toVertex",$diffB[0]));
		int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
		appendStringArray($orderedArray, $diffB, 1);
		$NearEdgesOne = $diffB;
	}
	appendStringArray($orderedArray,  $NearEdgesSecond, 1);
	$EdgeLists = "";
	int $iix = 0;
	int $iiV = 0;
	for ($each in $orderedArray){
		string $oneItem[0] = {$each};
		string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
		playButtonStepForward;
		select -r $EdgesVertex;
		playButtonStepForward;
		if ( $iix > 0){
			$ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
			if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
					$EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
			if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
		}
		if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
		$iix++;
	}
	string $bufferList[];
	$numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
	string $EdgeCurves[];
	clear $EdgeCurves;
	string $EdgesVertexEach[];
	string $ListA[];
	for($eachBuffer in $bufferList){
		string $ListA[] = `stringToStringArray  $eachBuffer " "`;
		//string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
		string $EdgesVertexEachOrder[] =  VertLoopEdgeLoop($ListA);
		$curve = "curve -d 1";	
		float $values[];
		for($eachVert in $EdgesVertexEachOrder){  playButtonStepForward; 
			select -r $eachVert; playButtonStepForward;
			$values = `pointPosition -w ($eachVert)`;		
			$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
		}
		string $Newcurvez = `eval($curve)`;
		string $NewcurveX[];
		$NewcurveX = {$Newcurvez};
		appendStringArray($EdgeCurves, $NewcurveX, 1);
	}
	select -r $EdgeCurves;
	string $NurbSurfaceFromPolyFaces[0] =  {`alternativeBoundry`};
	delete -ch $NurbSurfaceFromPolyFaces;
	delete -ch $EdgeCurves;
	delete $PolygonNew;
	string $ListofItemConvert[] =  `stringToStringArray $ReturnObjects " "`;
	delete $ListofItemConvert;
	return $NurbSurfaceFromPolyFaces;
}
///////////////////////////////////////////////// ////////////////////////////////////////
/////////////////////////////////////
proc string ConvertPolyFacesIntoNurbSurface(){
	string $PolyFaceslist[] = `ls -sl`;
	string $NewPolyFaces[] = ` polyChipOff -ch 1 -kft  1 -dup 0 -off 0 $PolyFaceslist`;
	print $NewPolyFaces;
	string $HistoryConnections[] = ` listHistory - future true -pruneDagObjects false  $NewPolyFaces`;
	string $polySep[] = `polySeparate -rs 1 -ch 0  $HistoryConnections[1]`;
	select -r $polySep[1];
	string $PolygonNew[0] = {$polySep[1]};
	parent -w $PolygonNew;
	select -r $PolygonNew;
	print $PolygonNew ;
	string $PolyFaces = ( $PolygonNew[0] +".f[*]");
	string $AllPolyFaces[] = `ls -fl $PolyFaces`;
	string $AllPolyFaces2[] = `ls $PolyFaces`;
	string $diffEdgeVertz[] = GetEdgeVertex ($PolygonNew);
	string $ReturnObjects = "";
	float $valuesP[];
	string $spaceLocatorB[];
	for ($eachP in $diffEdgeVertz){
		$valuesP = `pointPosition -w ($eachP)`;	
		int $xxIndeX = `size($spaceLocatorB)`;
		eval("string $spaceLocatorB["+$xxIndeX+"] =  `spaceLocator -p 0 0 0  -n LocatorCX`"); 
		move -ws $valuesP[0] $valuesP[1] $valuesP[2]  $spaceLocatorB;
		$ReturnObjects += $spaceLocatorB[0]+" ";
	}
	string $DiffPolyBorderEdges[] =  GetdiffEdgesOfBorder($PolygonNew);
	select -r $DiffPolyBorderEdges;
	string $SelectedPolyBorderEdges[] =  PolyBorderEdges($PolygonNew);
	select -r $SelectedPolyBorderEdges;
	int $sizeBorderEdges = size ($SelectedPolyBorderEdges) -1;
	string $EdgeVertzStart[0] = {$diffEdgeVertz[0]};
	select -r $EdgeVertzStart;
	stringArrayRemoveAtIndex(0, $diffEdgeVertz);
	select -r $diffEdgeVertz;
	string $NearEdges[] = GetNearEdges($EdgeVertzStart);
	$NearEdges = `ls -fl $NearEdges`;
	select -r $NearEdges;
	string $NearEdgesOne[0] = {$NearEdges[0]};
	string $NearEdgesSecond[0] = {$NearEdges[1]};
	select -r $DiffPolyBorderEdges;
	appendStringArray($DiffPolyBorderEdges,  $NearEdgesSecond, 1);
	select -r $DiffPolyBorderEdges;
	string $diffA[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdges);
	select -r $DiffPolyBorderEdges;
	string $orderedArray[0] = {$NearEdgesOne[0]};
	//clear $orderedArray;
	int $Xi = 3;
	while ($Xi < $sizeBorderEdges){
		$Xi++;
		string $NearEdgesA[] = GetNearEdges ($NearEdgesOne);
		$NearEdgesA = `ls -fl $NearEdgesA`;
		select -r $NearEdgesA;
		appendStringArray($DiffPolyBorderEdges,  $NearEdgesOne, 1);
		string $diffB[] = stringArrayRemoveExact ($DiffPolyBorderEdges,$NearEdgesA);
		select -r $diffB;
		string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("-toVertex",$diffB[0]));
		$EdgesVertex = `ls -fl $EdgesVertex`;
		int $ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
		appendStringArray($orderedArray, $diffB, 1);
		$NearEdgesOne = $diffB;
	}
	print $NearEdgesSecond;
	appendStringArray($orderedArray,  $NearEdgesSecond, 1);
	print $orderedArray;
	select -r $orderedArray;
	$EdgeLists = "";
	int $iix = 0;
	int $iiV = 0;
	for ($each in $orderedArray){
		string $oneItem[0] = {$each};
		string $EdgesVertex[] = ls(" -fl",polyListComponentConversion("-toVertex",  $oneItem[0]));
		playButtonStepForward;
		select -r $EdgesVertex;
		playButtonStepForward;
		if ( $iix > 0){
			$ifTrue = FindifArraysContain($EdgesVertex,  $diffEdgeVertz);
			if ( $ifTrue == 1){ $iiV++; if ( $iiV == 1){
					$EdgeLists += " "+$oneItem[0]+" "+"VERT";} if (  $iiV == 2){ $EdgeLists += " "+$oneItem[0]; $iiV =  0; } }
			if ( $ifTrue == 0){ $EdgeLists += " "+$oneItem [0]; }
		}
		if ( $iix == 0){  $EdgeLists += $oneItem[0]; }
		$iix++;
	}
	string $bufferList[];
	$numTokens = `tokenize $EdgeLists "VERT"  $bufferList`;
	string $EdgeCurves[];
	clear $EdgeCurves;
	string $EdgesVertexEach[];
	string $ListA[];
	for($eachBuffer in $bufferList){
		string $ListA[] = `stringToStringArray  $eachBuffer " "`;
		//string $EdgesVertexEach[] = ls(" -fl",polyListComponentConversion("-toVertex",  $ListA));
		string $EdgesVertexEachOrder[] =  VertLoopEdgeLoop($ListA);
		$curve = "curve -d 1";	
		float $values[];
		for($eachVert in $EdgesVertexEachOrder){  playButtonStepForward; 
			select -r $eachVert; playButtonStepForward;
			$values = `pointPosition -w ($eachVert)`;		
			$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
		}
		string $Newcurvez = `eval($curve)`;
		string $NewcurveX[];
		$NewcurveX = {$Newcurvez};
		appendStringArray($EdgeCurves, $NewcurveX, 1);
	}
	string $NurbSurfaceFromPolyFaces[0] =  {`alternativeBoundry`};
	delete -ch $NurbSurfaceFromPolyFaces;
	delete -ch $EdgeCurves;
	delete $PolygonNew;
	$ReturnObjects += $NurbSurfaceFromPolyFaces[0];
	select -r $EdgeCurves;
	print $ReturnObjects;
	return $ReturnObjects;
}
///////////////////////////////////////////////// ////////////////////////////////////////
///////////////////////////////////////////////// ////////////////////////////////////////Procs  Needed For Above Global Proc
//string $edgeArray[] =`ls -sl -fl`;
global proc string[] GetNearEdges(string $edgeArray[]){
	string $PolyVertexFromEdges[] = ls(" -fl",polyListComponentConversion("-toVertex",$edgeArray[0]));
	string $PolyEdgesFromVertex[] = ls(" -fl",polyListComponentConversion("-toEdge",  $PolyVertexFromEdges));
	return $PolyEdgesFromVertex;
} 
global proc string[] VertLoopEdgeLoop(string  $edgeZ[]){
	string	$verts[];
	string $v0[]=`polyListComponentConversion  -tv $edgeZ[0]`;
	$v0=`ls -fl $v0`;
	string $v1[]=`polyListComponentConversion  -tv $edgeZ[1]`;
	$v1=`ls -fl $v1`;
	$v0=`stringArrayRemove $v1 $v0`;
	$verts[0]=$v0[0];
	
	for($i=0;$i<size($edgeZ);$i++)
	{
		string 	$v0[] =`polyListComponentConversion -tv $edgeZ[$i]`;
		
		$v0=`ls -fl $v0`;
		$v0=`stringArrayRemove $verts $v0`;
		$verts[size ($verts)]=$v0[0];
	}
	
	return	$verts;
}
global proc int IfIntersect(string $ArrayA[],  string $ArrayB[]){
	string $myIntersector = `stringArrayIntersector`;
	stringArrayIntersector -edit -intersect $ArrayA  $myIntersector;
	stringArrayIntersector -edit -intersect $ArrayB  $myIntersector;
	string $findIntersection[] =  `stringArrayIntersector -query $myIntersector`;
	stringArrayIntersector -edit -reset  $myIntersector;
	int $sizeofItems = size($findIntersection);
	return $sizeofItems;
}
proc int IfIntersect(string $ArrayA[],  string $ArrayB[]){
	string $myIntersector = `stringArrayIntersector`;
	stringArrayIntersector -edit -intersect $ArrayA  $myIntersector;
	stringArrayIntersector -edit -intersect $ArrayB  $myIntersector;
	string $findIntersection[] =  `stringArrayIntersector -query $myIntersector`;
	stringArrayIntersector -edit -reset  $myIntersector;
	int $sizeofItems = size($findIntersection);
	return $sizeofItems;
}
proc BeVelFaceB(){
	string $AllPolyFaceZA[] = `ls -sl -fl`;
	string $AllPolyFaceZ[] = `ls -fl $AllPolyFaceZA`;
	string $PolyEdgesFromFaceZB[] =  ls( polyListComponentConversion("-border", "-toEdge",$AllPolyFaceZ));
	string $Edges = stringArrayToString($PolyEdgesFromFaceZB, " ");
	string $commandPoly = ("polyBevel -offset 0.45 -offsetAsFraction 1 -autoFit 1 -segments 1 -worldSpace 1 -uvAssignment 1 -fillNgons 1 -mergeVertices 1 -mergeVertexTolerance 0.0001 -smoothingAngle 30 -miteringAngle 180 -angleTolerance 180 -ch 1 "+$Edges );
	eval $commandPoly;
}
//BeVelFaceB;
//BeVelTrunkA;
proc BeVelTrunkA(){
	string $AllPolyFaceZA[] = `ls -sl`;
	string $Edges = stringArrayToString($AllPolyFaceZA, " ");
	string $commandPoly = ("polyBevel -offset 0.7438 -offsetAsFraction 1 -autoFit 0 -roundness 0.1694 -segments 3 -worldSpace 1 -uvAssignment 1 -fillNgons 1 -mergeVertices 1 -mergeVertexTolerance 0.0001 -smoothingAngle 30 -miteringAngle 180 -angleTolerance 180 -ch 1 "+$Edges );
	eval $commandPoly;
}
global proc string[] PolyBorderEdges(string  $polyZ[]){
	string $PolyFaceZ = ( $polyZ[0] +".f[*]");
	string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
	string $PolyEdgesFromFaceZ[] =  ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
	select -r $PolyEdgesFromFaceZ;
	polyConvertToShellBorder;
	string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
	return $SelectedPolyBorderEdgeZ;
}
global proc string[] GetdiffEdgesOfBorder(string  $poly[]){
	string $PolyFaceZ = ( $poly[0] +".f[*]");
	string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
	string $PolyEdgesFromFaceZ[] =  ls("-fl",polyListComponentConversion("-toEdge",$AllPolyFaceZ));
	$PolyEdgesFromFaceZ = `ls -fl $PolyEdgesFromFaceZ`;
	select -r $PolyEdgesFromFaceZ;
	polyConvertToShellBorder;
	string $SelectedPolyBorderEdgeZ[] = `ls -sl -fl`;
	string $diffEdgeZ[] = stringArrayRemoveExact ($SelectedPolyBorderEdgeZ, $PolyEdgesFromFaceZ);
	select -r $diffEdgeZ;
	return $diffEdgeZ;
}
global proc string[] GetEdgeVertex(string $poly[]){
	string $PolyFaceZ = ( $poly[0] +".f[*]");
	string $AllPolyFaceZ[] = `ls -fl $PolyFaceZ`;
	select -r $AllPolyFaceZ;
	polyConvertToShellBorder;
	ConvertSelectionToContainedEdges;
	ConvertSelectionToContainedFaces;
	string $EdgePolyFaceZ[] = `ls -sl -fl`;
	string $PolyEdgelistA[] = ls("-fl",polyListComponentConversion("-border", "-toVertex", "-fromFace", $EdgePolyFaceZ));
	select -r $PolyEdgelistA;
	string $PolyEdgelistB[] = ls("-fl",polyListComponentConversion( "-toVertex", "-fromFace", $EdgePolyFaceZ));
	$PolyEdgelistA = `ls -fl $PolyEdgelistA`;
	$PolyEdgelistB = `ls -fl $PolyEdgelistB`;
	string $diffEdgeZ[] = stringArrayRemoveExact ($PolyEdgelistA, $PolyEdgelistB);
	select -r $diffEdgeZ;
	return $diffEdgeZ; 
}

global proc polySelectEdgesPattern(string  $method)
{
	string $edges[] = `getEdges`;
	int $size = `size $edges`;
	if ($size > 1)
	{
		string $buffer[];
		tokenize $edges[0] "[]" $buffer;
		string $cmd = "polySelect -";
		$cmd += $method;
		$cmd += " ";
		$cmd += $buffer[1];
		tokenize $edges[1] "[]" $buffer;
		$cmd += " ";
		$cmd += $buffer[1];
		eval($cmd);
	}
}
global proc string[] SortEvenArrays(string  $ArrayItems[]){
	string $newItemsList[];
	int $getsize = size($ArrayItems);
	int $i = 0;	
	$iX = 0;
	while($i < $getsize){
		$iX++;
		if ( $iX == 2){
			string $oneitem[0] = {$ArrayItems[$i]};
			appendStringArray($newItemsList, $oneitem, 1);
			$iX = 0;
		}
		$i++;
	}
	return $newItemsList;
}
global proc string[] ArrayFromAllinString(string  $list){
	string $singleStringItemB[];
	string $singleStringItemA[];
	int $i = 0;
	int $Indexi = 0;
	int $triggerends = 0;
	string $listA = $list; 
	int $BytNumi;
	$BytNumi = `sizeBytes $listA`;
	while ( $triggerends < 1 ) { 
		$i++;
		$singleStringItemA = {`substring $listA $i $i`};
		if (size($singleStringItemA[0]) == 0){
			$triggerends = 2; } else {
			appendStringArray($singleStringItemB,  $singleStringItemA, 1);
		}
		$Indexi++;
		if ($Indexi == $BytNumi){ $triggerends = 2; print "end";}}
	return $singleStringItemB;
}
proc string [] RemoveFirsTLast(string $All[]){
	string $Alli[] = $All;
	int $S = `size($All)`-2;
	stringArrayRemoveAtIndex(0, $Alli);
	stringArrayRemoveAtIndex($S, $Alli);
	print  $Alli;
	return $Alli;
}
global proc int[] ArrayToIntList(string  $singleStringItemB[]){
	int $Numberlist[];
	int $triggerendsB = 0;
	int $newlistSize = size($singleStringItemB);
	int $ci = 0;
	while ( $triggerendsB < $newlistSize ) { 
		$Numberlist[$ci] = $singleStringItemB[$ci];
		$ci++;
		$triggerendsB = $triggerendsB + 1;
	}
	print $Numberlist;
	return $Numberlist;
}
global proc string[] CycleNumberString(string  $singleStringItemC[]){
	int $SizeOfArray;
	$SizeOfArray = size($singleStringItemC) -1;
	string $last[0] = {$singleStringItemC [$SizeOfArray]};
	string $first[0] = {$singleStringItemC[0]};
	stringArrayRemoveAtIndex(0,  $singleStringItemC);
	appendStringArray($singleStringItemC, $first,  1);
	return $singleStringItemC; 
}
proc string[] SortPatternArrays(string  $ArrayItems[], int $NumberlistA[]){
	int $getsizeNlist = size($NumberlistA);
	int $iN = 0;	
	string $newItemsList[];
	int $getsize = size($ArrayItems);
	int $i = 0;	
	$iX = 0;
	while($i < $getsize){
		$iX++;
		if ( $NumberlistA[$iN] == 0){
			string $oneitem[0] = {$ArrayItems[$i]};
			appendStringArray($newItemsList, $oneitem, 1);
			if ( $iN == $getsizeNlist){ $iN = -1;}
			$iX = 0;
		}
		$iN++;
		$i++;
	}
	return $newItemsList;
}
proc string[] ReverseStringArray(string $array[]){
	string	$arrayOut[];	
	for($i=0;$i<size($array);$i++){
		$arrayOut[$i]=$array[(size($array)-1-$i)];}		
	return $arrayOut;
}
proc float[] ReverseFloatArray(float $array[]){
	float	$arrayOut[];	
	for($i=0;$i<size($array);$i++){
		$arrayOut[$i]=$array[(size($array)-1-$i)];}		
	return $arrayOut;
}
proc string[] SortEvenArraysInt(string $ArrayItems [], int $Num){
	string $newItemsList[];
	int $getsize = size($ArrayItems);
	int $i = 0;	
	$iX = 0;
	while($i < $getsize){
		$iX++;
		if ( $Num == 2){
			if ( $iX == 2){
				string $oneitem[0] = {$ArrayItems[$i]};
				appendStringArray($newItemsList, $oneitem, 1);
				$iX = 0;
			}
		}
		if ( $Num == 1){
			if ( $iX == 1){
				string $oneitem[0] = {$ArrayItems[$i]};
				appendStringArray($newItemsList, $oneitem, 1);
			}
			if ( $iX == 2){ $iX = 0;}
		}
		$i++;
	}
	return $newItemsList;
}
proc string[] CompareCurveIntersect (string  $objectLoc[]){
	string $objectLocZ[];
	string $CurveintersectZ;
	string $ItemLists[];
	$objectLocZ = $objectLoc;
	int $X = size($objectLocZ) -1;
	int $Z = size($objectLocZ);
	int $i = 1;
	int $n = -1;
	int $n2 = 0;
	for( $i = 0; $i < $X; $i ++ ) {
		$n = $n + 1;
		$Z = $Z - 1;
		$ix = 0;
		$n2 = $n + 1;
		while ($Z > $ix++){	
			$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
			if (size($CurveintersectZ) > 0) {	
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
			} else { print "no Intersect"; }
			$n2++;
		}
	}
	return $ItemLists;
}
////////////
proc string[] CompareCurveIntersectTwoCurves (string $objectLocA[], string $objectAll[]){
	string $CurveintersectZA;
	string $CurveintersectZB;
	string $ItemLists[];
	int $Z = size($objectLocA) -1;
	int $X = size( $objectAll) -1;
	int $ix = 0;
	int $n2 = 0;
	while ($X > $ix++){	
		$CurveintersectZA = `curveIntersect -ch 0 - tolerance 0.001 $objectLocA[0] $objectAll[$n2]`;
		if (size($CurveintersectZA) > 0) {	
			$CurveintersectZB = `curveIntersect -ch 0 - tolerance 0.001 $objectLocA[1] $objectAll[$n2]`;
			if (size($CurveintersectZB) > 0) {	
				ArrayInsertAtEnd( $ItemLists, $objectAll[$n2]);
			}
		} else { print "no Intersect"; }
		$n2++;
	}
	return $ItemLists;
}
proc string[] CompareCurveIntersect4 (string  $objectLoc[]){
	string $objectLocZ[];
	string $CurveintersectZ;
	string $ItemLists[];
	$objectLocZ = $objectLoc;
	int $X = size($objectLocZ) -1;
	int $Z = size($objectLocZ);
	int $i = 1;
	int $n = -1;
	int $n2 = 0;
	for( $i = 0; $i < $X; $i ++ ) {
		$n = $n + 1;
		$Z = $Z - 1;
		$ix = 0;
		$n2 = $n + 1;
		while ($Z > $ix++){	
			$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
			if (size($CurveintersectZ) > 0) {	
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
			} else { print "no Intersect"; }
			$n2++;
		}
	}
	string $shorterList[] =  stringArrayRemoveDuplicates($ItemLists);
	$ItemLists = $shorterList;
	return $ItemLists;
}
proc string[] CompareCurveIntersect2 (string  $object[], string $objectlist[]){
	int $X = size($objectlist);
	string $ItemListsA[];
	$ix = 0;
	$iz = 1;
	while ($X > $ix++){	
		string $CurveintersectZ = `curveIntersect -ch 0  -tolerance 0.001 $object[0] $objectlist[$ix]`;
		if (size($CurveintersectZ) > 0) {	
			ArrayInsertAtEnd( $ItemListsA, $objectlist[$ix]);
		} 
	}
	return $ItemListsA;
}
proc string[] CompareCurveIntersect5 (string  $objectLoc[], string $objectLocB[]){
	string $objectLocZ[];
	string $CurveintersectZ;
	string $ItemLists[];
	$objectLocZ = $objectLoc;
	int $X = size($objectLocZ) ;
	int $Z = size($objectLocB);
	int $i = 1;
	int $n = -1;
	int $n2 = 0;
	for( $i = 0; $i < $X; $i ++ ) {
		$n = $n + 1;
		$Z = $Z - 1;
		$ix = 0;
		$n2 = $n + 1;
		while ($Z > $ix++){	
			$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocB[$n2] `;
			if (size($CurveintersectZ) > 0) {	
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
			} else { print "no Intersect"; }
			$n2++;
		}
	}
	string $shorterList[] =  stringArrayRemoveDuplicates($ItemLists);
	$ItemLists = $shorterList;
	return $ItemLists;
}
////////////////////////
proc setTranslationObj(string $objectitem1, float  $translate[] ){
	setAttr ($objectitem1 +".translate") $translate[0] $translate[1] $translate[2];
}
proc float [] roundFloatsInt(float $floatNumbZ[]){
	float $floatNumbZi[]= MakeCleanFloatsZ($floatNumbZ);
	float $floatNumbZii[];
	for ($eachF in $floatNumbZi){
		float $One = roundInt($eachF,1.0);
		$floatNumbZii[`size($floatNumbZii)`]= $One;
	}
	return $floatNumbZii;
}
proc float roundInt(float $val,float $dec){
	if($dec==1){
		$val = $val/10;}
	$sign = `sign $val`;
	float $decB = `pow 10 $dec`;
	$val = (int) (($val + $sign*5/($decB*10)) * $decB);
	float $valB = ($val / $dec);
	if($dec==1){
		$valB = $valB *1;}
	return $valB ;
}

//////////////////////////////////////////////
proc setRotationAxis(string $objectitem1[]){
	//
	string $objectitem1[] = `ls -sl`;
	select -cl  ;
	string $groupRotAX;
	$groupRotAX = `group -w -em -n RotAxiz`; xform - os -piv 0 0 0 $groupRotAX;
	string $itemA = $objectitem1[0];
	string $itemB = $objectitem1[1];
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB;
	float $rotationsA[] = `getAttr  ($itemA+".rotate")`;
	setAttr ($groupRotAX+".rotate") $rotationsA[0]  $rotationsA[1] $rotationsA[2];
	parent -absolute $itemB $groupRotAX;
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB; parent -w $itemB;
	delete $groupRotAX;
}
proc setRotationAxisString(string $objectitem1[]){
	//
	select -cl  ;
	string $groupRotAX;
	$groupRotAX = `group -w -em -n RotAxiz`; xform - os -piv 0 0 0 $groupRotAX;
	string $itemA = $objectitem1[0];
	string $itemB = $objectitem1[1];
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB;
	float $rotationsA[] = `getAttr  ($itemA+".rotate")`;
	setAttr ($groupRotAX+".rotate") $rotationsA[0]  $rotationsA[1] $rotationsA[2];
	parent -absolute $itemB $groupRotAX;
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB; parent -w $itemB;
	delete $groupRotAX;
}
proc setTranslationAxis(string $objectitem1[]){
	//
	string $objectitem1[] = `ls -sl`;
	select -cl  ;
	string $groupTranAX;
	$groupRotAX = `group -w -em -n TranAxiz`; xform - os -piv 0 0 0 $groupTranAX;
	string $itemA = $objectitem1[0];
	string $itemB = $objectitem1[1];
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB;
	float $translate[] = `getAttr  ($itemA+".translate")`;
	setAttr ($groupTranAX+".translate") $translate[0] $translate[1] $translate[2];
	parent -absolute $itemB $groupTranAX;
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB; parent -w $itemB;
	delete $groupTranAX;
}
proc string[] MakeCIRCLE(string $ObjectCurve[]) {
	string $CIRCLEX[];
	string $ObjectCurveduplicate[] = `duplicate -rr  $ObjectCurve`;
	setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
	setAttr ($ObjectCurveduplicate[0] + ".rotate") 0 0 0;
	select -cl  ;
	float $rotationz[];
	$rotationz = `xform -q -rotation $ObjectCurve`;
	float $translationz[];
	$translationz = `xform -q -translation  $ObjectCurve`;
	float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
	//print("Bounding box ranges from: " +
	//      $bbox[0] + "," + $bbox[1] + "," + $bbox [2] + ", to " +
	//      $bbox[3] + "," + $bbox[4] + "," + $bbox [5] + ".\n");
	spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
	move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
	move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
	move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
	move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
	// xform -query -worldSpace -translation;
	/////////////////////////////////////////
	float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
	float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
	float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
	float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
	$BoxPointA = `MakeCleanFloats($BoxPointA)`;
	$BoxPointB = `MakeCleanFloats($BoxPointB)`;
	$BoxPointC = `MakeCleanFloats($BoxPointC)`;
	$BoxPointD = `MakeCleanFloats($BoxPointD)`;
	float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
	float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
	float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
	float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
	//   MoveObjectSelection($BoxMPointAC);
	float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
	float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
	float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
	float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
	float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
	move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
	float $translationzMiddle[];
	$translationzMiddle = `xform -q -translation  BoxspaceLocatorMiddle`;
	float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
	float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
	$distanceAverage =  (($distanceA + $distanceB) *  (0.5)) ;
	$radiusX = ( $distanceAverage / 2);
	//if / then 
	float $squarePercentA;
	float $squarePercentB;
	if ( $distanceA > $distanceAverage) {
		$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
	}
	if ( $distanceA < $distanceAverage) {
		$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
	}
	if ( $distanceB > $distanceAverage) {
		$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
	}
	if ( $distanceB < $distanceAverage) {
		$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
	}
	/////////////////////
	int $squareA;
	$squareA = 0;
	int $squareB;
	$squareB = 0;
	print $squarePercentA ;
	if ( $squarePercentA > 55)  {
		$squareA = (0 + 1); 
	} else {
		$squareA = 0;
	}
	print $squareA;
	print $squarePercentB ;
	if ( $squarePercentB > 55)  {
		$squareB = ($squareB + 1);
	} else {
		$squareB = 0;
	}
	$addSquareResults = ($squareA + $squareB);
	circle -nr 0 1 0 -c $translationzMiddle[0]  $translationzMiddle[1] $translationzMiddle[2] -r  $radiusX;
	$CIRCLEX = `ls -sl`;
	float $rotationz[];
	$rotationz = `xform -q -rotation $ObjectCurve`;
	setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
	setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
	setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
	float $translationz[];
	$translationz = `xform -q -translation  $ObjectCurve[0]`;
	setAttr ($CIRCLEX[0] + ".translateX")  $translationz[0];
	setAttr ($CIRCLEX[0] + ".translateY")  $translationz[1];
	setAttr ($CIRCLEX[0] + ".translateZ")  $translationz[2];
	delete $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;
	string $NewNameZ = `rename $CIRCLEX "$ObjectCurve[0]"`;
	delete $ObjectCurve;
	$CIRCLEX = {$NewNameZ};
	return $CIRCLEX;
}
proc string[] CIRCLESCRIPTZ(string $ObjectCurve[]) {
	//CIRCLE SCRIPT
	string $CIRCLEX[];
	//string $newCircle[] = `CIRCLESCRIPTZ ($drawcurve)`;
	//string $ObjectCurve[] = $drawcurve;
	string $ObjectCurveduplicate[] = `duplicate -rr  $ObjectCurve`;
	setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
	setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
	select -cl  ;
	float $rotationz[];
	$rotationz = `xform -q -rotation $ObjectCurve`;
	float $translationz[];
	$translationz = `xform -q -translation  $ObjectCurve`;
	float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
	//print("Bounding box ranges from: " +
	//      $bbox[0] + "," + $bbox[1] + "," + $bbox [2] + ", to " +
	//      $bbox[3] + "," + $bbox[4] + "," + $bbox [5] + ".\n");
	spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
	move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
	move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
	move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
	move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
	// xform -query -worldSpace -translation;
	/////////////////////////////////////////
	float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
	float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
	float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
	float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
	$BoxPointA = `MakeCleanFloats($BoxPointA)`;
	$BoxPointB = `MakeCleanFloats($BoxPointB)`;
	$BoxPointC = `MakeCleanFloats($BoxPointC)`;
	$BoxPointD = `MakeCleanFloats($BoxPointD)`;
	float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
	float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
	float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
	float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
	//   MoveObjectSelection($BoxMPointAC);
	float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
	float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
	float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
	float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
	float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
	move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
	float $translationzMiddle[];
	$translationzMiddle = `xform -q -translation  BoxspaceLocatorMiddle`;
	float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
	float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
	$distanceAverage =  (($distanceA + $distanceB) *  (0.5)) ;
	$radiusX = ( $distanceAverage / 2);
	//if / then 
	float $squarePercentA;
	float $squarePercentB;
	if ( $distanceA > $distanceAverage) {
		$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
	}
	if ( $distanceA < $distanceAverage) {
		$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
	}
	if ( $distanceB > $distanceAverage) {
		$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
	}
	if ( $distanceB < $distanceAverage) {
		$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
	}
	/////////////////////
	int $squareA;
	$squareA = 0;
	int $squareB;
	$squareB = 0;
	print $squarePercentA ;
	if ( $squarePercentA > 55)  {
		$squareA = (0 + 1); 
	} else {
		$squareA = (0);
	}
	print $squareA;
	print $squarePercentB ;
	if ( $squarePercentB > 55)  {
		$squareB = ($squareB + 1);
	} else {
		$squareB = (0);
	}
	$addSquareResults = ($squareA + $squareB);
	if ( $addSquareResults == 2 ){
		circle -nr 0 1 0 -c $translationzMiddle[0]  $translationzMiddle[1] $translationzMiddle[2] -r  $radiusX;
		$CIRCLEX = `ls -sl`;
		float $rotationz[];
		$rotationz = `xform -q -rotation $ObjectCurve`;
		setAttr ($CIRCLEX[0] + ".rotateX") $rotationz[0];
		setAttr ($CIRCLEX[0] + ".rotateY") $rotationz[1];
		setAttr ($CIRCLEX[0] + ".rotateZ") $rotationz[2];
		float $translationz[];
		$translationz = `xform -q -translation  $ObjectCurve[0]`;
		setAttr ($CIRCLEX[0] + ".translateX")  $translationz[0];
		setAttr ($CIRCLEX[0] + ".translateY")  $translationz[1];
		setAttr ($CIRCLEX[0] + ".translateZ")  $translationz[2];
		//TEMP CHANGE
		//string $currPanel = `getPanel -withFocus` ,  $camera ;
		//$camera = `modelPanel -q -camera $currPanel`;
		//setAttr ($CIRCLEX[0] + ".rotate") `getAttr  ($ObjectCurve[0] + ".rotate")`;
		delete $ObjectCurve $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;
	}
	else {
		delete $ObjectCurveduplicate BoxspaceLocatorA  BoxspaceLocatorB BoxspaceLocatorC  BoxspaceLocatorD BoxspaceLocatorMiddle;
	}
	string $NewNameZ = `rename $CIRCLEX "Curve"`;
	$CIRCLEX = {$NewNameZ};
	return $CIRCLEX;
}
proc EvalSmoothCurves(){
	SmoothCurvature3(8);
	//SmoothCurvatureReverse6(18);
}
proc EvalSmoothCurvesB(){
	SmoothCurvatureB3(8);
}
proc string[] Make_Middle_of_Curve_ParamlocatorZ (string $objectCurveSelected[]){
	float $arclenghtzALL = `arclen  $objectCurveSelected`;
	float $arclenghtzDivide = $arclenghtzALL / 2.0;
	int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;			
	$CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
	string $paramlocatorZARC[];
	$paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.0 + "]");
	float $step = 10; 
	int $a = 1;
	float $t =  $a/$step;
	setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $t;
	string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
	float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
	float $divZZ = $arclenghtzDivide /  $arclenghtzparamZ ;
	float $divZZ2 = $t * $divZZ ;
	setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $divZZ2;
	////////////////////// Moved ParamLoc to middle
	float $posA[];
	float $posB[];
	float $posC[];
	$posA = `pointPosition -w $CurveSelection[0]`;
	$posB = `pointPosition -w $paramlocatorZARC[0]`;
	$posC = `pointPosition -w $CurveSelection[1]`;
	string $CircularArcFromCurve[];
	$CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
	setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
	setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
	setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
	setAttr ($CircularArcFromCurve[0] + ".d") 3;
	setAttr ($CircularArcFromCurve[0] + ".s") 8;
	string $ArcCurve[];
	$ArcCurve[0] = `createNode nurbsCurve` ; 
	connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
	//delete $objectCurveSelected; 
	string $ParentArc[];
	$ParentArc = `listRelatives -parent $ArcCurve`;
	ResetTranslation($ParentArc);
	string $MakeArcLocator[]; $MakeArcLocator =  `spaceLocator -p 0 0 0 -n ArcLocator`;
	move -ws $posB[0] $posB[1] $posB[2]  $MakeArcLocator;
	$ConnectLocToPoint2 = `connectAttr -f  ($MakeArcLocator[0] + ".translate") (  $CircularArcFromCurve[0] + ".pt2")`;
	string $ArcZ[];
	$ArcZ[0] = `rename $ParentArc  $objectCurveSelected`; 
	delete $paramlocatorZARC;
	select -r $ArcZ;
	return $ArcZ; 
}
///////////////////////////////////////////////// /////////////////////
proc string[] SmoothCurvature4(float $curveM ,  int $Steps ){
	string $curves[] = `ls -sl`;
	string $myCurve = $curves[0];
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
	smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = `size  ($CurveSelection)`;
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	int $numEPrealNum2 = ($numEPrealNum * 3 );
	if ($Steps > 8 ){ $numEPrealNum2 = $Steps; }  
	string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
	string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
	$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	int $trigger = 0;
	$curve = "";
	float $curveMin = $curveM;
	while ( $trigger < 1 ){
		float $step = $numEPrealNum2;  
		$curve = "curve -d 3";
		
		int $Par = 0;
		int $a;
		int $ii = 0;	
		int $CVpoints = 0;	
		for($a = 0; $a <= $step;$a++){
			$ii = $ii + 1;
			$t =  $a/$step;
			$Par = ($a/$step);
			setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
			float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
			float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
			if ( $CurvatureRadi <=  $curveMin){
				$CVpoints++;
				$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
			}
			if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
				$CVpoints++;
				$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
			}
			if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
				$CVpoints++;
				$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
			}
		}
		if ( $CVpoints < 8 ){ $curveMin++; }
		if ( $CVpoints >= 8 ){ $trigger = 1; }
	}
	string $Newcurvez = `eval($curve)`;
	string $Newcurve[] = {$Newcurvez};
	delete $paramlocatorpointOnCurvex $spaceLocatorB; 
	delete $curves;
	rename $Newcurve $myCurve;  
	$Newcurve = {$myCurve};
	return $Newcurve; 
}
//////////////////////////
proc string[] SmoothCurvature13(float $curveM ){
	string $curves[] = `ls -sl`;
	float $arcL1 = `arclen $curves[0]`;
	float $arcL1B = ( $arcL1 + ((-1) * ( $arcL1 / 10  )));
	string $myCurve = $curves[0];
	string $crShape[] = `listRelatives -s $curves[0] `;
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
	smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	int $numEPrealNum2 = ($numEPrealNum * 1 );  
	string $Newcurve[];
	string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
	string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
	$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	int $trigger = 0;
	$curve = "";
	int $Par = 0;
	int $b = 0;
	int $ii = 0;
	int $a = 0;
	float $curveMin = $curveM;
	float $CurvatureRadi2;
	string $Newcurvez;
	string $Newcurve[];
	while ( $trigger < 1 ){
		float $step = $numEPrealNum2;  
		$curve = "curve -d 3";
		int $CVpoints = 0;	
		for($a = 0; $a <= $step;$a++){	
			$ii = $ii + 1;
			$t =  $a/$step;
			$Par = $a/$step;
			setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
			if ( $Par > 0.0 ){ $b = $a -1; $Par2 = $b/$step;
				$CurvatureRadi2 = `pointOnCurve -top 1  -pr $Par2 -cr $crShape[0]`; }
			float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
			float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
			float $AverageCurvatureRadi = (($CurvatureRadi +  $CurvatureRadi2) / 2);
			if ( $AverageCurvatureRadi <=  $curveMin){
				$CVpoints++;
				$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
			}
			if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
				$CVpoints++;
				$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
			}
			if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
				$CVpoints++;
				$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
			}
		}
		if ( $CVpoints < 8 ){ $curveMin++; }
		if ( $CVpoints > 2 ){
			string $Newcurvez = `eval($curve)`;
			$Newcurve = {$Newcurvez};
			float $arcL2 = `arclen $Newcurve[0]`;
			if ( $arcL2 < $arcL1B ){ delete $Newcurve;  $trigger = 0; $numEPrealNum2 = $numEPrealNum2 +  3;   }
			if (( $CVpoints >= 8 )&& ( $arcL2 > $arcL1B )){  $trigger = 1; }
		}
	}
	delete $paramlocatorpointOnCurvex $spaceLocatorB; 
	delete $curves;
	rename $Newcurve $myCurve;  
	$Newcurve = {$myCurve};
	return $Newcurve; 
}
/*
string $retopoProjectionCurves[] =  `StartofCurveScriptRetopo2($CaptureCurveNameA)`; 
string $AllIntersectCurveSA[] =  StartofCurveScriptRetopo3( $PolygonShapeZA,  $retopoProjectionCurves, $CaptureCurveNameA );
EvalSmoothCurves;
select -r $AllIntersectCurveSA;
FlattenCurveOnMesh( $AllIntersectCurveSA,  $PolygonShapeZA);
*/
///////////////////////////////////////////////// /
// SmoothCurvature3(3);
///////////////////////////////////////////////// /
proc string[] SmoothCurvature3(float $curveM ){
	string $curves[] = `ls -sl`;
	string $myCurve = $curves[0];
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
	smoothCurve -ch 0 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	int $numEPrealNum2 = ($numEPrealNum * 4 ); 
	//Above was Times * 4 
	string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
	string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
	$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = 8;
	int $Par = 0;
	int $a;
	int $ii = 0;	
	for($a = 0; $a <= $step;$a++){
		$ii = $ii + 1;
		$t =  $a/$step;
		$Par = ($a/$step);
		setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
		float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
		float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi <=  $curveMin){   
			$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
		}
		if (( $CurvatureRadi > $curveMin) && ( $ii == 1  )){
			$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		}
		if (( $CurvatureRadi > $curveMin) && ( $Par ==  1.0 )){
			$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		}
	}
	///////////////////////////////////////////////// ////
	string $Newcurvez = `eval($curve)`;
	print "look Here";
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $Newcurvez;
	float $numLength = (`arclen $Newcurvez`) +1; 
	int $StepZNum = $numLength;
	delete $paramlocatorpointOnCurvex $spaceLocatorB; 
	delete $curves;
	///////////////////////////////////////////////// //////
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s $StepZNum -d 3 -tol 0.001  $Newcurvez;
	string $Newcurve[] = {$Newcurvez};
	rename $Newcurve $curves;  
	$Newcurve = {$curves[0]};
	return $Newcurve; 
}
/////////////////////////
//  SmoothCurvatureB3(6);
///////////////////////
//////////////////////////////////
////////////////////////////////////
proc string[] SmoothCurvatureReverse6(float  $curveM ){
	string $curves[] = `ls -sl`;
	string $myCurve = $curves[0];
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 0 -kr 0 -kcp  1 -kep 1 -kt 0 -s 28 -d 3 -tol 0.001 $myCurve;
	smoothCurve -ch 1 -rpo 1 -s 5.60 ($myCurve +".cv [*]");
	string $CurveSelection[] = `ls -fl  ($myCurve+".ep[0:*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	int $numEPrealNum = ( $numEPs -1 );
	int $numEPrealNum2 = ($numEPrealNum * 2 ); 
	//Above was Times * 4 
	string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
	string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
	$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 3";
	float $curveMin = $curveM;
	int $Par = 0;
	int $a;
	int $ii = 0;	
	for($a = 0; $a <= $step;$a++){
		$ii = $ii + 1;
		$t =  $a/$step;
		$Par = ($a/$step);
		setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;
		float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
		float $CurvatureRadi = `getAttr  ($paramlocatorpointOnCurvex +  ".curvatureRadius")`;
		if ( $CurvatureRadi >=  $curveMin){
			$curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];
		}
		if (( $CurvatureRadi < $curveMin) && ( $ii == 1  )){
			$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		}
		if (( $CurvatureRadi < $curveMin) && ( $Par ==  1.0 )){
			$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		}
	}
	string $Newcurvez = `eval($curve)`;
	string $Newcurve[] = {$Newcurvez};
	delete $paramlocatorpointOnCurvex $spaceLocatorB; 
	delete $curves;
	rename $Newcurve $curves;  
	$Newcurve = {$curves[0]};
	return $Newcurve; 
}
proc float XpercentLess_thenY(float $Ix, float  $Iy){
	float $N;
	float $Ni;
	if ( $Ix > $Iy){
		$Ni = $Ix; $N = $Iy; } else { $N = $Ix;  $Ni =  $Iy; }
	float $PercentA;
	float $PercentB;
	$PercentA = ((float($N) / $Ni) * (100) );
	$PercentB = 100 - $PercentA;
	return $PercentB;
}
//////////////////////////////////////
////////////////////////////////////
////////////////////////////////////////
proc EvalStrait_ARC_or_FreeForm(){
	string $curveItem[] = `ls -sl`;
	Strait_ARC_or_FreeForm($curveItem, 5.5, 2.5 );
}
//////////////////////////////////////////
proc int Strait_ARC_or_FreeFormFind(string  $renamed[], float $ArcN, float $StraitN ){
	int $SAF = 0;
	string $nameString = $renamed[0];
	string $ParentArc[];
	//rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 - kcp 0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001 $renamed;
	string $objectB[] =  Make_Middle_of_Curve_ParamlocatorZ($renamed);
	ResetTranslation($objectB);
	string $objectC[] = {$renamed[0], $objectB[0]};
	ResetTranslationEach($objectC);
	float $objectAcurve = GET_AREA_OF_CURVE  ($renamed);
	float $objectBcurve = GET_AREA_OF_CURVE  ($objectB);
	/////////////////////////
	float $PercentDiff = XpercentLess_thenY ($objectBcurve, $objectAcurve);
	float $objectAcurveL = arclen ($renamed);
	float $objectBcurveL = arclen ($objectB);
	float $PercentDiffL = XpercentLess_thenY ($objectBcurveL, $objectAcurveL);
	float $PercentAverage = ($PercentDiff +  $PercentDiffL) /2;
	vector $VectorCurveEndZ[] = VecCurveEnds ($renamed);
	float $posA[] =  $VectorCurveEndZ[0];
	float $posB[] =  $VectorCurveEndZ[1];
	string $CurveBetween[] = MakeCurveBetweenFloats ($posA, $posB);
	ResetTranslation($CurveBetween);
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 8 -d 3 -tol 0.001  $CurveBetween;
	float $objectCcurveL = arclen ($CurveBetween);
	float $PercentDiffS = XpercentLess_thenY ($objectCcurveL, $objectAcurveL);
	print ("PercentDiff_Curve_to_Arc AREA  "+$PercentDiff + "\n");
	print ("PercentDiff_Curve_to_Arc L  "+$PercentDiffL + "\n");
	print (" " + "\n");
	print ("PercentDiff_Curve_to_Arc Average  "+$PercentAverage + "\n");
	print (" " + "\n");
	print ("PercentDiff_Curve_to_STRAIT  "+$PercentDiffS + "\n");
	string $DeleteCurveA[];
	string $DeleteCurveB[];

	if (($PercentAverage< $ArcN) && ($PercentDiffS >  $StraitN)){
		print ("ARC Curve"+ "\n"); $SAF = 0;
	}else if ($PercentDiffS < $StraitN){
		print ("STRAIT Curve"+ "\n"); $SAF = 1;
	} else { 
		print ("FREEFORM Curve"+ "\n"); $SAF = 2;
	}
	delete $CurveBetween  $objectB;
	return $SAF; 
}
proc int AddorSubtract(int $Number, int $AorS){
	if ($AorS == 1){ $Number++; return $Number;} 
	if ($AorS == 0){ $Number--; return $Number;}
	if ($AorS == 2){ $Number = 0; return $Number;}  
}
///////////////////////////////////////////////// /
proc float RoundFloat(float $val,float $dec){
	$sign = `sign $val`;
	float $dec = `pow 10 $dec`;
	$val = (int) (($val + $sign*5/($dec*10))  * $dec);
	$val = ($val / $dec);
	return $val;
}
//////////////////////////////////////
proc ResetTrans(){
	string $oneItemz[] = `ls -sl`;
	xform -cp $oneItemz[0];
	vector $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
	move -rpr 0 0 0  $oneItemz[0];
	makeIdentity -apply true  -t 1 -r 0 -s 0 $oneItemz[0];
	xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $oneItemz[0];
}
proc int IsCircle() {
	//StraitCurves SCRIPT
	int $IsCircle = 0;
	string $ObjectCurve[];
	string $StraitCurve[];
	$ObjectCurve = `ls -selection`;
	xform -cp;
	ResetTrans;
	duplicatePreset (1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);
	string $ObjectCurveduplicate[];
	$ObjectCurveduplicate = `ls -selection`;
	setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
	setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
	playButtonStepForward; select -cl  ;
	float $rotationz[];
	$rotationz = `xform -q -rotation $ObjectCurve`;
	float $translationz[];
	$translationz = `xform -q -translation  $ObjectCurve`;
	float $ArcLength = `arclen $ObjectCurve[0]`;
	float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
	print("Bounding box ranges from: " +
	$bbox[0] + "," + $bbox[1] + "," + $bbox[2]  + ", to " +
	$bbox[3] + "," + $bbox[4] + "," + $bbox[5]  + ".\n");
	spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
	move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
	move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
	move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
	move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
	// xform -query -worldSpace -translation;
	float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
	float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
	float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
	float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
	$BoxPointA = `MakeCleanFloats($BoxPointA)`;
	$BoxPointB = `MakeCleanFloats($BoxPointB)`;
	$BoxPointC = `MakeCleanFloats($BoxPointC)`;
	$BoxPointD = `MakeCleanFloats($BoxPointD)`;
	float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
	float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
	float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
	float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
	//   MoveObjectSelection($BoxMPointAC);
	///////////////////////////////
	///////////////////////////////
	float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
	// BoxspaceLocatorMiddle CHANGES need here in the  future
	float $translationzMiddle[];
	$translationzMiddle = $CrossMPointAB;
	float $CurveCVzero[] = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
	float $CurveCVLast[] = GetCurveCVposENDS ($ObjectCurveduplicate, 1);
	float $distanceBetween = PointsGetDistanceFLOAT ($CurveCVzero, $CurveCVLast);
	int $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA); 
	int $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
	int $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC); 
	int $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC); 
	int $AorC = 0;
	if (($pA1 == 3) || ($pA2 == 3)){
		$AorC = 1;
	}
	if (($pC1 == 3) || ($pC2 == 3)){
		$AorC = 2;
	}  
	float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
	float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
	float $distanceC = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointD);
	float $distanceAverage =  (($distanceA +  $distanceB) * (0.5)) ;
	float $radiusX = ( $distanceAverage / 2.0);
	float $distanceAverageA = $distanceC ;
	float $radiusXA = (($distanceC) * (0.5)) ;
	// Result: 38.390151 // 
	float $Pi = 3.141593;
	float $circleArc = (($Pi) * ($distanceC));
	float $percentLess = XpercentLess_thenY(  $circleArc, $ArcLength);
	float $squarePercentA;
	float $squarePercentB;
	if ( $distanceA > $distanceAverage) {
		$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
	}
	if ( $distanceA < $distanceAverage) {
		$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
	}
	if ( $distanceB > $distanceAverage) {
		$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
	}
	if ( $distanceB < $distanceAverage) {
		$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
	}
	/////////////////////
	int $squareA = 0;
	int $squareB = 0;
	if ( $squarePercentA > 55){
		$squareA = 1; 
	}
	if ( $squarePercentB > 55){
		$squareB =  1; 
	}
	string $StraitCurve[];
	$addSquareResults = ($squareA + $squareB);
	if (( $addSquareResults == 2 ) && ( $percentLess  < 12.0 )) {
		$IsCircle = 1;
	} else { 
		// Not Diagonal curves
		$IsCircle = 0;
	}
	/*
setAttr ($StraitCurve[0] + ".rotateX")  $rotationz[0];
setAttr ($StraitCurve[0] + ".rotateY")  $rotationz[1];
setAttr ($StraitCurve[0] + ".rotateZ")  $rotationz[2];
setAttr ($StraitCurve[0] + ".translateX")  $translationz[0];
setAttr ($StraitCurve[0] + ".translateY")  $translationz[1];
setAttr ($StraitCurve[0] + ".translateZ")  $translationz[2];
*/
	select -r $ObjectCurveduplicate BoxspaceLocatorA  BoxspaceLocatorB BoxspaceLocatorC  BoxspaceLocatorD BoxspaceLocatorMiddle;
	delete;
	print ("IsCircle " + $IsCircle);
	print ("percentLess " + $percentLess);
	print ("addSquareResults " + $addSquareResults);
	return $IsCircle;
}
////////////////////////////////
proc string CurveIntersectZX(string $objectcurv[]){
	string $plainName;
	
	string $digitalSkeleton[];
	$numInts = size($digitalSkeleton);
	if ( $numInts > 0 ){
		clear $digitalSkeleton;
	}
	///////////////GATHER ALL BUILDING  STRUCTURE/////////##
	///////////////////////////////////////////////// ////##
	string $CurveSelection[]; 
	int $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($objectcurv[0] + ".cv[0]")  ;			
	$CurveSelection[1] = ($objectcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposA[];
	float $EACHCVposB[];	
	string $AllIntersectCurveZ[];
	$numInts = size($AllIntersectCurveZ);
	if ( $numInts > 0 ){
		clear $AllIntersectCurveZ;
	}
	string $IntersectCurves[];
	string $MakeExtrudeSurface[];
	string $MakeBirailSurface[];
	string $MakeXBetween[];
	string $MakeIntersectCurvez[];
	string $MakespaceLocator[];
	float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $CurveSelection[0]  )`;
	$MakespaceLocator = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
	$MakeIntersectCurvez[0] = `curve -d 1 -p 0 0 0 -p  12 0 0 -k 0 -k 1 -n IntersectCurve` ;
	appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
	appendStringArray($digitalSkeleton,  $MakespaceLocator, 1);
	$numInts = size($AllIntersectCurveZ);
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
	move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
	aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM      $MakeIntersectCurvez[0];
	$EACHCVposA = $eachCVpos;
	string $surfX = "Xplane";
	float $intersectPoint[] = GetSurfaceIntersectPoint($MakeIntersectCurvez[0], $surfX);
	$duplicateCamPlain1 = `duplicate -rr LiveSurfaceB`;
	$plainName = $duplicateCamPlain1[0];
	xform -cp $duplicateCamPlain1;
	ResetTranslation($duplicateCamPlain1);
	Move $intersectPoint $duplicateCamPlain1[0];
	extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo 1 -es 2 -ed 2   $duplicateCamPlain1;
	///
	delete $digitalSkeleton;
	return $plainName; 
}
////////////////////////////////
////////////////////////////////
proc float[] GetSurfaceIntersectPoint(string $Curvez, string $surf){
	string $objectCurve = $Curvez;
	string $MakeExtrudeSurface[];
	$MakeExtrudeSurface = `extrude -ch true -rn false -po 0 -et 0 -upn 1 -length 3.000 -rotation 0 -scale 1 -dl 3 -n CURVEZextrude $Curvez` ;
	string $iSurf = $MakeExtrudeSurface[0];
	string $surf = "Xplane";
	string $paramlocatorZ[];
	string $intersectZ[];
	float $intersectposA[];
	if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf $surf `)){
		print "error";
	} else {
		///////////////GATHER ALL BUILDING  STRUCTURE/////////##
		///////////////
		string $curveIntersectZ[];
		$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZ $objectCurve`;
		string $buffer[];
		$numTokens = `tokenize $curveIntersectZ[0] " "  $buffer`;
		$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve + ".u[" + $buffer[1] + "]");
		
		$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
	}
	delete $intersectZ $paramlocatorZ;
	delete $MakeExtrudeSurface;
	$intersectposA = `MakeCleanFloats($intersectposA)`;
	return $intersectposA;
}
//EVALCamScripts added to end
////////////////////////////////
proc AdvancedCurveMODprojectTAN(string $INarrayA [], int $plainNum ){
	float $eachCVposSTART[];
	float $eachCVposEND[];
	string $MakespaceLocatorSTART[];
	string $MakespaceLocatorEND[];
	string $digitalSkeletonA[];
	string $NewStraitCurve[];
	$numInts = size($digitalSkeletonA);
	if ( $numInts > 0 ){
		clear $digitalSkeletonA;
	}
	$digitalSkeletonA =  `StartofCurveScriptIntersectZX`;
	//Huge re-occuring problem is here
	string $AllCurveZ[];
	$numInts = size($AllCurveZ);
	if ( $numInts > 0 ){
		clear $AllCurveZ;
	} 
	string $AllSpaceLocatorZ[];
	$numInts = size($AllSpaceLocatorZ);
	if ( $numInts > 0 ){
		clear $AllSpaceLocatorZ;
	} 
	string $renamed[];
	string $rebuildit[];
	string $ZIntersectionCurveZA[];
	string $intersectionCurve[]; 
	string $MakeSpaceLocator[];
	string $objectLocaterz[];
	string $AllparamlocatorZ[];
	clear $AllparamlocatorZ;
	string $intersectZ[];
	string $surf[];
	string$ZBetween[];
	string $objectCurve[];
	float $EACHCVposA[];
	float $EACHCVposB[];
	float $p1Z; 	
	int $moveCurve = 0;
	int $SE = 0;
	int $foundCurve = 0;
	setAttr "subCurve1.minValue" 0.85;
	setAttr "subCurve2.minValue" 0.85;
	$surf[0] = ("IntersectLoftZ");
	//This reduces number of curves it has to  recursively Search through.... But it could be  faster
	//AND it now is .....
	string $queryLocCurveEnds[] = queryLocOnLivePlaneBLayer();
	string $queryLocCurveEndsOLD[] = queryLocOnLivePlaneBLayer();
	//clear $distancesEachToCurve;
	vector $LocCurveEndsVec[] = PointArray($queryLocCurveEnds);
	float $pointCurveOnplane[] = `xform -q -ws -t $digitalSkeletonA[0]`;
	string $CurveItemAa[] ;
	$CurveItemAa[0] = $digitalSkeletonA[0];
	float $CurveDirection[] = IfstraitFindCurveOthoDirection($CurveItemAa);
	float $distancesEachToCurve[] = ArrayDistancesVecTofloat($LocCurveEndsVec, $pointCurveOnplane);
	string $EmptyStringNewOrderA[];
	float $newOrdersZ[] = SortFloatArrayAndString($distancesEachToCurve, $queryLocCurveEnds, $EmptyStringNewOrderA);
	string $newNames = stringArrayToString($EmptyStringNewOrderA, " ");
	string $newNamesResultA = substituteAllString($newNames, "PlaneLOC", "");
	string $newNamesResultB = substituteAllString($newNamesResultA, "START", "");
	string $newNamesResultC = substituteAllString($newNamesResultB, "END", "");
	string $arrayCurvesNear[];
	$arrayCurvesNear = stringToStringArray($newNamesResultC, " ");
	int $ColorzA =13;
	for($eachL in $EmptyStringNewOrderA){
		select -r $eachL; 
		SetItemColorString($eachL, $ColorzA);
		$ColorzA++; 
	}
	PAUSE;
	//for($eachC in $arrayCurvesNear){
	//select -r $eachC; PAUSE; 
	//}
	float $curveSearchRadius = GetDistanceBetweenCurveEnds({$digitalSkeletonA[3]});
	$curveSearchRadius = $curveSearchRadius/2;
	float $curveSearchRadiusA = ($curveSearchRadius/2)+$curveSearchRadius;
	int $newIndexX= 0;
	string $newCurves[];
	for ($eachDistance in $newOrdersZ){
		if($eachDistance<$curveSearchRadiusA){
			$newCurves[`size($newCurves)`]= $arrayCurvesNear[$newIndexX];
		}
		$newIndexX++;
	}
	string $shorterListC[] = stringArrayRemoveDuplicates($newCurves);
	//for($eachCs in $shorterListC){//
	//select -r $eachCs; PAUSE;
	//select -cl  ;
	//}
	if(`size($shorterListC)`==0){
		$shorterListC[0]=$arrayCurvesNear[0];
	}
	$objectSelection = $shorterListC;
	int $ColorzX =20;
	//for($eachObj in $objectSelection){
	//SetItemColorString($eachObj, $ColorzX);
	//PAUSE;
	//}
	int $EdgecurvesizeNUM = size($objectSelection);
	string $each;
	for ($each in $objectSelection) {
		string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
		if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf[0] $surf[0]`)){
			
			delete `ls -sl`;
		} else {
			///////////////GATHER ALL BUILDING  STRUCTURE/////////##
			///////////////
			$objectCurve[0] = $each;
			appendStringArray($AllCurveZ, $objectCurve, 1);
			delete $intersectZ;
			delete $iSurf;
			$foundCurve++;
			if ($foundCurve == 2){ $foundCurve = 0; break;} 
		}
	}
	setAttr "subCurve1.minValue" 0.0;
	setAttr "subCurve2.minValue" 0.0;
	setAttr "subCurve1.maxValue" 0.15;
	setAttr "subCurve2.maxValue" 0.15;
	int $EdgecurvesizeNUM = size($objectSelection);
	string $each;
	for ($each in $objectSelection) {
		string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
		if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf[0] $surf[0]`)){
			
			delete `ls -sl`;
		} else {
			///////////////GATHER ALL BUILDING  STRUCTURE/////////##
			///////////////
			$objectCurve[0] = $each;
			appendStringArray($AllCurveZ, $objectCurve, 1);
			delete $intersectZ;
			delete $iSurf;
			$foundCurve++;
			if ($foundCurve == 2){ $foundCurve = 0; break;} 
		}
	}
	setAttr "subCurve1.maxValue" 1.0;
	setAttr "subCurve2.maxValue" 1.0;
	string $shorterListA[] =  stringArrayRemoveDuplicates($AllCurveZ);
	$AllCurveZ = $shorterListA;
	///////////////////////////////////////////////// ////
	if (size($AllCurveZ) > 2){
		print "Intersected 2 Curves";
		string $ItemListsZ[];
		$ItemListsZ = `CompareCurveIntersect($AllCurveZ) `;
		string $diffCurvesSame[] =  stringArrayRemoveExact($ItemListsZ, $AllCurveZ);
		if (size($diffCurvesSame) == 1){
			ResetTranslationEach($ItemListsZ);
			ArrayInsertAtEnd( $ItemListsZ, $diffCurvesSame [0]);
			string $NearestCurvesSame[] =  NearestObjectArray(1, $ItemListsZ);
			string $TwoCurvesBest[];
			ArrayInsertAtEnd( $TwoCurvesBest,  $diffCurvesSame[0]);
			ArrayInsertAtEnd( $TwoCurvesBest,  $NearestCurvesSame[0]);
			$objectSelection = $TwoCurvesBest;
		}
	}
	///////////////////////////////////////////////// ////
	setAttr "subCurve1.minValue" 0.85;
	setAttr "subCurve2.minValue" 0.85;
	$EdgecurvesizeNUM = size($objectSelection);
	string $each;
	for ($each in $objectSelection) {
		string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
		if (catchQuiet($intersectZ = `intersect -ch 0 - cos 0 -fs 1 -tol 0.001 -name IntersectSURFACZ  $iSurf[0] $surf[0]`)){
			
			delete `ls -sl`;
		} else {
			///////////////GATHER ALL BUILDING  STRUCTURE/////////##
			appendStringArray($digitalSkeletonA, $iSurf, 1);
			appendStringArray($digitalSkeletonA, $intersectZ,  1); 
			///////////////
			$objectCurve[0] = $each;
			string $objectCurveZ[] = `ls -sl -tl 1`;
			appendStringArray($AllCurveZ, $objectCurve, 1);
			string $curveIntersectZ[];
			$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZ $objectCurve[0]`;
			string $buffer[];
			$numTokens = `tokenize $curveIntersectZ[0] " "  $buffer`;
			$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[1] + "]");
			appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
			appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
			float $intersectposA[];	
			$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
			string $objectLocaterzA[];
			$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
			move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
			///////////
			appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
			///////////
			$foundCurve++;
			if ($foundCurve == 2){ $foundCurve = 0; break;} 
		}
	}
	setAttr "subCurve1.minValue" 0.0;
	setAttr "subCurve2.minValue" 0.0;
	setAttr "subCurve1.maxValue" 0.15;
	setAttr "subCurve2.maxValue" 0.15;
	$EdgecurvesizeNUM = size($objectSelection);
	string $each;
	for ($each in $objectSelection) {
		string $iSurf[] = `extrude -ch 1 -et 0 -l  0.05 -n AxisSelection ( $each )`;
		if (catch($intersectZ = `intersect -ch 0 -cos 0  -fs 1 -tol 0.001 -name IntersectSURFACZ $iSurf[0]  $surf[0]`)){
			
			delete `ls -sl`;
		} else {
			///////////////GATHER ALL BUILDING  STRUCTURE/////////##
			appendStringArray($digitalSkeletonA, $iSurf, 1);
			appendStringArray($digitalSkeletonA, $intersectZ,  1); 
			///////////////
			$objectCurve[0] = $each;
			string $objectCurveZ[] = `ls -sl -tl 1`;
			appendStringArray($AllCurveZ, $objectCurve, 1);
			string $curveIntersectZ[];
			$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZ $objectCurve[0]`;
			string $buffer[];
			$numTokens = `tokenize $curveIntersectZ[0] " "  $buffer`;
			$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[1] + "]");
			appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
			appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
			float $intersectposA[];	
			$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
			string $objectLocaterzA[];
			$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
			move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
			///////////
			appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
			///////////
			$foundCurve++;
			if ($foundCurve == 2){ $foundCurve = 0; break;} 
		}
	}
	setAttr "subCurve1.maxValue" 1.0;
	setAttr "subCurve2.maxValue" 1.0;
	///////////////////////////////////////////////// /////////////////////////////////
	///////////////////////////////////////////////// /////////////////////////////////
	appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, size($AllSpaceLocatorZ));
	string $shorterList[] =  stringArrayRemoveDuplicates($AllCurveZ);
	$AllCurveZ = $shorterList;
	int $CurvesCUTinto = size($AllCurveZ);
	if ($CurvesCUTinto == 1){string $oneLocatorZ[] =  {$AllparamlocatorZ[0]}; $AllparamlocatorZ =  $oneLocatorZ; }
	int $numparam = size($AllparamlocatorZ);
	if (($CurvesCUTinto == 2) && ($numparam == 4)){
		string $oneLocatorZa[] = {$AllparamlocatorZ[0]}; 
		string $oneLocatorZb[] = {$AllparamlocatorZ[1]}; 
		$AllparamlocatorZ = {$oneLocatorZa[0],  $oneLocatorZb[0]}; 
	}
	$numparam = size($AllparamlocatorZ);
	int $numInts = size($AllSpaceLocatorZ);
	if (($CurvesCUTinto == 2) && ($numInts == 4)){
		string $oneLocatorZ2a[] = {$AllSpaceLocatorZ[0]}; 
		string $oneLocatorZ2b[] = {$AllSpaceLocatorZ[1]}; 
		$AllSpaceLocatorZ = {$oneLocatorZ2a[0],  $oneLocatorZ2b[0]}; 
	}
	$numInts = size($AllSpaceLocatorZ);
	if ( $numparam > 0 ){
		//$paramlocatorZ[0] = `rename ParamLocatorShape`;
		string $shorterList[] =  stringArrayRemoveDuplicates($AllparamlocatorZ);
		$AllparamlocatorZ = $shorterList;
	}
	$numparam = size($AllparamlocatorZ);
	$numInts = size($AllSpaceLocatorZ);
	if ( $numparam == 1 ){
		float $EACHCVposA[];
		$EACHCVposA = `positionOne($AllparamlocatorZ[0]) `;
		float $EACHCVposA[] = `positionOne ($AllparamlocatorZ[0])`;
	}
	if ( $numparam == 1 ){
		float $EACHCVposA[];
		$EACHCVposA = `positionOne($AllparamlocatorZ[0]) `;
		float $EACHCVposA[] = `positionOne ($AllparamlocatorZ[0])`;
	}
	select -cl  ;
	string $MakespaceLocatorZSE[];
	string $SEspaceLocSetofSetz = `sets -name  SEspaceLocSetofSets`;	
	string $paramANDCurve3[] = `paramToCurvePts3(  $AllparamlocatorZ )`;
	string $paramANDCurve2[] = `paramToCurvePts2(  $AllparamlocatorZ )`;
	string $paramANDCurve[] = `paramToCurvePts(  $AllparamlocatorZ )`;
	string $paramCurveNAMES[] = `tokenizeparam(  $paramANDCurve )`;
	$MakespaceLocatorZSE = EvalMoveCurvesTOend ($paramANDCurve, $paramCurveNAMES,  $paramANDCurve3, $AllparamlocatorZ,  $SEspaceLocSetofSetz);
	if (size($MakespaceLocatorZSE) > 0){
		appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
	}
	int $setsNumber = `sets -q -size  $SEspaceLocSetofSetz`;
	if ($setsNumber > 0){
		string $subsets[];
		$subsets = `sets -q $SEspaceLocSetofSetz`;
		//appendStringArray($digitalSkeletonA, $subsets,  size($subsets));
	}

	print $digitalSkeletonA;
	string $objectcurv[0] = {$digitalSkeletonA[0]};
	if ( $numparam == 0 ){
		/////////////////////////////////////////////////////########################
		string $plainXa = CurveIntersectZX($objectcurv);
		string $intersectionCurvePlainX[];
		$intersectionCurvePlainX = `intersect  -ch 0 - fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves" $plainXa`;
		string $theintersectA[];
		$theintersectA = $intersectionCurvePlainX;
		string $theintersectCURVEsA[];
		$theintersectCURVEsA = `listRelatives -children  $theintersectA`;
		parent -w $theintersectCURVEsA;
		delete $theintersectA;
		//select -r $theintersectCURVEsA;
		delete $plainXa;
		string $newnameA = "Curve";
		string $renamedA2 = `rename $theintersectCURVEsA $newnameA`; 
		$intersectionCurvePlainX = {$renamedA2};
		int $trueORfalseA = 0;
		int $trueORfalseA2 = 0;
		$trueORfalseA = FindIfCurveCrossesZ($intersectionCurvePlainX);
		string $newname[]; 
		if ($trueORfalseA == 1){
			CutCurveIFConditionTRUETransitZ($intersectionCurvePlainX);
			$trueORfalse2A = 1;
			ResetTranslation($intersectionCurvePlainX);
		}  
		/////////////////////////////////
		if ($trueORfalseA == 0){
			ResetTranslation($intersectionCurvePlainX);
		}
		string $ParentArc[];
		$ParentArc = Strait_ARC_or_FreeForm($intersectionCurvePlainX,  1.9, 1.5 );
		select -r $ParentArc;
		MirrorANDrename($ParentArc);
		if ($trueORfalseA2 == 1){
			sets -include ZEdgeCurvesSet $ParentArc;
		}
		///////////////////////////////////////////////// ///////
		///////////////////////////////////////////////// ///////
		ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);
		ResetTranslation($ParentArc);
		editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ParentArc;
		select -r $ParentArc[0];
		EvalAddingCurves;
		EvalcreatSphere;
		/////////////////////////////////////////////////////////////////////////////////////////////////////
	} else if ( $numparam == 1 ){
		print ("numparam IS 1" + "\n");
		//ONE LOCATOR // print $AllSpaceLocatorZ;
		//ONE LOCATOR  /////////////////////////////////////////////
		//appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, 1);
		string $objectSelection[0] = $AllSpaceLocatorZ;
		string $cameraANDlocator[];
		$cameraANDlocator[0] = "LiveSurfaceB"; 
		float $point1[];
		float $point2[];
		$point1 = `xform -query -worldSpace - translation ( $objectSelection[0])`;
		$point2 = `xform -query -worldSpace - translation ( $cameraANDlocator[0])`;
		$dx = $point1[0] - $point2[0];
		$dy = $point1[1] - $point2[1];
		$dz = $point1[2] - $point2[2];
		float $distance;
		$distance = `sqrt( ($dx * $dx) + ($dy * $dy) +  ($dz * $dz) )`;
		$scalePlane = $distance;
		nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "cutingplaneAlign";
		scale -r $scalePlane $scalePlane $scalePlane;
		performRebuildSurfaceSet 1 1 0 0.001 4 4 3 3 1 2  1 0 2 1 0.05 0 0;
		if ($plainNum == 0){
			setAttr "cutingplaneAlign.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
			setAttr "cutingplaneAlign.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
			setAttr "cutingplaneAlign.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
		}
		//  float $angleofStraitCurve[] =  `EulerAngleofCurve`;
		if ($plainNum == 1){ setAttr  cutingplaneAlign.rotateZ 90; setAttr  cutingplaneAlign.rotateX 45; }
		if ($plainNum == 2){ setAttr  cutingplaneAlign.rotateZ 90; setAttr  cutingplaneAlign.rotateX -45; }
		if ($plainNum == 3){ setAttr  cutingplaneAlign.rotateZ 90; }
		if ($plainNum == 4){ setAttr  cutingplaneAlign.rotateX 90; } 
		if ($plainNum == 5){ setAttr  cutingplaneAlign.rotate 0.0 0.0 0.0; } 
		print $objectSelection; 
		float $Locaterpos[];	
		$Locaterpos = `pointPosition -w (  $objectSelection[0] )`;
		move  -ws $Locaterpos[0] $Locaterpos[1]  $Locaterpos[2] cutingplaneAlign ;
		string $intersectionCurveMake1[];
		$intersectionCurveMake1 = `intersect  -ch false  -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"  "cutingplaneAlign" `;

		string $theintersect[];
		$theintersect = $intersectionCurveMake1;
		string $theintersectCURVEs[];
		$theintersectCURVEs = `listRelatives -children  $theintersect`;
		parent -w $theintersectCURVEs;
		delete $theintersect;
		select -r $theintersectCURVEs $AllCurveZ;
		string $bufferCutCurve[];
		string $ZIntersectionCurveZ[];
		string $afterCut[];
		string $numTokensZ;
		int $n, $i;
		cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
		$afterCut = `ls -sl`;
		$n = size($afterCut);
		for( $i=0; $i<$n; $i+=1 ) {
			// Now, two of these are  bad, two are OK:
			if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
			} else {			
				$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
				$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		}
		string $ZIntersectionCurveZA[];
		$ZIntersectionCurveZA = `listRelatives -shapes  $ZIntersectionCurveZ`;
		string $renamed[]; 
		$renamed[0] = `rename $ZIntersectionCurveZ Curve`;
		ResetTranslation($renamed);
		string $CurveSelection[]; 
		int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
		int $numCVrealNum = ( $numCVs -1 );
		$CurveSelection[0] = ($renamed[0] + ".cv[0]") ;		 	
		$CurveSelection[1] = ($renamed[0] + ".cv[" +  $numCVrealNum + "]") ;
		float $EACHCVposAZ[];
		float $EACHCVposBZ[];	
		int $numIntZB = 0;
		string $MakeXBetweenB[];
		for ($eachZA in $CurveSelection) {
			float $eachCVpos[];		
			$eachCVpos = `pointPosition -w ( $eachZA   )`;
			$numIntZB = $numIntZB + 1;
			if ( $numIntZB == 1 ){
				$EACHCVposAZ = $eachCVpos;
			}
			if ( $numIntZB == 2 ){
				$EACHCVposBZ = $eachCVpos;
			}
		}
		if (size($MakespaceLocatorZSE) > 0){
			int $ZEROorONE;
			int $foundA = stringArrayGmatch ("SEspaceLocatorSTART3DZ*",  $MakespaceLocatorZSE);
			int $foundB = stringArrayGmatch ("SEspaceLocatorEND3DZ*", $MakespaceLocatorZSE);
			if (( $foundA == 1 ) || ( $foundB == 1 )) {
				float $eachCVposSTART[] = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
				float $movePIVOT[];
				$ZEROorONE = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTART);
				if ( $ZEROorONE == 0){ $movePIVOT = $EACHCVposAZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +                        ".rotatePivot") ;}
				if ( $ZEROorONE == 1){ $movePIVOT = $EACHCVposBZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +                        ".rotatePivot") ; }
				move -rpr $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2] $renamed[0];
				xform -cp $renamed[0];
			}
		}
		if (size($MakespaceLocatorZSE) == 0){
			string $paramANDCurveA2[];
			$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
			string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
			delete $AllCurveZ;
			string $AllCurveZ2[];
			string $newCurves1[];
			for ($each in $detachCurve1){
				string $newCurve;
				$newCurve = `rename $each Curve`;
				ArrayInsertAtEnd( $newCurves1, $newCurve);
			}
			string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
			$INarrayA = $objectLayerCurvesRange;
			ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
			ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
			string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
			$digitalSkeletonA = $diffdigitalSkeleton;
			$AllCurveZ = $newCurves1;
		}
		delete $digitalSkeletonA cutingplaneAlign;
		ResetTranslation($renamed);
		string $renamed2[];
		$renamed2 = $renamed;
		///////////////////////////////////////////////// ///////
		///////////////////////////////////////////////// ///////
		// IF Drawn Curve is connected to the end of  another curve thast is in EdgeSet
		// the curve drawn can be on a edge curve which  is eather protruding from the ZY plain 
		// or it lies on the ZY plain. if it is at one of  the two ends of a protruding EdgeCurve
		// then the drawn curve intersecting at  EdgeCurves Ends is eather also protruding from ZY  plain or 
		// is positioned freely at the other end.. which  means it could be crossing the ZY plain which  means     
		// It would need to be cut
		int $ifNearEnds = size($MakespaceLocatorZSE);
		int $AllCurveCVsZeroAndLast = FindIfCurveISonZ ($AllCurveZ);
		int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
		int $ZeroX = 0;
		if (( $ifNearEnds == 1) && (  $AllCurveCVsZeroAndLast == 1) && ( $edgeZsetA ==  1)) {
			vector $AllCurveCVENDs[] = `VecCurveEnds ($AllCurveZ)`;
			vector $renamed2CVENDs[] = `VecCurveEnds ($renamed2)`;
			float $renamed2CVENDAs[] = $renamed2CVENDs[0];
			float $renamed2CVENDBs[] = $renamed2CVENDs[1];
			float $AllCurveCVENDAs[] = $AllCurveCVENDs[0];
			float $AllCurveCVENDBs[] = $AllCurveCVENDs[1];
			float $FloatZ1[] = $renamed2CVENDAs;
			float $FloatZ2[] = $renamed2CVENDBs;
			float $FloatZ3[] = $AllCurveCVENDAs;
			float $FloatZ4[] = $AllCurveCVENDBs;
			$renamed2CVENDAs = `MakeCleanFloats($FloatZ1)`;
			$renamed2CVENDBs = `MakeCleanFloats($FloatZ2)`;
			$AllCurveCVENDAs = `MakeCleanFloats($FloatZ3)`;
			$AllCurveCVENDBs = `MakeCleanFloats($FloatZ4)`;
			int $CombA = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDAs);
			int $CombB = PointsEquivalentTol ($renamed2CVENDBs, $AllCurveCVENDBs);
			int $CombC = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDBs);
			float $intersectFloat[];
			if ($CombA == 3 ){ $intersectFloat =  $AllCurveCVENDAs;}
			if ($CombB == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
			if ($CombC == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
			print $intersectFloat;
			float $Zero0x = 0.0;
			$ZeroX = equivalentTol($Zero0x, $intersectFloat [0], 0.001);
		}
		$intZplainF = 1;
		if ($ZeroX == 1){
			$intZplainF = `ZplainFlatten`;
			if($intZplainF == 0){
				FlattenCurveToZplain($renamed);
			}
		}
		if ($AllCurveCVsZeroAndLast == 2){
			$intZplainF = `ZplainFlatten`;
			if($intZplainF == 0){
				FlattenCurveToZplain($renamed);
			}
		}
		int $trueORfalse = 0;
		int $trueORfalse2 = 0;
		if ($ZeroX == 0){
			$trueORfalse = FindIfCurveCrossesZ($renamed2);
			print ("IF_Curve_Crosses_Z True-OR-False"+"  "+$trueORfalse);
			string $newname[]; 
			if (($trueORfalse == 1) && ($ZeroX == 0)){
				$newname = CutCurveIFConditionTRUETransitZ ($renamed2);
				$trueORfalse2 = 1;
				ResetTranslation($newname);
				rename $newname $renamed; 
			}
		}  
		/////////////////////////////////
		string $newnamed[0] = {$renamed2[0]};
		ResetTranslation($renamed);
		string $ParentArc[];
		// $CurveDirection
		//$ParentArc = Direction_Strait_ARC_or_FreeForm($newnamed,  1.5, 2.5, $CurveDirection);
		$ParentArc = Strait_ARC_or_FreeForm($newnamed,  1.5, 2.5 );
		if($intZplainF > 0)  {
			select -r $ParentArc;
			MirrorANDrename($ParentArc);
		}
		if (($ZeroX == 1) || ($trueORfalse2 == 1)){
			sets -include ZEdgeCurvesSet $ParentArc;
		}
		///////////////////////////////////////////////// ///////
		///////////////////////////////////////////////// ///////
		ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);
		ResetTranslation($ParentArc);
		editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ParentArc;
		select -r $ParentArc[0];
		EvalAddingCurves;
		EvalcreatSphere;
		///////////////////////END OF ONE  CURVE
		//////////////////////////////////////
	} else if ( $numparam > 2 ){
		if (size($MakespaceLocatorZSE) > 0){
			appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
		}
		delete $digitalSkeletonA;
		//////////////////////////////////////
		//////////////////////////////////////
	} else if ( $numparam == 2 ){
		//////////////////////
		//START OF 2 Curves
		int $boundSurfTrigger = 0;
		string $BoundaryA[];
		string $NewboundryA[];
		string $objectCurveIntersectAZ[] =  CompareCurveIntersect($AllCurveZ );
		string $objectLayerCurvesRangeA[] =  `queryLayerRangeMembers`;
		int $numberofAllcurves = size ($objectLayerCurvesRangeA);
		if ($numberofAllcurves > 3){
			string $diffNearestCurvesWithIntersectsA[] =  stringArrayRemoveExact($AllCurveZ,  $objectLayerCurvesRangeA);
			string $diffNearestCurvesWithIntersectsB[] =  stringArrayRemoveExact($AllCurveZ,  $objectLayerCurvesRangeA);
			string $AllCurveZA[0] = {$AllCurveZ[0]};
			string $AllCurveZB[0] = {$AllCurveZ[1]};
			SecondArrayInsertAtEndofArray(  $diffNearestCurvesWithIntersectsA, $AllCurveZA);
			SecondArrayInsertAtEndofArray(  $diffNearestCurvesWithIntersectsB, $AllCurveZB);
			string $allNearcurves[];
			if ($numberofAllcurves < 6){ 
				string $diffCurvesAll[] =  stringArrayRemoveExact($AllCurveZ,  $objectLayerCurvesRangeA);
				$allNearcurves = $diffCurvesAll; }else{
				int $ni = 6;
				string $NearestCurvesZAi[] =  (NearestObjectArray($ni,  $diffNearestCurvesWithIntersectsA));
				string $NearestCurvesZBi[] = (NearestObjectArray ($ni, $diffNearestCurvesWithIntersectsB));
				$allNearcurves = $NearestCurvesZAi;
				appendStringArray($allNearcurves,  $NearestCurvesZBi, size($NearestCurvesZBi));
				string $shorterListA[] =  stringArrayRemoveDuplicates($allNearcurves);
				$allNearcurves = $shorterListA;
			}
			string $allNearcurvesIntersects[] =  CompareCurveIntersectTwoCurves($AllCurveZ,  $allNearcurves);
			if (size($allNearcurvesIntersects) == 2 ){
				$BoundaryA = `boundary -ch 1 -or 0 -ep 1 -rn 1 - po 0 -ept 0.1 $AllCurveZ[0]  $allNearcurvesIntersects[0] $AllCurveZ[1]  $allNearcurvesIntersects[1]  `;
				$NewboundryA = {$BoundaryA[0]};
				appendStringArray($digitalSkeletonA,  $NewboundryA, 1);
				$boundSurfTrigger = 1;
			}
		}
		int $paramloc = size($AllparamlocatorZ);
		int $paramlocIndexA;
		int $paramlocIndexB;
		if ($paramloc > 2){
			int $paramlocRealIndex = $paramloc -1;
			$paramlocIndexA = $paramlocRealIndex -1;
			$paramlocIndexB = $paramlocRealIndex;
		} else {$paramlocIndexA = 0;
			$paramlocIndexB = 1;}
		float $EACHCVposA[] = `positionOne ($AllparamlocatorZ[$paramlocIndexA])`;
		float $EACHCVposB[] = `positionOne ($AllparamlocatorZ[$paramlocIndexB])`;
		$ZBetween[0] = `curve -d 1 -p $EACHCVposA[0]  $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0]  $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n             ZCurveBetween`;
		string $duplicateCurvez1[];
		string $duplicateCurvez2[];
		$duplicateCurvez1 = `duplicateCurve -ch 0 -rn 0  -local 0  "LiveSurfaceBShape.u[0]" `;
		xform -cp $duplicateCurvez1;
		$duplicateCurvez2 = `duplicateCurve -ch 0 -rn 0  -local 0  "LiveSurfaceBShape.u[1]" `;
		xform -cp $duplicateCurvez2;
		ResetTranslation($duplicateCurvez1);
		ResetTranslation($duplicateCurvez2);
		move  -ws $EACHCVposA[0] $EACHCVposA[1]  $EACHCVposA[2] $duplicateCurvez1;
		move  -ws $EACHCVposB[0] $EACHCVposB[1]  $EACHCVposB[2] $duplicateCurvez2;
		string $LoftduplicateCurvez[];
		$LoftduplicateCurvez = `loft -ch 0 -u 1 -c 0 -ar  1 -d 3 -ss 4 -rn 0 -po 0 -rsn true  $duplicateCurvez1 $duplicateCurvez2`;
		extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo  1 -es 2 -ed 0  $LoftduplicateCurvez;
		extendSurface -ch 0 -em 0 -et 0 -d 10 -jn 1 -rpo  1 -es 2 -ed 1  $LoftduplicateCurvez;
		//RESET ITS 000 TRANS
		ResetTranslation($ZBetween);
		$ZBetweenDUP = `duplicate -rr $ZBetween[0]`;
		$ZBetweenDUP2 = `duplicate -rr $ZBetween[0]`;
		///////////////GATHER ALL BUILDING  STRUCTURE/////////##
		appendStringArray($digitalSkeletonA, $ZBetween,  1);
		appendStringArray($digitalSkeletonA,  $LoftduplicateCurvez, 1);
		appendStringArray($digitalSkeletonA,  $duplicateCurvez1, 1);
		appendStringArray($digitalSkeletonA,  $duplicateCurvez2, 1);
		appendStringArray($digitalSkeletonA,  $ZBetweenDUP, 1);
		appendStringArray($digitalSkeletonA,  $ZBetweenDUP2, 1);
		appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, 2);
		///////////////GATHER ALL BUILDING  STRUCTURE/////////##
		string $TANGENT[];
		string $TANGENTloftA[];
		string $TANGENTloft[];
		$TANGENTA = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss  4 -rn 0 -po 0 -rsn true -n TANGENTSURFACE  $AllCurveZ[0] $AllCurveZ[1]`;
		extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo  1 -es 2 -ed 0 -n $TANGENTA $TANGENTA;
		$TANGENT[0] = `curve -d 3 -p 0 0 0 -p 0 0 -1.5 -p  0 0 -3 -p 0 0 -4.5 -k 0 -k 0 -k 0 -k 4.5 -k 4.5  -k 4.5 -n TANGENTCURVE` ;
		string $surfaceUsed[];
		if ($boundSurfTrigger == 1){ normalConstraint - weight 1 -aimVector 0 0 1 -upVector 0 0 1 - worldUpType "vector" -worldUpVector 1 0 0  $NewboundryA   TANGENTCURVE ;
			$surfaceUsed = $NewboundryA;
		}else{
			normalConstraint -weight 1 -aimVector 0 0 1 - upVector 0 0 1 -worldUpType "vector" - worldUpVector 1 0 0 TANGENTSURFACE TANGENTCURVE ;
			$surfaceUsed = {"TANGENTSURFACE"};
		}
		//////////////////////////
		//////////////////////////////
		//AVERAGEbetween two Locators
		shadingNode -asUtility plusMinusAverage;
		rename plusMinusAverageA;
		setAttr plusMinusAverageA.operation 3;                                               
		connectAttr -force plusMinusAverageA.output3D (  "|" + "TANGENTCURVE" + ".translate");
		connectAttr -f ( $AllSpaceLocatorZ[0] +  ".translate") plusMinusAverageA.input3D[1];
		connectAttr -f ( $AllSpaceLocatorZ[1] +  ".translate") plusMinusAverageA.input3D[0];
		string $CurveSelection2[]; 
		int $numCVs = `getAttr -size ("TANGENTCURVE" +  ".controlPoints")`;
		int $numCVrealNum = ( $numCVs -1 );			
		$CurveSelection2[1] = ("TANGENTCURVE" + ".cv[" +  $numCVrealNum + "]") ;
		float $TANGENTCURVEposA[];	
		$TANGENTCURVEposA = `pointPosition -w (  $CurveSelection2[1]  )`;
		move  -ws $TANGENTCURVEposA[0] $TANGENTCURVEposA [1] $TANGENTCURVEposA[2] ZCurveBetween1;
		$TANGENTloft = `loft -ch 1 -u 1 -c 0 -ar 1 -d 3  -ss 4 -rn 0 -po 0 -rsn true -n  PROJECTonTANGENTSURFACE ZCurveBetween  ZCurveBetween1`;
		extendSurface -ch 0 -em 0 -et 0 -d 100 -jn 1 -rpo  1 -es 2 -ed 1  "PROJECTonTANGENTSURFACE";
		delete -ch PROJECTonTANGENTSURFACE;
		float $TANCURVEAposA[];
		$TANCURVEAposA = `xform -query - worldSpace -translation TANGENTCURVE`;
		string $TANGENTZ[];
		$TANGENTZ[0] = `curve -d 3 -p 0 0 0 -p -1.5 0 0  -p -3 0 0 -p -4.5 0 0 -k 0 -k 0 -k 0 -k 4.5 -k  4.5 -k 4.5 -n TANGENTCURVEZ` ;
		move  -ws $TANCURVEAposA[0] $TANCURVEAposA[1]  $TANCURVEAposA[2] TANGENTCURVEZ;
		aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM  $TANGENTZ;
		///////////////GATHER ALL BUILDING  STRUCTURE/////////##
		appendStringArray($digitalSkeletonA, $TANGENTZ,  1);
		appendStringArray($digitalSkeletonA, $TANGENTA,  1);
		appendStringArray($digitalSkeletonA, $TANGENT,  1);
		appendStringArray($digitalSkeletonA,  $TANGENTloft, 1);
		///////////////////////////////////////////////// ////##
		string $CurveSelectionZ[]; 
		int $numCVsA = `getAttr -size ($TANGENTZ[0] +  ".controlPoints")`;
		int $numCVrealNumA = ( $numCVsA -1 );		
		$CurveSelectionZ[0] = ($TANGENTZ[0] + ".cv[" +  $numCVrealNumA + "]") ;
		string $CurveSelectionX[]; 
		int $numCVsB = `getAttr -size ($TANGENT[0] +  ".controlPoints")`;
		int $numCVrealNumB = ( $numCVsB -1 );			
		$CurveSelectionX[0] = ($TANGENT[0] + ".cv[" +  $numCVrealNumB + "]") ;
		string $CurveSelectionY[]; 
		$CurveSelectionY[0] = ($TANGENTZ[0] + ".cv[" + 0  + "]") ;
		// This Corrects the problem of constraining a  curve to the normal of a Surf while wanting
		// the curve to point from the surface towards  the camera but with out knowing the surface  normal direction
		// so this flips the surface to use the surface  setting that matches the shortest distance from  curve end to CAM
		// hence fixing if the curve is pointing the  wrong way;
		string $ZCAM[] = {"ZCURVEModelingCAM"};
		float $CAMfromTANX2 =  GetDistancePointPositionFLOAT($ZCAM[0],  $CurveSelectionX[0]);
		reverseSurface -d 1 -ch 1 -rpo 1 $surfaceUsed;
		float $CAMfromTANX3 =  GetDistancePointPositionFLOAT($ZCAM[0],  $CurveSelectionX[0]);
		if($CAMfromTANX2 < $CAMfromTANX3){ reverseSurface  -d 1 -ch 1 -rpo 1 $surfaceUsed; }
		float $TANZfromTANX2;
		$TANZfromTANX2 = GetDistancePointPositionFLOAT ($CurveSelectionZ[0], $CurveSelectionX[0]);
		float $p1[];		
		$p1 = `pointPosition -w (  $CurveSelectionZ[0]  )`;
		float $p2[];		
		$p2 = `pointPosition -w (  $CurveSelectionX[0]  )`;
		float $p3[];		
		$p3 = `pointPosition -w (  $CurveSelectionY[0]  )`;
		float $mid1[3];
		$mid1 = midPoint2Pts( $p1, $p2 );
		string $TANGENTY[];
		string $TANGENTloftY[];
		$TANGENTY[0] = `curve -d 1 -p $p3[0] $p3[1] $p3 [2] -p $mid1[0] $mid1[1] $mid1[2] -k 0 -k 2 -n  TANGENTCURVEY`;
		appendStringArray($digitalSkeletonA, $TANGENTY,  1);
		move  -ws $mid1[0] $mid1[1] $mid1[2]  $ZBetweenDUP2;

		$TANGENTloftY = `loft -ch 0 -u 1 -c 0 -ar 1 -d 3  -ss 4 -rn 0 -po 0 -rsn true -n  PROJECTonTANGENTSURFACEY $ZBetweenDUP2  $ZBetween`;

		extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo  1 -es 2 -ed 2  "PROJECTonTANGENTSURFACEY";
		extendSurface -ch 0 -em 0 -et 2 -d 100 -jn 1 -rpo  1 -es 2 -ed 2  "PROJECTonTANGENTSURFACEY";

		appendStringArray($digitalSkeletonA,  $TANGENTloftY, 1);
		string $queryIntersectFormLayer[];
		$queryIntersectFormLayer =  `editDisplayLayerMembers -q IntersectFormLayer`;
		if (size( $queryIntersectFormLayer) > 0){
			$TANGENTloft[0] = $queryIntersectFormLayer[0]; 
			$TANGENTA[0] = $queryIntersectFormLayer[0]; 
			$TANGENTloftY[0] = $queryIntersectFormLayer[0]; 
			$LoftduplicateCurvez[0] =  $queryIntersectFormLayer[0]; 
		}
		string $rebuildit[];
		string $intersectionCurveMake[];
		string $intersectionCurve[];
		print $boundSurfTrigger;
		if ($boundSurfTrigger == 1){ 
			$intersectionCurveMake = `intersect  -ch false - fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"  $NewboundryA `;
		}else{
			$intersectionCurveMake = `intersect  -ch false - fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"  $TANGENTloft[0] `;
		}
		$intersectionCurve = `listRelatives  $intersectionCurveMake`; 
		if ((size($intersectionCurve) > 1) || (  $TANZfromTANX2 < 2.25 )) {
			delete $intersectionCurve; 
			delete $intersectionCurveMake;
			string $intersectionCurveMake2[];
			string $intersectionCurve2[];
			$intersectionCurveMake2 = `intersect  -ch  false -fs 0 -cos 0 -tol 0.001  "SurfaceinterectCurves" $TANGENTA[0] `;
			$intersectionCurve2 = `listRelatives  $intersectionCurveMake2`;
			print $TANGENTA; print "intersectionCurve2"; 
			if (size($intersectionCurve2) >  1){
				delete  $intersectionCurve2; 
				delete  $intersectionCurveMake2;
				string  $intersectionCurveMake3[];
				string  $intersectionCurve3[];
				$intersectionCurveMake3 =  `intersect  -ch false -fs 0 -cos 0 -tol 0.001  "SurfaceinterectCurves" $TANGENTloftY[0] `;
				$intersectionCurve3 =  `listRelatives $intersectionCurveMake3`;
				if (size ($intersectionCurve3) > 1) {
					delete  $intersectionCurve3; 
					delete  $intersectionCurveMake3;
					string  $intersectionCurveMake4[];
					string  $intersectionCurve4[];
					$intersectionCurveMake4 = `intersect  -ch false  -fs 0 -cos 0 -tol 0.001 "SurfaceinterectCurves"      $LoftduplicateCurvez[0] `;
					$intersectionCurve4 = `listRelatives  $intersectionCurveMake4`;
					parent -w  $intersectionCurve4;
					string  $renamed[]; 
					$renamed [0] = `rename $intersectionCurve4 Curve`; 
					$rebuildit = $renamed;
					ResetTranslation($rebuildit);
					///////////////////////////////////////////////
					select -r $intersectionCurve3 $AllCurveZ[0];
					string $bufferCutCurve[];
					string $ZIntersectionCurveZ[];
					string $afterCut[];
					string $numTokensZ;
					int $n, $i;
					cutCurvePreset(1,1,0.01,6,-0.7767,0.1104,- 0.6201,1,2);
					$afterCut = `ls -sl`;
					$n = size($afterCut);
					for( $i=0; $i<$n; $i+=1 ) {
						// Now, two of these are  bad, two are OK:
						if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
						} else {			
							$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
							$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
						}		}
					if (catch(`select -r $bufferCutCurve[0]  $AllCurveZ[1]`)){
						select -r $intersectionCurve3 $AllCurveZ[1];
					} else { print "hereCUT2"; }
					cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
					$afterCut = `ls -sl`;
					$n = size($afterCut);
					for( $i=0; $i<$n; $i+=1 ) {
						// Now, two of these are  bad, two are OK:
						if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
						} else {			
							$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
							$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
						}		}
					$renamed[0] = `rename $ZIntersectionCurveZ[0]  Curve`;
					string $ZIntersectionCurveZB[];
					$ZIntersectionCurveZB = `listRelatives -shapes  $renamed`;
					if (size($ZIntersectionCurveZB) > 0 ){
						string $ListCONCurveZA[];
						$ListCONCurveZA = `listConnections  $ZIntersectionCurveZB`;
						if (size( $ListCONCurveZA) > 0){
							string $ListCONCurveZB[];
							$ListCONCurveZB = `listConnections -shapes 0 - source 0 $ListCONCurveZA`;
							delete  $ListCONCurveZA $ListCONCurveZB;
						}
					}
					$rebuildit = $renamed;
					///////////
				} else { 
					print "parent intersectionCurve3"; 
					parent -w $intersectionCurve3;
					//CHANGE
					$rebuildit = $intersectionCurve3;
					ResetTranslation($rebuildit);
					select -r $intersectionCurve3 $AllCurveZ[0];
					string $bufferCutCurve[];
					string $ZIntersectionCurveZ[];
					string $afterCut[];
					string $numTokensZ;
					int $n, $i;
					cutCurvePreset(1,1,0.01,6,-0.7767,0.1104,- 0.6201,1,2);
					$afterCut = `ls -sl`;
					$n = size($afterCut);
					for( $i=0; $i<$n; $i+=1 ) {
						// Now, two of these are  bad, two are OK:
						if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
						} else {			
							$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
							$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
						}
					}
					//string $ZIntersectionCurveZA[];
					// $ZIntersectionCurveZA = `listRelatives -shapes  $ZIntersectionCurveZ`;
					if (catch(`select -r $bufferCutCurve[0]  $AllCurveZ[1]`)){
						select -r $intersectionCurve3 $AllCurveZ[1];
					} else { print "hereCUT2"; }
					cutCurvePreset(1,1,0.001,6,-0.7767,0.1104,- 0.6201,1,2);
					$afterCut = `ls -sl`;
					$n = size($afterCut);
					for( $i=0; $i<$n; $i+=1 ) {
						// Now, two of these are  bad, two are OK:
						if( `getAttr ($afterCut [$i] + ".spans")` < 1){ delete $afterCut[$i];
						} else {			
							$numTokensZ = `tokenize $afterCut[$i] "."  $bufferCutCurve`;
							$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; 
						}
					}
					$renamed[0] = `rename $ZIntersectionCurveZ[0]  Curve`;
					string $ZIntersectionCurveZB[];
					$ZIntersectionCurveZB = `listRelatives -shapes  $renamed`;
					if (size($ZIntersectionCurveZB) > 0 ){
						string $ListCONCurveZA[];
						$ListCONCurveZA = `listConnections  $ZIntersectionCurveZB`;
						if (size( $ListCONCurveZA) > 0){
							string $ListCONCurveZB[];
							$ListCONCurveZB = `listConnections -shapes 0 - source 0 $ListCONCurveZA`;
							delete  $ListCONCurveZA $ListCONCurveZB;
						}
					}
					$rebuildit = $renamed;
				}} else {
				parent -w $intersectionCurve2;
				string $renamed[]; 
				$renamed[0] = `rename $intersectionCurve2 Curve`;
				//CHANGE
				$rebuildit = $renamed;
				ResetTranslation($rebuildit); 
				print "parent intersectionCurve002"; }
		} else {
			$intersectionCurve = `listRelatives  $intersectionCurveMake`; 
			parent -w $intersectionCurve;
			string $renamed[]; 
			$renamed[0] = `rename $intersectionCurve Curve`; 
			$rebuildit = $renamed;
			ResetTranslation($rebuildit);
		} 
		if ( size($MakespaceLocatorZSE) == 0  ) {
			PAUSE;
			string $paramANDCurveA2[];
			$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
			string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
			string $detachCurve2[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[1]`;
			delete $AllCurveZ;
			string $newCurves1[];
			string $newCurves2[];
			for ($each in $detachCurve1){
				string $newCurve;
				$newCurve = `rename $each Curve`;
				ArrayInsertAtEnd( $newCurves1, $newCurve);
			}
			for ($each in $detachCurve2){
				string $newCurve;
				$newCurve = `rename $each Curve`;
				ArrayInsertAtEnd( $newCurves2, $newCurve);
			}
			string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
			$INarrayA = $objectLayerCurvesRange;
			ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
			ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
			ArrayInsertAtEnd( $INarrayA, $newCurves2[0]);
			ArrayInsertAtEnd( $INarrayA, $newCurves2[1]);
			ResetTranslationEach($newCurves1);
			ResetTranslationEach($newCurves2);
			string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
			$digitalSkeletonA = $diffdigitalSkeleton;
			$AllCurveZ = $newCurves1;
			ArrayInsertAtEnd( $AllCurveZ, $newCurves2[0]);
			ArrayInsertAtEnd( $AllCurveZ, $newCurves2[1]);
		}
		//////////////////
		///////////////PROBLEMS HERE ####################
		int $ONEspaceLOC = 0;
		string $newCurves1[];
		if (size($MakespaceLocatorZSE) == 1){
			$ONEspaceLOC = 1;
			print "MakespaceLocatorZSE_is_ONE";
			string $subsetsA[];
			$subsetsA = `sets -q $SEspaceLocSetofSetz`;
			string $subsetsB[]; string $subsetsB2[];
			$subsetsB = `sets -q $subsetsA`;
			$subsetsB2[0] = $subsetsB[0];
			$subsetsB3[0] = $subsetsB[1];
			string $SetItemA = ($subsetsB2[0]);
			string $SetItemB = ($subsetsB3[0]);
			string $subsetItemNeeded[];
			int $setATrueFalse = `gmatch $SetItemA "*->*"`;
			int $setBTrueFalse = `gmatch $SetItemB "*->*"`;
			if ($setATrueFalse == 1){
				$subsetItemNeeded[0] = $subsetsB2[0];
			}else{ $subsetItemNeeded[0] = $subsetsB3[0]; }
			string $bufferZ[];
			$numTokensX = `tokenize $subsetItemNeeded[0] "->"  $bufferZ`;
			string $CurveLOCZ[] =  {$bufferZ[1]};
			string $paramANDCurveA02[];
			$paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ  )`;
			string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA02[0]`;
			delete $subsetsB[0];
			string $newCurves1[];
			for ($each in $detachCurve1){
				string $newCurve;
				$newCurve = `rename $each Curve`;
				ArrayInsertAtEnd( $newCurves1, $newCurve);
			}
			string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
			$INarrayA = $objectLayerCurvesRange;
			ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
			ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
			string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
			$digitalSkeletonA = $diffdigitalSkeleton;
			RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
			delete $AllparamlocatorZ; 
		}
		if ( size($MakespaceLocatorZSE) > 0  ) {
			appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
			string $CurveSelection[]; 
			int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
			int $numCVrealNum = ( $numCVs -1 );
			$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
			$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
			float $EACHCVposAZ[];
			float $EACHCVposBZ[];	
			int $numIntZB = 0;
			string $MakeXBetweenB[];
			for ($eachZA in $CurveSelection) {
				float $eachCVpos[];		
				$eachCVpos = `pointPosition -w ( $eachZA   )`;
				$numIntZB = $numIntZB + 1;
				if ( $numIntZB == 1 ){
					$EACHCVposAZ = $eachCVpos;
				}
				if ( $numIntZB == 2 ){
					$EACHCVposBZ = $eachCVpos;
					$MakeXBetweenB[0] = `curve -d 1 -p $EACHCVposAZ [0] $EACHCVposAZ[1] $EACHCVposAZ[2] -p  $EACHCVposBZ[0] $EACHCVposBZ[1] $EACHCVposBZ[2]  -k 0 -k 2 -n                        XCurveBetweenB`;
					rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 1 -tol 0.001  $MakeXBetweenB[0];
					appendStringArray($digitalSkeletonA,  $MakeXBetweenB, 1);
				}
			}
			wire -gw false -en 1.000000 -ce 0.000000 -li  1.000000 -w $MakeXBetweenB[0] -dds 0 50.000000  $rebuildit[0];

			string $CurveSelection[]; 
			int $numCVs = `getAttr -size ($MakeXBetweenB[0] +  ".controlPoints")`;
			int $numCVrealNum = ( $numCVs -1 );
			$CurveSelection[0] = ($MakeXBetweenB[0] + ".cv [0]") ;			
			$CurveSelection[1] = ($MakeXBetweenB[0] + ".cv["  + $numCVrealNum + "]") ;
			float $EACHCVposAZ[];
			float $EACHCVposBZ[];	
			int $numIntZB = 0;
			for ($eachZA in $CurveSelection) {
				float $eachCVpos[];		
				$eachCVpos = `pointPosition -w ( $eachZA   )`;
				$numIntZB = $numIntZB + 1;
				if ( $numIntZB == 1 ){
					$EACHCVposAZ = $eachCVpos;
				}
				if ( $numIntZB == 2 ){
					$EACHCVposBZ = $eachCVpos;
				}
			}
			int $ZEROorONEA;
			int $ZEROorONEB;
			string $locZSE0[];
			string $locZSE1[];
			int $foundAZ0;
			int $foundBZ0;
			int $foundAX1;
			int $foundBX1;
			int $i = 0;
			int $iX = 0;
			float $eachCVpos1[];
			float $eachCVpos2[];
			float $movePIVOT1[];
			float $movePIVOT2[];
			if (size($MakespaceLocatorZSE) == 1){	 $i = 1; }
			if (size($MakespaceLocatorZSE) == 2){ 	 $iX = 2; }
			if (( $i == 1) || ( $iX == 2)){
				$locZSE0[0] = $MakespaceLocatorZSE[0];
				$eachCVpos1 = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
				if ( $iX == 2){
					$locZSE1[0] = $MakespaceLocatorZSE[1];
					$eachCVpos2 = `pointPosition -w  ($MakespaceLocatorZSE[1])`;
				}
				if (( $i == 1) || ( $iX == 2)) {
					$ZEROorONEA = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos1);
					if ( $ZEROorONEA == 0){ $movePIVOT1 =  $eachCVpos1; print "cv ZERO"; }
					if ( $ZEROorONEA == 1){ $movePIVOT1 =  $eachCVpos1; print "cv LAST"; }
					if ( $iX == 2){
						$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos2);
						if ( $ZEROorONEB == 0){ $movePIVOT2 =  $eachCVpos2; print "cv ZERO"; }
						if ( $ZEROorONEB == 1){ $movePIVOT2 =  $eachCVpos2; print "cv LAST"; }
						move -ws $movePIVOT2[0] $movePIVOT2[1]  $movePIVOT2[2] $CurveSelection[$ZEROorONEB];
					}
					move -ws $movePIVOT1[0] $movePIVOT1[1]  $movePIVOT1[2] $CurveSelection[$ZEROorONEA];
				}
				delete -ch $rebuildit;
				RemoveNoLongerExistingFromArray ($digitalSkeletonA);
				if (size($digitalSkeletonA) > 0){
					delete $digitalSkeletonA; }
			}
		}
		///////////////////////////////////////////////// ////////////////////////////
		int $CVsZeroAndLast;
		if ( size($MakespaceLocatorZSE) > 0  ) {
			if ( `objExists ZEdgeCurvesSet` == 1  ) {
				//Flattening X to Zero
				if ( $ONEspaceLOC == 0  ) {
					int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
					int $edgeZsetB = `sets -im ZEdgeCurvesSet  $AllCurveZ[1]`;
					$CVsZeroAndLast = FindIfCurveISonZ($rebuildit);
					if (($edgeZsetA == 1) && ($edgeZsetB == 1)){
						print "Intersects edgeZset Curves";
						string $CurveSelectionZ[];
						int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
						int $numCVrealNum = ( $numCVs -1 );	
						$CurveSelectionZ[0] = ($rebuildit[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;
						if ($CVsZeroAndLast == 2){
							string $CurveSelectionX[];
							$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
							for ($eachZA in $CurveSelectionX) {
								float $eachCVpos[];		
								$eachCVpos = `pointPosition -w ( $eachZA   )`;
								move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
							}
						}
						xform -cp;
					}
				}
			}
		}

		ResetTranslation($rebuildit);
		select -r $rebuildit;
		string $ParentArc[];
		$ParentArc = Strait_ARC_or_FreeForm($rebuildit,  5.5, 2.5 );
		if($CVsZeroAndLast < 2)  {
			select -r $ParentArc;
			MirrorANDrename($ParentArc);
		}
		if ( $CVsZeroAndLast > 0){ 
			sets -include ZEdgeCurvesSet $ParentArc;
		}
		//delete $rebuildit;
		ArrayInsertAtEnd( $INarrayA, $ParentArc[0]);
		////////////////////////////////ADDON
		ResetTranslation($ParentArc);
		editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $ParentArc;
		select -r $ParentArc[0];
		EvalAddingCurves;
		////////////////////TRIGGER###################### #######////////////////
		EvalcreatSphere;
		////////////////////TRIGGER###################### #######////////////////
	}
	RemoveNoLongerExistingFromArray ($digitalSkeletonA);
	if (size($digitalSkeletonA) > 0){
		delete $digitalSkeletonA;
	}
	RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
	if (size($AllparamlocatorZ) > 0){
		delete $AllparamlocatorZ;
	} 
	if ( `objExists $SEspaceLocSetofSetz` == 1  ) { 	
		select -r -ne $SEspaceLocSetofSetz;
		delete;
	}
	EVALCamScripts;
	//END of "If elses"
}
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
//###############_END_########################### #
proc float[] EulerAngleofTwoPoints(float  $EACHCVposAZ[], float $EACHCVposBZ[]){
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	if ( $MagVectorZ1 > $MagVectorZ2 ){
		print (" posA is Higher " + "\n");
		$EACHCVposHigher = $EACHCVposAZ;
		$EACHCVposLower = $EACHCVposBZ;
	}
	if ( $MagVectorZ1 < $MagVectorZ2  ){
		print (" posB is Higher " + "\n");
		$EACHCVposHigher = $EACHCVposBZ;
		$EACHCVposLower = $EACHCVposAZ;
	}
	float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
	float $vector_SubUnitMagVec2[];
	$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
	///////////////////////////////////////////////// ////
	float $curveArclenZ  = PointsGetDistanceFLOAT ($EACHCVposAZ, $EACHCVposBZ);
	float $DivideIt  = $curveArclenZ / 2.0;
	float $DivideIt2  = $DivideIt * -1;
	float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
	float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
	/// NOTE curve ENds will not allways Line up and  may be inverted
	//let $F1 be the first CV $F2 the last .. $F3  third point
	int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
	if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
	float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1]     $vector_SubUnitMagVec2[2]`;
	float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1]     $vector_SubUnitMagVec1[2]`;
	return $EulerAngleA;
}
proc float[] getYrotationOFcam(){
	float $CamerasDirectionVector[] ;
	float $CamerasPositionz[];
	float $CamLengthVector[];
	//============================================
	float $CamerasDirectionVector[] =  nurbsViewDirectionVector(0);
	//============================================ ;)  nurbsViewDirectionVector =====
	string $currPanel = `getPanel -withFocus` ,  $camera ;
	string $Camera = `modelEditor -q -camera  $currPanel`;
	$CamerasPositionz = `camera -q -position  $Camera`;
	float $CP[] = $CamerasPositionz;
	$CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);
	float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
	float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
	float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);
	return $CamEulerAngle;
}
proc float[] getXrotationOfCam(){
	float $CamerasDirectionVector[] ;
	float $CamerasPositionz[];
	float $CamLengthVector[];
	//============================================
	float $CamerasDirectionVector[] =  nurbsViewDirectionVector(0);
	//============================================ ;)  nurbsViewDirectionVector =====
	string $currPanel = `getPanel -withFocus` ,  $camera ;
	string $Camera = `modelEditor -q -camera  $currPanel`;
	$CamerasPositionz = `camera -q -position  $Camera`;
	float $CP[] = $CamerasPositionz;
	$CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);
	float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
	float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
	float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);
	float $CamEulerAngleX[] = EulerAngleofTwoPoints ($CamLengthVector, $CP);
	//cross is needed
	return $CamEulerAngle;
}
proc float magF(float $AnglePointA[]){
	vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
	float $AnglePointB = mag($AngleP);
	return $AnglePointB;
}
proc float[] multiplyFloat(float  $posA, float $posB[]){
	float $AddposA_AND_posB_float[];
	$TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
	return $TimesposA_AND_posB_float;
}
proc float [] unitF(float $AnglePointA[]){
	vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
	float $AnglePointB[] = unit($AngleP);
	return $AnglePointB;
}
proc float [] RotPoint(float $posF[], float $Ax[], float $Ndegrees){
	vector $myVec = << $posF[0], $posF[1], $posF[2] >>;
	vector $Axis = << $Ax[0], $Ax[1], $Ax[2] >>;
	vector $rot_Vec = rot($myVec, $Axis, $Ndegrees);
	float $Roatation[] = $rot_Vec;
	return $Roatation;
}
/*
-40.829 
-40.829 18.8 0.0
proc float[] getYrotationOFcam(){
float $CamerasDirectionVector[] ;
float $CamerasPositionz[];
float $CamLengthVector[];
//============================================
float $CamerasDirectionVector[] =  nurbsViewDirectionVector(0);
//============================================ ;)  nurbsViewDirectionVector =====
string $currPanel = `getPanel -withFocus` ,  $camera ;
string $Camera = `modelEditor -q -camera  $currPanel`;
$CamerasPositionz = `camera -q -position  $Camera`;
float $CP[] = $CamerasPositionz;
float $One[] ={1, 1, 1};
float $Zero[] ={0, 0, 0};
$CamLengthVector = AddFloats ($CamerasDirectionVector, $CP);
//print $CamerasDirectionVector;
//print unitF $CamerasDirectionVector;
float $magCam = `magF $CP`;
vector $UnitVecMagZ[] =  MagTimesUnitVecs($CP,  $CamLengthVector);
float $UnitVectorMagF[] = $UnitVecMagZ[0];
float $vector_SubUnitMagVec1[];
float $UnitDirectionFloatA[] = SubtractFloats ($CamLengthVector,$UnitVectorMagF); 
Loc $UnitDirectionFloatA;
float $UnitpointXY[] = {0.0, $UnitDirectionFloatA[1], $UnitDirectionFloatA[2]};
float $UnitpointY[] = {$UnitDirectionFloatA[0],  0.0, $UnitDirectionFloatA[2]};
Loc $UnitpointXY;
Loc $UnitpointY;
float $UnitHightZY = $UnitpointXY[1]
Loc $CP;
Loc $CamLengthVector;
//float $Direction[] = DirectionTwoPoints($CamLengthVector, $CP);
float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
float $CamEulerAngleNiiX[] = {$CP[0], 0.0, $CP[2]};
float $CamHightZYPlain[] = {0.0, $CP[1], 0.0};
float $HightZY = $CP[1];
Loc $CamEulerAngleN;
//The same Bottom
Loc $CamEulerAngleNi;
Loc $CamEulerAngleNiiX;
///////////////////////////////////////////////// ////
float $CamEulerAngleN1[] = { 0.0, $CamLengthVector[1], $CamLengthVector[2]};
// Result: 0 18.89263 20.698596 // 
float $CamEulerAngleNi1[] = { 0.0, $CamerasPositionz[1], $CamerasPositionz[2]};
// Result: 0 18.238829 19.982298 // 
float $CamEulerAngleN2i[] = {0.0,  0.0, $CamLengthVector[2]};
Loc $CamEulerAngleN1 ;
Loc $CamEulerAngleN2i ;
float $Zero[] ={0, 0, 0};
float $CamEulerAngleX[] = EulerAngleofTwoPoints ($CamEulerAngleN1, $Zero);
float $CamEulerAngleN2[] = { 0.0, $CamLengthVector[1], $CamLengthVector[2]};
float $CamEulerAngleNi2[] = { 0.0, $CamerasPositionz[1], $CamerasPositionz[2]};
float $CamEulerAngleN[] = {$CamLengthVector[0],  0.0, $CamLengthVector[2]};
//This one is the floor rotate this point the degrees in Y
float $CamEulerAngleNi[] = {$CamerasPositionz[0],  0.0, $CamerasPositionz[2]};
float $CamEulerAngleA[] = EulerAngleofTwoPoints ($CamEulerAngleN1, $CamEulerAngleNi1);
float $CamEulerAngleB[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);
float $CamEulerAngleBNeg = $CamEulerAngleB[1] *-1;
float $EulerAngleBRad = deg_to_rad($CamEulerAngleB[1]);
float $EulerAngleBRadN = deg_to_rad($CamEulerAngleBNeg);
float $Ax[] = { 0, 1, 0};
float $CamHightZYPlain[] = {0.0, $CP[1], 0.0};
float $HightZY = $CP[1];
float $RotationPointUnit[] = RotPoint($UnitpointY, $Ax, $EulerAngleBRadN);
$RotationPointUnit = `MakeCleanFloats $RotationPointUnit`;
Loc $RotationPointUnit;
float $RotationPoint[] = RotPoint($CamEulerAngleNi, $Ax, $EulerAngleBRadN);
$RotationPoint = `MakeCleanFloats $RotationPoint`;
///###
float $AnglePointUnitA[] = {0.0, $UnitHightZY, $RotationPointUnit[2]};
Loc $AnglePointUnitA;
//////////////////////////////////////////
float $AnglePointA[] = {0.0, $HightZY, $RotationPoint[2]};
vector $AngleP = << $AnglePointA[0], $AnglePointA[1], $AnglePointA[2] >>;
float $AnglePointB[] = unit($AngleP);
float $AnglePointC[] = AddFloats ($AnglePointB, $AnglePointA);
float $CamEulerAngleX[] = EulerAngleofTwoPoints ($AnglePointUnitA, $Zero);
float $CamEulerAngleX[] = EulerAngleofTwoPoints ($AnglePointA, $AnglePointC);
Loc $CamEulerAngleNi;
Loc $RotationPoint;
Loc $AnglePointA;
float $CamEulerAngle[] = EulerAngleofTwoPoints ($CamEulerAngleN, $CamEulerAngleNi);
print $CamEulerAngleX;
print " ";
print $CamEulerAngle;
Loc ($CamEulerAngleN);
//RotPoint(float $posF[], float $Ax[], float $Ndegrees)
//cross is needed
return $CamEulerAngle;
}
*/
proc float [] GetAngleEulerBetween(float $pointA[], float $pointB[]){
	float $AngleEuler[] = `angleBetween -euler -v1 $pointA[0] $pointA[1] $pointA[2] -v2 $pointB[0] $pointB[1] $pointB[2]`;
	return $AngleEuler;
}
// -39.649 
///////////////////////////////
//float $CamEulerAngleA[] = `getYrotationOFcam`;
//SetRotations($objectSet, $CamEulerAngleA);
//string $objectSet[];
//$objectSet = `ls -sl`;
////////////////////////////////
////////////////////////////////
proc int ZplainFlatten(){
	int $Y = 0;
	float $CamEulerAngle[] = `getYrotationOFcam`;
	float $CamEulerAngleY = `abs $CamEulerAngle[1]`;
	if ($CamEulerAngleY < 22.0){
		$Y = 1; 
		print "Less then 22";
	}
	return $Y;
}
///////////////////////////////
//string $objectSet[];
//$objectSet = `ls -sl`;
//float $CurveEulerAngleA[] = `EulerAngleofCurve`;
//SetRotations($objectSet, $CurveEulerAngleA);
////////////////////////////////
proc setRotationAxisFloat(string $objectitem1[], float $rotationsA[]){
	//
	select -cl  ;
	string $groupRotAX;
	$groupRotAX = `group -w -em -n RotAxiz`; xform - os -piv 0 0 0 $groupRotAX;
	string $itemB = $objectitem1[0];
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB;
	setAttr ($groupRotAX+".rotate") $rotationsA[0]  $rotationsA[1] $rotationsA[2];
	parent -absolute $itemB $groupRotAX;
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $itemB; parent -w $itemB;
	delete $groupRotAX;
}
proc float[] EulerAngleTwoPts(vector $vectorZ1,vector $vectorZ2){
	float $EACHCVposAZ[] = $vectorZ1;
	float $EACHCVposBZ[] = $vectorZ2;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[]=$vectorZ1;
	float $EACHCVposLower[]=$vectorZ2;
	if ( $MagVectorZ1 > $MagVectorZ2 ){
		print (" posA is Higher " + "\n");
		$EACHCVposHigher = $EACHCVposAZ;
		$EACHCVposLower = $EACHCVposBZ;
	}
	if ( $MagVectorZ1 < $MagVectorZ2  ){
		print (" posB is Higher " + "\n");
		$EACHCVposHigher = $EACHCVposBZ;
		$EACHCVposLower = $EACHCVposAZ;
	}
	float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
	float $vector_SubUnitMagVec2[];
	$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
	///////////////////////////////////////////////// ////
	float $curveArclenZ = distance2Pts($vectorZ1, $vectorZ2);
	float $DivideIt  = $curveArclenZ / 2.0;
	float $DivideIt2  = $DivideIt * -1;
	float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
	float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
	/// NOTE curve ENds will not allways Line up and  may be inverted
	//let $F1 be the first CV $F2 the last .. $F3  third point
	int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
	if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
	float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1] $vector_SubUnitMagVec2[2]`;
	float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1] $vector_SubUnitMagVec1[2]`;
	print $EulerAngleB;
	return $EulerAngleA;
}
proc float[] EulerAngleofCurve(){
	string $CurveItem[];
	$CurveItem = `ls -sl`;
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];	
	int $numIntZB = 0;
	for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){
			$EACHCVposAZ = $eachCVpos;
		}
		if ( $numIntZB == 2 ){
			$EACHCVposBZ = $eachCVpos;
		}
	}
	vector $vectorZ1 = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	vector $vectorZ2 = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	float $MagVectorZ1 = mag($vectorZ1); 
	float $MagVectorZ2 = mag($vectorZ2);
	float $EACHCVposHigher[];
	float $EACHCVposLower[];
	if ( $MagVectorZ1 > $MagVectorZ2 ){
		print (" posA is Higher " + "\n");
		$EACHCVposHigher = $EACHCVposAZ;
		$EACHCVposLower = $EACHCVposBZ;
	}
	if ( $MagVectorZ1 < $MagVectorZ2  ){
		print (" posB is Higher " + "\n");
		$EACHCVposHigher = $EACHCVposBZ;
		$EACHCVposLower = $EACHCVposAZ;
	}
	float $pointCVAB_MidPoint[] = MidPointBetween ($EACHCVposHigher, $EACHCVposLower);
	/////////////////////////////////////
	vector $UnitVectorMagPosHigher[] =  MagTimesUnitVecs($EACHCVposHigher,  $pointCVAB_MidPoint);
	float $vector_SubUnitMagVec1[];
	$vector_SubUnitMagVec1 = SubtractFloats ($EACHCVposHigher,$UnitVectorMagPosHigher[1]); 
	vector $UnitVectorMagPosLower[] =  MagTimesUnitVecs($EACHCVposLower,  $pointCVAB_MidPoint);
	float $vector_SubUnitMagVec2[];
	$vector_SubUnitMagVec2 = SubtractFloats ($EACHCVposLower,$UnitVectorMagPosLower[1]); 
	///////////////////////////////////////////////// ////
	float $curveArclenZ  = `arclen $CurveItem`;
	float $DivideIt  = $curveArclenZ / 2.0;
	float $DivideIt2  = $DivideIt * -1;
	float $pointB1[] = {0.0 , 0.0 , $DivideIt} ;
	float $pointB2[] = {0.0 , 0.0 , $DivideIt2} ;
	/// NOTE curve ENds will not allways Line up and  may be inverted
	//let $F1 be the first CV $F2 the last .. $F3  third point
	int $Z = FindclosetTOcurveENDz($pointB1,  $pointB2, $vector_SubUnitMagVec2);
	if ($Z == 1){ print "new floats"; $pointB1 =  $pointB2; $pointB2 = {0.0 , 0.0 , $DivideIt}; }
	float $EulerAngleA[] = `angleBetween -euler -v1  $pointB1[0] $pointB1[1] $pointB1[2] -v2   $vector_SubUnitMagVec2[0] $vector_SubUnitMagVec2 [1] $vector_SubUnitMagVec2[2]`;
	float $EulerAngleB[] = `angleBetween -euler -v1  $pointB2[0] $pointB2[1] $pointB2[2] -v2  $vector_SubUnitMagVec1[0] $vector_SubUnitMagVec1 [1] $vector_SubUnitMagVec1[2]`;
	return $EulerAngleA;
}
///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ////
proc float[] MidPointBetween(float $loc1[],  float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);
	float $MidPoint[] = {$a , $b , $c};
	return $MidPoint;
}
///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ////
proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
	int $pX = equivalentTol($posA[0], $posB[0],  0.001);
	int $pY = equivalentTol($posA[1], $posB[1],  0.001);
	int $pZ = equivalentTol($posA[2], $posB[2],  0.001);
	int $addedResults = $pX + $pY + $pZ;
	if ($addedResults == 3 ){ print "Points  equivalent"; 
	}
	return $addedResults;
}
///////////////////////////////////////////////// ////
//////////////////////////////////////////
proc vector[] MagTimesUnitVecs(vector  $vectorZFlatYHigher, vector $vectorZFlatYLower){
	float $MagVectorZYHigher = mag ($vectorZFlatYHigher); 
	float $MagVectorZYLower = mag ($vectorZFlatYLower); 
	vector $unitVectormagZYHL[];
	$unitVectormagZYHL[0] = $MagVectorZYHigher *  unit($vectorZFlatYHigher);
	$unitVectormagZYHL[1] = $MagVectorZYLower * unit ($vectorZFlatYLower);
	return $unitVectormagZYHL;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] AppendFloatsZ(float $posA[], float  $posB[], int $XYZ){
	float $AddposA_AND_posB_float[];
	if($XYZ == 0){ $AddposA_AND_posB_float = {$posB [0], $posA[1], $posA[2]} ; }
	if($XYZ == 1){ $AddposA_AND_posB_float = {$posA [0], $posB[1], $posA[2]} ; }
	if($XYZ == 2){ $AddposA_AND_posB_float = {$posA [0], $posA[1], $posB[2]} ; }
	return $AddposA_AND_posB_float;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] CycleFloatsZ(float $posA[], float  $posB[], int $XYZ1, int $XYZ2){
	float $AddposA_AND_posB_float[];
	if(($XYZ1 == 0) && ($XYZ2 == 1)){  $AddposA_AND_posB_float = {$posA[1], $posA[0],  $posA[2]} ; } //01 xy
	if(($XYZ1 == 0) && ($XYZ2 == 2)){  $AddposA_AND_posB_float = {$posA[2], $posB[1],  $posA[0]} ; } //02 xz
	if(($XYZ1 == 1) && ($XYZ2 == 2)){  $AddposA_AND_posB_float = {$posA[0], $posA[2],  $posB[1]} ; } //12 yz
	return $AddposA_AND_posB_float;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] AddFloats(float $posA[], float  $posB[]){
	float $AddposA_AND_posB_float[];
	$AddposA_AND_posB_float = {($posA[0] + $posB[0]),  ($posA[1] + $posB[1]), ($posA[2] + $posB[2])} ;
	return $AddposA_AND_posB_float;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] SubtractFloats(float $posA[], float  $posB[]){
	float $SubtractposA_AND_posB_float[];
	$SubtractposA_AND_posB_float = {($posA[0] -  $posB[0]), ($posA[1] - $posB[1]), ($posA[2] -  $posB[2])} ;
	return $SubtractposA_AND_posB_float;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] multiplyFloat(float  $posA, float $posB[]){
	float $AddposA_AND_posB_float[];
	$TimesposA_AND_posB_float = {($posA * $posB[0]),  ($posA * $posB[1]), ($posA * $posB[2])} ;
	return $TimesposA_AND_posB_float;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] Add_Float_to_3PointFloats(float  $posA, float $posB[]){
	float $AddposA_AND_posB_float[];
	$AddposA_AND_posB_float = {($posA + $posB[0]),  ($posA + $posB[1]), ($posA + $posB[2])} ;
	return $AddposA_AND_posB_float;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] SubtractFloat_to_3PointFloats(float  $posA, float $posB[]){
	float $SubtractposA_AND_posB_float[];
	$SubtractposA_AND_posB_float = {($posA - $posB [0]), ($posA - $posB[1]), ($posA - $posB[2])} ;
	return $SubtractposA_AND_posB_float;
}
//////////////////////////////////////////
proc vector FloatToVec(float $posA[]){
	vector $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
	return $xvex;
}
//////////////////////////////////////////
proc float GetDegreesFromFloat(float $posA[],  float $posB[]){
	vector $xvex = << $posA[0], $posA[1], $posA[2] >>  ;
	vector $yvex = << $posB[0], $posB[1], $posB[2] >>  ;
	float $xy_angle = angle ($xvex, $yvex) ;
	float $Some_degrees = `rad_to_deg $xy_angle`;
	return $Some_degrees; 
}
///////////////////////////////////////////////// ////
proc SetRotations(string $objectSet[], float  $EulerAngleA[]){
	setAttr ($objectSet[0] + ".rotate") $EulerAngleA [0] $EulerAngleA[1] $EulerAngleA[2] ;
}
proc SetTranslations(string $objectSet[], float  $EulerAngleA[]){
	setAttr ($objectSet[0] + ".translate")  $EulerAngleA[0] $EulerAngleA[1] $EulerAngleA[2] ;
}
///////////////////////////////////////////////// ////
///////////////////////////////////////////////// ////
//////////TEST///////////////////////////
//string $ObjectSelectionz[];
//$ObjectSelectionz = `ls -sl`;
//string $curveObject[];
//$curveObject = `ls -sl`;
//float $translationZ[] = `ResetTranslation ($curveObject)`;
//float $EulerAngleCurveObject[] =  `EulerAngleofCurve`;
//SetRotations($ObjectSelectionz,  $EulerAngleCurveObject);
//SetTranslations($ObjectSelectionz,  $translationZ);
//////////////////////////////////////////
//float $pi = 3.141593 ;
//float $pointZero[];
//$pointZero = << 0, 0, 0 >>;
float $Axis_x[];
float $Axis_y[];
float $Axis_z[];
$AxisF_x = << 1, 0, 0 >>;
$AxisF_y = << 0, 1, 0 >>;
$AxisF_z = << 0, 0, 1 >>;
vector $Axis_X = << 1, 0, 0 >>;
vector $Axis_Y = << 0, 1, 0 >>;
vector $Axis_Z = << 0, 0, 1 >>;
//////////////////////////////////////////
proc float GetDistanceBetweenCurveEnds(string  $CurveItem[]){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];	
	int $numIntZB = 0;
	string $MakeXBetweenB[];
	for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){
			$EACHCVposAZ = $eachCVpos;
		}
		if ( $numIntZB == 2 ){
			$EACHCVposBZ = $eachCVpos;
		}
	}
	$dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy =  $EACHCVposAZ[1] - $EACHCVposBZ[1];
	$dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float  $distanceA2; 
	float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
	return $distanceA2; 
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float GetDistancePointPositionFLOAT(string  $objectFirst, string $objectSecond){
	float $pointAZ1[]; float $pointAZ2[];
	if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
		$pointAZ1 = `xform -q -ws - rp ($objectFirst)`;
	} 
	if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
		$pointAZ1 = `xform -q -ws - rp ($objectSecond)`;
	} $dAx = $pointAZ1[0] - $pointAZ2[0];  $dAy = $pointAZ1[1] - $pointAZ2[1];
	$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
	float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
	return $distanceA2; 
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float GetDistanceFLOAT(string $objectFirst,  string $objectSecond){
	float $pointAZ1[]; float $pointAZ2[];
	if (catch($pointAZ1 = `pointPosition -w  ($objectFirst)`)){
		$pointAZ1 = `xform -q -ws - rp ($objectFirst)`;
	} 
	if (catch($pointAZ2 = `pointPosition -w  ($objectSecond)`)){
		print "using Xform"; $pointAZ1 = `xform -q -ws - rp ($objectSecond)`;
	} 
	$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
	$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
	float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
	return $distanceA2; 
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float PointsGetDistanceFLOAT(float  $pointAZ1[], float $pointAZ2[]){
	$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
	$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
	float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
	return $distanceA2; 
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float getDistance(float  $pointAZ1[], float $pointAZ2[]){
	$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
	$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
	float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
	return $distanceA2; 
}
//////////////////////////////////////////
proc float GetDistanceBetweenCurveEnds(string  $CurveItem[]){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];	
	int $numIntZB = 0;
	string $MakeXBetweenB[];
	for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){
			$EACHCVposAZ = $eachCVpos;
		}
		if ( $numIntZB == 2 ){
			$EACHCVposBZ = $eachCVpos;
		}
	}
	$dAx = $EACHCVposAZ[0] - $EACHCVposBZ[0]; $dAy =  $EACHCVposAZ[1] - $EACHCVposBZ[1];
	$dAz = $EACHCVposAZ[2] - $EACHCVposBZ[2]; float  $distanceA2; 
	float $distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy  * $dAy) + ($dAz * $dAz) )`;
	return $distanceA2; 
}
//////////////////////////////////////////
proc int ZeroOrONE(string $objectLoc[]){
	string $objectLocZ[];
	$objectLocZ = $objectLoc;
	int $X = size($objectLocZ) -1;
	int $Z = size($objectLocZ);
	int $i = 1;
	int $n = -1;
	int $n2 = 0;
	float $SubtractAB[];
	float $posA[];
	float $posB[];
	int $Zero0rOne = 0;
	for( $i = 0; $i < $X; $i ++ ) {
		$n = $n + 1;
		$Z = $Z - 1;
		$ix = 0;
		$n2 = $n + 1;
		while ($Z > $ix++){
			$posA = `xform -q -wd -translation  $objectLocZ[$n]`;
			$posB = `xform -q -wd -translation  $objectLocZ[$n2]`;
			$n2++;	
			$SubtractAB = SubtractFloats($posA, $posB);
			if (($SubtractAB[0] == 0) && ($SubtractAB[1] ==  0) && ($SubtractAB[2] == 0 )){
				print "yes AB";
				$Zero0rOne = 1;
			}
		}
	}
	return $Zero0rOne;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc MoveObject(float $addfloatVector1[], string  $VectorUnitLoc[] ){
	move -ws $addfloatVector1[0] $addfloatVector1[1]  $addfloatVector1[2] $VectorUnitLoc[0];
}
proc MoveObjectSelection(float $addfloatVector1 []){
	string $VectorUnitLoc[];
	$VectorUnitLoc = `ls -selection`;
	move -ws $addfloatVector1[0] $addfloatVector1[1]  $addfloatVector1[2] $VectorUnitLoc[0];
}
//////////////////////////////////////////
proc float[] GetCurveCVposENDS(string $CurveItem [], int $ix){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];
	float $eachCVpos[];	
	if ($ix == 0){
		$eachCVpos = `pointPosition -w ($CurveSelection[0]  )`;
		return $eachCVpos; }
	if ($ix == 1){
		$eachCVpos = `pointPosition -w ($CurveSelection[1]  )`;
		return $eachCVpos; }
}
//////////////////////////////////////////
//////////////////////////////////////////
//////////////////////////////////////////
// $scriptt_jobNum = `scriptJob -event  DagObjectCreated StraitCurvesSCRIPTZ - compressUndo true -protected`;
//////////////////////////////////////////
//////////////////////////////////////////
proc FlattenCurveToZplain(string $renamed[]){
	string $CurveSelectionZ[];
	int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );	
	$CurveSelectionZ[0] = ($renamed[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;
	string $CurveSelectionX[];
	$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
	for ($eachZA in $CurveSelectionX) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $eachZA   )`;
		move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
	}
}
//////////////////////////////////////////
//////////////////////////////////////////
proc vector[] VecCurveEnds(string $CurveItem[]){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];	
	int $numIntZB = 0;
	for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){
			$EACHCVposAZ = $eachCVpos;
		}
		if ( $numIntZB == 2 ){
			$EACHCVposBZ = $eachCVpos;
		}
	}
	vector $VectorCurveEnds[];
	$VectorCurveEnds[0] = << $EACHCVposAZ [0],$EACHCVposAZ[1], $EACHCVposAZ[2] >> ;
	$VectorCurveEnds[1] = << $EACHCVposBZ[0],  $EACHCVposBZ[1], $EACHCVposBZ[2] >> ;
	return $VectorCurveEnds; 
}
//////////////////////////////////////////
//////////////////////////////////////////
global proc string[] MakeCurveBetweenFloats(float  $posA[], float $posB[]){
	string $ZBetween[];
	$ZBetween[0] = `curve -d 1 -p $posA[0] $posA[1]  $posA[2] -p $posB[0] $posB[1] $posB[2] -k 0 -k 2  -n ZCurveBetween`;
	return $ZBetween;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc float[] MakeCleanFloats(float $FloatZ[]){
	string $POSAe = $FloatZ[0]; string $POSBe =  $FloatZ[1];
	string $POSCe = $FloatZ[2];
	string $nameAe; string $nameBe; string $nameCe;
	$nameAe = `match "e" $POSAe`;
	$nameBe = `match "e" $POSBe`;
	$nameCe = `match "e" $POSCe`;
	int $zeroORZe1 = `gmatch "e" $nameAe`;
	int $zeroORZe2 = `gmatch "e" $nameBe`;
	int $zeroORZe3 = `gmatch "e" $nameCe`;
	if ( $zeroORZe1 == 1){ $FloatZ[0] = 0.0; }
	if ( $zeroORZe2 == 1){ $FloatZ[1] = 0.0; }
	if ( $zeroORZe3 == 1){ $FloatZ[2] = 0.0; }
	return $FloatZ;
}
proc float[] MakeCleanFloatsZ(float $FloatZ[]){
	string $POSAe[] = FloatArrayToStringArray( $FloatZ);
	float $FloatZi[];
	int $index =0;
	for ($eachS in $POSAe){
		string $POSAe = $eachS;
		string $nameAe;
		$nameAe = `match "e" $POSAe`;
		int $zeroORZe1 = `gmatch "e" $nameAe`;
		if ( $zeroORZe1 == 1){ $FloatZi[$index] = 0.0;
		}else{$FloatZi[$index] = $FloatZ[$index];}
		$index++;
	}
	return $FloatZi;
}
///////////////////////////////
proc float [] roundFloatsInt(float $floatNumbZ[]){
	float $floatNumbZi[]= MakeCleanFloatsZ($floatNumbZ);
	float $floatNumbZii[];
	for ($eachF in $floatNumbZi){
		float $One = roundInt($eachF,1.0);
		$floatNumbZii[`size($floatNumbZii)`]= $One;
	}
	return $floatNumbZii;
}
///////////////////////////////////
proc float roundInt(float $val,float $dec){
	if($dec==1){
		$val = $val/10;}
	$sign = `sign $val`;
	float $decB = `pow 10 $dec`;
	$val = (int) (($val + $sign*5/($decB*10)) * $decB);
	float $valB = ($val / $dec);
	if($dec==1){
		$valB = $valB *1;}
	return $valB ;
}
////////////////////////////////////////  
////////////////////////////////////////////
proc float MakeCleanFloat1(float $FloatZ){
	string $POSAe = $FloatZ; 
	string $nameAe; 
	$nameAe = `match "e" $POSAe`;
	int $zeroORZe1 = `gmatch "e" $nameAe`;
	if ( $zeroORZe1 == 1){ $FloatZ = 0.0; }
	return $FloatZ;
}
//////////
//proc float PercentDiff_Curve_to_Arc(float  $arclenghtzARC, float $arclenghtzDRAWN){
///float $PercentA;
//$PercentA = ((float($arclenghtzARC) /  $arclenghtzDRAWN) * (100) );
//return $PercentA;
//}
proc float PercentDiff_Curve_to_Arc(float  $arclenghtzARC, float $arclenghtzDRAWN){
	float $FLOAT1;
	float $FLOAT2;
	if($arclenghtzARC < $arclenghtzDRAWN){
		$FLOAT1 = $arclenghtzARC; $FLOAT2 = $arclenghtzDRAWN;}
	if($arclenghtzARC > $arclenghtzDRAWN){
		$FLOAT1 = $arclenghtzDRAWN; $FLOAT2 = $arclenghtzARC; }
	float $PercentA;
	if($arclenghtzARC == $arclenghtzDRAWN){
		$PercentA = 0;}else{
		$PercentA = ((float($FLOAT1) / $FLOAT2) * (100) ); }
	return $PercentA;
}
///////////////////////////////////////////////// ///////////////////////////////////////////////// ////
proc string[] paramToCurvePts3( string  $locatorShapes[] ){
	string $curveName[];
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
		// Get the parent transform above the locator  shape
		string $parent1[] = `listRelatives -p  $locatorShapes[$i]`;
		string $parent2[] = `listRelatives -p $parent1 [0]`;
		string $parent3[] = `listRelatives -p $parent2 [0]`;		
		$curveName[ size($curveName) ] = $parent3[0];
	}
	return $curveName;
}
proc string[] paramToCurvePts2( string $locatorShapes[] ){
	string $selectionList[];
	string $curveName;
	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
		// Get the parent transform above the locator shape
		string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
		string $parent2[] = `listRelatives -p $parent1[0]`;
		$curveName = $parent2[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;
		string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {
			float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;
			setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];
			string $selectionItem = $curveName + ".u[" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;
			delete $pmm;
		}
	}
	return $selectionList;
}
////////////////////////////////////////////////////////
proc string[] paramToCurvePts( string $locatorShapes[] ){
	string $selectionList[];
	string $curveName;
	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);
	for( $i = 0; $i < $numLocators; $i ++ ) {
		// Get the parent transform above the locator shape
		string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
		string $parent2[] = `listRelatives -p $parent1[0]`;
		$curveName = $parent2[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;
		string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {
			float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;
			setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];
			string $selectionItem = $curveName + ".u["  + "0.0" + ":" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;
			delete $pmm;
		}
	}
	return $selectionList;
}
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
proc string[] tokenizeparam( string $paramANDCurveZ[] ){
	string $selectionList[];
	int $i;
	int $num = size($paramANDCurveZ);
	for( $i = 0; $i < $num; $i ++ ) {
		string $bufferA[];
		$numTokensA = `tokenize $paramANDCurveZ[$i] "." $bufferA`;
		string $selectionItem = $bufferA[0];
		$selectionList[ size($selectionList) ] = $selectionItem;
	}
	return $selectionList;
}
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
proc string[] EvalMoveCurvesTOend(string  $paramANDCurveZ[], string $paramCurveNAMEZ[],  string $paramANDCurve3[], string  $AllparamlocatorZ[],      string   $set){
	int $i;
	int $iX;
	$iX = -1;
	string $SEspaceLocSet;
	int $numparamANDCurveNAMEZ = size ($paramCurveNAMEZ);
	string $MakespaceLocatorSE[],  $MakespaceLocatorEND[], $CurveSelection[],  $MakespaceLocatorSTART[]; 
	float $eachCVposSTART[], $eachCVposEnd[];
	for( $i = 0; $i < $numparamANDCurveNAMEZ;  $i ++ ) {
		float $arclenghtzIntersectZ = `eval("arclen" + "  " + $paramANDCurveZ[$i])`;
		float $arclenghtzALL = `arclen $paramCurveNAMEZ [$i]`;
		int $arclenghtzIntTIMES = ($arclenghtzIntersectZ  * 1000) ;
		int $arclenghtzTOTALnumTIMEZ = ($arclenghtzALL  *1000) ;
		//asume there is only one curve intersect
		int $PercentA;
		$PercentA = ((float($arclenghtzIntTIMES) /  $arclenghtzTOTALnumTIMEZ) * (100) );
		if (( $PercentA > 85 ) || ( $PercentA < 15 )){
			int $numCVs = `getAttr -size ($paramCurveNAMEZ [$i] + ".controlPoints")`;
			int $numCVrealNum = ( $numCVs -1 );
			$CurveSelection[0] = ($paramCurveNAMEZ[$i] +  ".cv[0]") ;			
			$CurveSelection[1] = ($paramCurveNAMEZ[$i] +  ".cv[" + $numCVrealNum + "]") ;
			if ( $PercentA > 85 ) { 
				// move to curve end
				$MakespaceLocatorEND = `spaceLocator -p 0 0 0 -n  SEspaceLocatorEND3DZ`;		
				$eachCVposEND = `pointPosition -w  ($CurveSelection[1])`;
				move  -ws $eachCVposEND[0] $eachCVposEND[1]  $eachCVposEND[2] $MakespaceLocatorEND[0];
				appendStringArray($MakespaceLocatorSE,  $MakespaceLocatorEND, 1);
			}
			if ( $PercentA < 15 ) { 
				$MakespaceLocatorSTART = `spaceLocator -p 0 0 0  -n SEspaceLocatorSTART3DZ`;	
				$eachCVposSTART = `pointPosition -w  ($CurveSelection[0])`;
				move  -ws $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2] $MakespaceLocatorSTART;
				appendStringArray($MakespaceLocatorSE,  $MakespaceLocatorSTART, 1);
			}
		}
		if (( $PercentA < 85 ) && ( $PercentA > 15 )){
			$iX = $iX +1;
			select -cl;
			print $AllparamlocatorZ[$i];
			print ("_____not near ends_____" + "\n");
			string $setName = ("SEisnotLocSESet"+$iX);
			$SEspaceLocSet = `sets -name $setName`;
			sets -include $SEspaceLocSet $paramANDCurve3[$i];
			sets -include $SEspaceLocSet $AllparamlocatorZ [$i];
			sets -include $set $SEspaceLocSet;
		}
	}
	return $MakespaceLocatorSE;
}
proc float GET_AREA_OF_CURVE (string $obj[]){
	float $area = 0;
	float $centroid[] = `xform -q -ws -t ($obj[0])`;
	string $CurveItemA = $obj[0];
	string $numcvnames[] = `ls -fl ($CurveItemA+".cv [*]")`; 
	int $numcvs = size($numcvnames);
	for ($iC=0;$iC<$numcvs;$iC++){
		if ($iC<($numcvs-1)){
			string $cvname0 = $obj[0] + ".cv[" + $iC +  "]";
			string $getpos0 = "pointPosition " +  $cvname0;
			float $pos0[] = `eval $getpos0`;
			string $cvname1 = $obj[0] + ".cv[" + ($iC+1)  + "]";
			string $getpos1 = "pointPosition " +  $cvname1;
			float $pos1[] = `eval $getpos1`;
			$pos0 = `MakeCleanFloats($pos0)`;
			$pos1 = `MakeCleanFloats($pos1)`;
			float $aP = `distanceBetween {$centroid [0],$centroid[1],$centroid[2]} {$pos0[0],$pos0 [1],$pos0[2]}`;
			float $bP = `distanceBetween {$pos0 [0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1 [2]}`;
			float $cP = `distanceBetween {$pos1 [0],$pos1[1],$pos1[2]} {$centroid[0],$centroid [1],$centroid[2]}`;
			float $triarea = 0.25* sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  );
			clear $pos0;
			clear $pos1;
			$area = $area + $triarea;
		} else{
			string $cvname0 = $obj[0] + ".cv[" + $iC +  "]";
			string $getpos0 = "pointPosition " +  $cvname0;
			float $pos0[] = `eval $getpos0`;
			string $cvname1 = $obj[0] + ".cv[" + ($iC+1)  + "]";
			string $getpos1 = "pointPosition " +  $cvname1;
			float $pos1[] = `eval $getpos1`;
			$pos0 = `MakeCleanFloats($pos0)`;
			$pos1 = `MakeCleanFloats($pos1)`;
			float $aP = `distanceBetween {$centroid [0],$centroid[1],$centroid[2]} {$pos0[0],$pos0 [1],$pos0[2]}`;
			float $bP = `distanceBetween {$pos0 [0],$pos0[1],$pos0[2]} {$pos1[0],$pos1[1],$pos1 [2]}`;
			float $cP = `distanceBetween {$pos1 [0],$pos1[1],$pos1[2]} {$centroid[0],$centroid [1],$centroid[2]}`;
			float $triarea = 0.25* sqrt ( ($aP+$bP+$cP)  * ($bP+$cP-$aP) * ($cP+$aP-$bP) * ($aP+$bP-$cP)  );
			clear $pos0;
			clear $pos1;
			$area = $area + $triarea;
		}
	}
	clear $numcvnames;
	return $area;
}
proc string[]  Make_Middle_of_Curve_ParamlocatorZ002(string  $objectCurveSelected[]){
	float $arclenghtzALL = `arclen  $objectCurveSelected`;
	float $arclenghtzDivide = $arclenghtzALL / 2.0;
	float $arclenghtzDivideROUNDED =  `RoundfloatingPointoff($arclenghtzDivide)`;  
	int $numCVs = `getAttr -size  ($objectCurveSelected[0] + ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($objectCurveSelected[0] +  ".cv[0]") ;			
	$CurveSelection[1] = ($objectCurveSelected[0] +  ".cv[" + $numCVrealNum + "]") ;
	int $numCVrealNumDivide = $numCVrealNum / 2; 
	if ($numCVrealNumDivide > 2){ $numCVrealNumDivide  = $numCVrealNumDivide -1; } 
	float $arclenghtzHalf = `arclen  ($objectCurveSelected[0] + ".u[0.0:" +  $numCVrealNumDivide + "]")`;
	float $arclenghtzHalfROUNDED =  `RoundfloatingPointoff($arclenghtzHalf)`; 
	float $iz = 0.0; int $M;
	if ( $arclenghtzDivideROUNDED >  $arclenghtzHalfROUNDED){
		print "Greater_then"; $M = 0;  $iz = 0.01;}
	if ( $arclenghtzDivideROUNDED <  $arclenghtzHalfROUNDED){
		print "Less_then"; $M = 1; $iz = -0.01;}
	$paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" +  $numCVrealNumDivide + "]");
	float $iX = float($numCVrealNumDivide); 
	int $i = 1;
	while ($i > 0){
		$iX = $iX + $iz;
		setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $iX;
		string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
		float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
		float $arclenghtzparamZROUNDED =  `RoundfloatingPointoff($arclenghtzparamZ)`;
		if($M == 0){
			if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED >  $arclenghtzDivideROUNDED)){
				$i = 0; }
		}
		if($M == 1){
			if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED <  $arclenghtzDivideROUNDED)){
				$i = 0; }
		}
	}
	float $posA[];
	float $posB[];
	float $posC[];
	$posA = `pointPosition -w $CurveSelection[0]`;
	$posB = `pointPosition -w $paramlocatorZARC[0]`;
	$posC = `pointPosition -w $CurveSelection[1]`;
	string $CircularArcFromCurve[];
	$CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
	setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
	setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
	setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
	setAttr ($CircularArcFromCurve[0] + ".d") 3;
	setAttr ($CircularArcFromCurve[0] + ".s") 8;
	string $ArcCurve[];
	$ArcCurve[0] = `createNode nurbsCurve` ; 
	connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
	//delete $objectCurveSelected; 
	string $ParentArc[];
	$ParentArc = `listRelatives -parent $ArcCurve`;
	ResetTranslation($ParentArc);
	string $ArcZ[];
	$ArcZ[0] = `rename $ParentArc  $objectCurveSelected`; 
	delete $paramlocatorZARC;
	select -r $ArcZ;
	return $ArcZ; 
}
proc ResetTranslationEach(string $oneItemz[]){
	for ($each in $oneItemz){
		xform -cp $each;
		vector $worldPos = `xform -q -ws -rp  $each`;
		move -rpr 0 0 0 $each;
		makeIdentity -apply true  -t 1 -r 0 -s 0 $each;
		xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $each;
	}
}
///////////////////////////////////////////////// //////////////////////////////////////////
///////////////////////////////////////////////// //////////////////////////////////////////
proc string[] CompareCurveIntersect (string  $objectLoc[]){
	string $objectLocZ[];
	string $CurveintersectZ;
	string $ItemLists[];
	$objectLocZ = $objectLoc;
	int $X = size($objectLocZ) -1;
	int $Z = size($objectLocZ);
	int $i = 1;
	int $n = -1;
	int $n2 = 0;
	for( $i = 0; $i < $X; $i ++ ) {
		$n = $n + 1;
		$Z = $Z - 1;
		$ix = 0;
		$n2 = $n + 1;
		while ($Z > $ix++){	
			$CurveintersectZ = `curveIntersect -ch 0 - tolerance 0.001 $objectLocZ[$n] $objectLocZ[$n2] `;
			if (size($CurveintersectZ) > 0) {	
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n]);
				ArrayInsertAtEnd( $ItemLists, $objectLocZ[$n2]);
			} else { print "no Intersect"; }
			$n2++;
		}
	}
	return $ItemLists;
}
///////////////////////////////////////////////// //////////////////////////////////////////
///////////////////////////////////////////////// //////////////////////////////////////////
proc float RoundfloatingPointoff(float  $floatingPointNumZ){
	int $roundoff = $floatingPointNumZ *100;
	float $roundoff2 = float($roundoff) * 0.01;
	return $roundoff2;
}
///////////////////////////////////////////////// //////////////////////////////////////////
///////////////////////////////////////////////// //////////////////////////////////////////
proc float[]  Make_Middle_of_Curve_ParamlocatorFloat(string  $objectCurveSelected[]){
	float $arclenghtzALL = `arclen  $objectCurveSelected`;
	float $arclenghtzDivide = $arclenghtzALL / 2.0;
	float $arclenghtzDivideROUNDED =  `RoundfloatingPointoff($arclenghtzDivide)`;   
	$paramlocatorZARC[0] = eval("paramLocator " +   $objectCurveSelected[0] + ".u[" + 0.00 + "]");
	float $iX = 0.00; 
	int $i = 1;
	string $posALL[];
	float $posB[];
	while ($i > 0){
		$iX = $iX + 0.01;
		setAttr ( $paramlocatorZARC[0] +  ".localPositionX") $iX;
		string $paramANDCurve[] = `paramToCurvePts(  $paramlocatorZARC )`;
		float $arclenghtzparamZ = `eval("arclen" + " " +  $paramANDCurve[0])`;
		float $arclenghtzparamZROUNDED =  `RoundfloatingPointoff($arclenghtzparamZ)`;
		if (($arclenghtzparamZROUNDED ==  $arclenghtzDivideROUNDED) ||  ($arclenghtzparamZROUNDED >  $arclenghtzDivideROUNDED)){
			$i = 0;
		}
	}
	$posB = `pointPosition -w  $paramlocatorZARC[0]`;
	delete $paramlocatorZARC;
	return $posB ; 
}
///////////////////////////////////////////////// //////////////////
proc float[] MidPoint(float $loc1[],  float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);
	float $vPoint[] = {$a , $b , $c};
	return $vPoint;
}
///////////////////////////////////////////////// //////////////////
///////////////////////////////////////////////// //////////////////
proc float[] MidPointBetween(float $loc1[],  float $loc2[]) {
	float $a = ($loc2[0] + $loc1[0]) * (0.5);
	float $b = ($loc2[1] + $loc1[1]) * (0.5);
	float $c = ($loc2[2] + $loc1[2]) * (0.5);
	float $MidPoint[] = {$a , $b , $c};
	return $MidPoint;
}
///////////////////////////////////////////////// //////////////////
proc float distanceBetween(float $loc1[], float  $loc2[]) {
	float $a = `pow ($loc2[0] - $loc1[0]) 2`;
	float $b = `pow ($loc2[1] - $loc1[1]) 2`;
	float $c = `pow ($loc2[2] - $loc1[2]) 2`;
	float $distance = `sqrt ( $a+$b+$c )`;
	return $distance;
}
proc float distanceBetweenS() {
	string $s[] = `ls -sl`;
	float $loc1[] = `pointPosition -w  $s[0]`;
	float $loc2[] = `pointPosition -w  $s[1]`;
	float $a = `pow ($loc2[0] - $loc1[0]) 2`;
	float $b = `pow ($loc2[1] - $loc1[1]) 2`;
	float $c = `pow ($loc2[2] - $loc1[2]) 2`;
	float $distance = `sqrt ( $a+$b+$c )`;
	return $distance;
}
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////
// string $objectA[0] = `ls -sl`;
// MirrorANDrename($objectA);
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// //////////////////////////////////////////
proc MirrorANDrename(string $objectA[]){
	ResetTranslation($objectA);
	float $posA[];	
	$posA = `xform -q -os -translation   $objectA[0]`;
	xform -ws -pivots 0 $posA[1] $posA[2];
	duplicate -rr -renameChildren $objectA; scale -r  -1 1 1; 
	string $objectDup[] = `ls -sl`;
	int $ifCurvetype = `ISobjectSelectedTypeCurve`;
	string $firstcurveRelativesA1[] = `listRelatives  -shapes $objectDup`;
	int $numa  = `match "[0-9]+" $objectA[0]`;
	string $nameAZ;
	$nameAZ = `match "[a-zA-Z]+" $objectA[0]`;
	string $renamez = ("A" + $nameAZ + $numa + "A");
	string $renameShape = ("A" + $nameAZ + "Shape" +  $numa + "A");
	string $renameitzA[];
	select -r $objectDup[0];
	$renameitzA[0] = `rename $objectDup[0] $renamez`;
	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
	ResetTranslation($renameitzA);
	if ($ifCurvetype == 1){
		string $ArcLOCZ[];
		string $selectedCurve[];
		clear $selectedCurve;
		$selectedCurve = $objectA;
		string $firstcurveRelatives1[];
		$firstcurveRelatives1 = `listRelatives -shapes   $selectedCurve`;
		string $firstcurveConnectionsz2[];
		$firstcurveConnectionsz2 = ` listHistory -future   false -pruneDagObjects true   $firstcurveRelatives1`;
		int $sizeOfConnections = `size ($firstcurveConnectionsz2)`;
		if ($sizeOfConnections > 0){
			string $ArcCURVEnode =   "makeThreePointCircularArc*";
			int $IFArcCurveIStrue = stringArrayGmatch  ($ArcCURVEnode, $firstcurveConnectionsz2);
			if ($IFArcCurveIStrue == 0){
				string $renameitzA[];
				string $renameitzB[];
				//$renameitzA[0] = `rename $objectDup[0]  $renamez`;
				$renameitzB[0] = `rename $firstcurveRelativesA1 [0] $renameShape`;
				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0  $renameitzA;
				ResetTranslation($renameitzA);
			}else if ($IFArcCurveIStrue == 1){ 
				string $ArcCURVEnodeZ[];
				string $firstcurveRelatives3[];
				$ArcCURVEnodeZ =   stringArrayGmatchToArray($ArcCURVEnode,   $firstcurveConnectionsz2);
				$firstcurveRelatives3 = `listHistory -  future 0 -pruneDagObjects 0 $ArcCURVEnodeZ`;
				string $ArcCURVEnodeLOC = "ArcLocator*";
				int $IFArcLOCIStrue = stringArrayGmatch  ($ArcCURVEnodeLOC, $firstcurveRelatives3);
				if ($IFArcLOCIStrue == 1){ 
					$ArcLOCZ = stringArrayGmatchToArray  ($ArcCURVEnodeLOC, $firstcurveRelatives3);
					float $getXLoc = `getAttr ($ArcLOCZ[0]   +".translateX")`;
					float $MirrorXLoc = $getXLoc * -1; 
					string $objectDupLocs[] = `duplicate -rr   $ArcLOCZ[0]`; 
					select -r $objectDupLocs;
					group -w; 
					xform -os -piv 0 0 0;
					scale -r -1 1 1;
					//string $objectLOCDup[] = `listRelatives   $objectDup`; 
					select -r $objectDupLocs;
					//capture trans, rot, and scale of object to   match
					$outmmesh = ($ArcLOCZ[0] + ".translate"); 
					$inmmesh = ($objectDupLocs[0] +   ".translate");
					{
						$connect = `connectAttr -f $outmmesh $inmmesh`;
					}
					select -r $ArcLOCZ;
					string $objectDupLocs2[] = `duplicate -rr   $ArcLOCZ[0]`; 
					setAttr ($objectDupLocs2[0] +".translateX")   $MirrorXLoc;
					parentConstraint -mo -weight 1 $objectDupLocs[0]   $objectDupLocs2[0];
					select -r $objectDupLocs2;
					Make_Middle_of_Curve_ParamlocatorZMirror  ($renameitzA, $objectDupLocs2);
					select -r $objectA ;
				}
			}
		}
	}
}
///////////////////////////////////////////////// //
proc int MatchIsTrue (string $item, string $list[]){
	int $result = false;	
	string $listItem;
	string $ItemA;
	int $XiN = 0;
	string $MatchedItem[];	
	for ($Eachlist in $list) {
		$ItemA = `match "$item" $Eachlist`;
		if ( `gmatch $ItemA $Eachlist` ==  1){
			$result = true;
			if ($result == true ){ $XiN = 1; $MatchedItem =  {$Eachlist};}
			break;	}
	}
	
	return $XiN;
}
///////////////////////////////////////////////// //
proc int FindIfCurveCrossesZ(string $rebuildit[]){
	int $ZeroOneORTwo;
	string $CurveSelection[]; 
	int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];
	$EACHCVposAZ = `pointPosition -w (  $CurveSelection[0]  )`;		
	$EACHCVposBZ = `pointPosition -w (  $CurveSelection[1]  )`;
	string $POSA = $EACHCVposAZ[0];
	string $nameA;
	$nameA = `match "-" $POSA`;
	int $zeroOR1Z = `gmatch "-" $nameA`;
	string $POSB = $EACHCVposBZ[0];
	string $nameB;
	$nameB = `match "-" $POSB`;
	int $zeroOR2Z = `gmatch "-" $nameB`;
	int $ZeroOneORTwo = $zeroOR1Z + $zeroOR2Z;
	string $POSAe = `abs $EACHCVposAZ[0]`;
	string $POSBe = `abs $EACHCVposBZ[0]`;
	string $nameAe;
	$nameAe = `match "e" $POSAe`;
	string $nameBe;
	$nameBe = `match "e" $POSBe`;
	int $zeroOR1Ze = `gmatch "e" $nameAe`;
	int $zeroOR2Ze = `gmatch "e" $nameBe`;
	if (($zeroOR1Ze == 1 ) || ($zeroOR2Ze == 1 )){
		print "is Zero";
		$ZeroOneORTwo = 0;
		print $ZeroOneORTwo;
	}
	return $ZeroOneORTwo;
}
///////////////////////////////////////////////// //
///////////////////////////////////////////////// //
proc int GetDistance(string $objectFirst, string  $objectSecond){
	float $pointAZ1[]; float $pointAZ2[];
	$pointAZ1 = `xform -query -worldSpace - translation ($objectFirst)`;
	$pointAZ2 = `xform -query -worldSpace - translation ($objectSecond)`;
	$dAx = $pointAZ1[0] - $pointAZ2[0]; $dAy =  $pointAZ1[1] - $pointAZ2[1];
	$dAz = $pointAZ1[2] - $pointAZ2[2]; float  $distanceA2; 
	$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
	int $distanceA2roundoff;  
	int $distanceA2roundoff = $distanceA2; 
	return $distanceA2roundoff; 
}
///////////////////////////////////////////////// //
///////////////////////////////////////////////// //
proc string[] CutCurveIFConditionTRUETransitZ (string $rebuildit[]){
	int $XiScaleTimes;
	int $XiScale;
	string $remainingCurve[];
	int $ZeroOneORTwoZ = FindIfCurveCrossesZ ($rebuildit);
	if ($ZeroOneORTwoZ == 1){ 
		float $CURVEAposA[];
		$CURVEAposA = `xform -query -worldSpace  -translation $rebuildit[0]`;
		float $CURVEA_AREA = `GET_AREA_OF_CURVE ($rebuildit)`;
		string $ZcutingplaneZZ[];
		$ZcutingplaneZZ = `nurbsPlane -ch on -o on -po 0  -ax 0 1 0 -w 1 -lr 1 -n "ZcutingplaneZZ"`;
		setAttr "ZcutingplaneZZ.rotateZ" 90;
		$XiScale = GetDistance($rebuildit[0],  $ZcutingplaneZZ[0]);
		$XiScaleTimes = ($XiScale * 3) + $CURVEA_AREA;
		scale -r $XiScaleTimes $XiScaleTimes  $XiScaleTimes $ZcutingplaneZZ;
		string $curveIntersectZ[];
		string $intersectZZCUT[];
		string $iSurfZ[] = `extrude -ch 1 -et 0  -l 0.5 -n AxisSelectionZ ( $rebuildit )`;
		$intersectZZCUT = `intersect -ch 0 -cos 0 -fs 1  -tol 0.001 -name IntersectSURFACZ $iSurfZ[0]  $ZcutingplaneZZ[0]`;
		select -r $intersectZZCUT;
		$curveIntersectZ[0] = `curveIntersect -ch 0 - tolerance 0.00001 $intersectZZCUT $rebuildit[0]`;
		string $buffer[];
		int $numTokensZa;
		string $paramlocatorZ[];
		$numTokensZa = `tokenize $curveIntersectZ[0] " "  $buffer`;
		$paramlocatorZ[0] = `eval("paramLocator " +   $rebuildit[0] + ".u[" + $buffer[1] + "]")`;
		int $X = 0;
		string $paramANDCurve[];
		$paramANDCurve  = `paramToCurvePts2(  $paramlocatorZ)`;
		string $curvesZ[];
		$curvesZ = `detachCurve -ch 1 -cos on -rpo 1  $paramANDCurve`;
		string $curveZ0[];
		$curveZ0[0] = $curvesZ[0];
		string $curveZ1[];
		$curveZ1[0] = $curvesZ[1];
		ResetTranslation($curveZ0);
		ResetTranslation($curveZ1);
		float $EACHCVposAZ[];
		float $EACHCVposBZ[];
		$EACHCVposAZ = `xform -query -worldSpace  -translation ( $curvesZ[0]  )`;		
		$EACHCVposBZ = `xform -query -worldSpace  -translation ( $curvesZ[1]  )`;
		string $POSA = $EACHCVposAZ[0];
		string $nameA;
		$nameA = `match "-" $POSA`;
		int $zeroOR1Z = `gmatch "-" $nameA`;
		string $POSB = $EACHCVposBZ[0];
		string $nameB;
		$nameB = `match "-" $POSB`;
		int $zeroOR2Z = `gmatch "-" $nameB`;
		if ($zeroOR1Z == 1){
			delete $curvesZ[0];
			$X = 1; }
		if ($zeroOR2Z == 1){
			delete $curvesZ[1]; 
			$X = 2;}
		if ($X == 2){
			select -r $curvesZ[0]; }
		if ($X == 1){
			select -r $curvesZ[1]; }
		$remainingCurve = `ls -sl`;
		delete $intersectZZCUT $ZcutingplaneZZ  AxisSelectionZ ; 
	}
	$rebuildit = $remainingCurve;
	return $remainingCurve;
}
///////////////////////////////////////////////// //
///////////////////////////////////////////////// //
proc int FindIfCurveISonZ(string $rebuildit[]){
	string $CurveSelection[];
	int $iZ = 0; 
	int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[];
	float $EACHCVposBZ[];
	$EACHCVposAZ = `pointPosition -w (  $CurveSelection[0]  )`;		
	$EACHCVposBZ = `pointPosition -w (  $CurveSelection[1]  )`;
	string $POSA = $EACHCVposAZ[0];
	string $ScientNotationNameA;
	$ScientNotationNameA = `match "e" $POSA`;
	int $zeroOR1Z = `gmatch "e"  $ScientNotationNameA`;
	if (($EACHCVposAZ[0] == 0) || ($zeroOR1Z == 1)){
		print "yes";
		$iZ = $iZ + 1;
	}
	string $POSB = $EACHCVposBZ[0];
	string $ScientNotationNameB;
	$ScientNotationNameB = `match "e" $POSB`;
	int $zeroOR2Z = `gmatch "e"  $ScientNotationNameB`;
	if (($EACHCVposBZ[0] == 0) || ($zeroOR2Z == 1)){
		print "yes";
		$iZ = $iZ + 1;
	}
	return $iZ;
}
///////////////////////////////////////////////// //
///////////////////////////////////////////////// //
proc PAUSE(){
	playButtonStepForward;
}
///////////////////////////////////////////////// //
///////////////////////////////////////////////// //
proc averagingNode(string $firstObjectz, string  $averageObjectz, string $LastObjectz){
	string $averaging[];
	$averaging[0] = `shadingNode -asUtility  plusMinusAverage`;
	setAttr ($averaging[0] + ".operation") 3;   
	connectAttr -force ( $firstObjectz +  ".translate")($averaging[0] + ".input3D[1]"); 
	connectAttr -force ($averaging[0] + ".output3D") ("|" + $averageObjectz + ".translate");                                         
	connectAttr -force ( $LastObjectz +  ".translate")($averaging[0] + ".input3D[0]"); 
}
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////
proc int ArrayInsertAtEnd( string $INarray[],  string $NewItem){ 
	int $SizeOfArray;
	$SizeOfArray = size($INarray);
	$INarray[$SizeOfArray] = ( $NewItem );
	return $SizeOfArray;
}
///////////////////////////////////////////////// ///////
proc ResetTranslation(string $oneItemz[]){
	xform -cp $oneItemz[0];
	vector $worldPos = `xform -q -ws -rp  $oneItemz[0]`;
	move -rpr 0 0 0  $oneItemz[0];
	makeIdentity -apply true  -t 1 -r 0 -s 0 $oneItemz[0];
	xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $oneItemz[0];
}
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////
proc float[] positionOne(string $eachZA){       	
	float $eachCVpos[] = `pointPosition -w $eachZA`;
	return $eachCVpos;
}
///////////////////////////////////////////////// ///////
////if ( eval("gmatch $list $item") == 1){
//print "yes"; }
// BELOW PROC Gmatches a list of items in an  array to one "thing" like a shortname 
//ALL THE CHARAs in one sting and RETURNS - a  Zero or one
///////////////////////////////////////////////// ///////
proc int stringArrayGmatch(string $item, string  $list[]){
	int $result = false;	
	string $listItem;	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` ==  1){
			$result = true;
			break;	}
	}	
	return $result;
}
///////////////////////////////////////////////// ///////
proc int FindclosetTOcurveENDz(float $a1[], float  $a2[], float $b1[]){
	int $binaryAnswer;
	float $distance1;
	float $distance2;
	float $pointA1[];
	float $pointA2[];
	float $pointB1[];
	float $dAx;
	float $dAy;
	float $dAz;
	$pointA1 = $a1;
	$pointA2 = $b1;
	$dAx = $pointA1[0] - $pointA2[0];
	$dAy = $pointA1[1] - $pointA2[1];
	$dAz = $pointA1[2] - $pointA2[2];
	$distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
	$distance1 = $distanceA;
	$pointB1 = $a2;
	$dAx = $pointB1[0] - $pointA2[0];
	$dAy = $pointB1[1] - $pointA2[1];
	$dAz = $pointB1[2] - $pointA2[2];
	$distanceB = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
	$distance2 = $distanceB;
	if ($distance1 < $distance2){ 
		$binaryAnswer = 0;
		return $binaryAnswer; 
	}
	if ( $distance2 < $distance1 ){
		$binaryAnswer = 1;
		return $binaryAnswer;
	}
}
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////
proc string[] NearestObjectArray(int $n, string $ItemsSelectedinArray[]){
	int $NearestObjectN = $n;
	string $NearestCurvesZ[];
	int $numIntx = `size($NearestCurvesZ)`;
	if ( $numIntx > 0 ){
		clear $NearestCurvesZ;
	}
	string $lastItemInarray[];
	int $size = `size ($ItemsSelectedinArray)`;
	int $TriggerIf = 0;
	if(($size==$n)||($size<$n)) {
		$TriggerIf =1;
		$n = $size -1;
		$NearestObjectN = $n;
	}else{$TriggerIf = 0; }
	if ($TriggerIf == 1){ $lastItemInarray[0]= $ItemsSelectedinArray[$n]; } 
	string $array1[] = $ItemsSelectedinArray;
	string $array2[] = $ItemsSelectedinArray;
	string $arrayMainObject1[] =  $ItemsSelectedinArray;
	string $ArrayTwoObjectX[0];
	int $indexN = 0;
	int $NearestObjectNumbers = $NearestObjectN;
	$ObjN = 0;
	$ObjN2 = 0;
	while($ObjN++ < $NearestObjectNumbers ){
		string $array1Count = (`size ($array1)`) -1;
		int $array1Number = (`size ($array1)`) -1;
		stringArrayRemoveAtIndex($array1Count, $array1);
		string $diff[] = stringArrayRemoveExact($array1,  $arrayMainObject1);
		string $CompareAllShapesCount = `size ($array1)`;
		int $curvenumbers = $CompareAllShapesCount;
		$i = 1;
		while($i++ < $curvenumbers ){
			//DISTANCE A
			float $pointA1[];
			float $pointA2[];
			$pointA1 = `xform -query -worldSpace - translation ( $diff)`;
			$pointA2 = `xform -query -worldSpace - translation ($array1[0])`;
			$dAx = $pointA1[0] - $pointA2[0];
			$dAy = $pointA1[1] - $pointA2[1];
			$dAz = $pointA1[2] - $pointA2[2];
			float $distanceA;
			$distanceA = `sqrt( ($dAx * $dAx) + ($dAy * $dAy)  + ($dAz * $dAz) )`;
			//DISTANCE B
			float $pointB1[];
			float $pointB2[];
			$pointB1 = `xform -query -worldSpace - translation ( $diff)`;
			$pointB2 = `xform -query -worldSpace - translation ( $array1[1])`;
			$dBx = $pointB1[0] - $pointB2[0];
			$dBy = $pointB1[1] - $pointB2[1];
			$dBz = $pointB1[2] - $pointB2[2];
			float $distanceB;
			$distanceB = `sqrt( ($dBx * $dBx) + ($dBy * $dBy)  + ($dBz * $dBz) )`;
			if( $distanceA < $distanceB ){
				stringArrayRemoveAtIndex(1, $array1);
			}
			if( $distanceA > $distanceB ){
				stringArrayRemoveAtIndex(0, $array1);
			}
		}
		appendStringArray($NearestCurvesZ, $array1, 1);
		string $oneitem[];
		$oneitem[0] = $array1[0];
		string $arrayLast[] = stringArrayRemoveExact ($oneitem, $arrayMainObject1);
		$array1 = $arrayLast;
		$array2 = $arrayLast;
		$arrayMainObject1 = $arrayLast;
		$indexN++;
		stringArrayInsertAtIndex(($indexN),  $ArrayTwoObjectX, $arrayLast[0]);
	}
	string $array1[]; 
	clear $array1;
	string $array2[];
	clear $array2;
	string $arrayMainObject1[];
	clear $arrayMainObject1;
	string $return[];
	$return = $NearestCurvesZ;
	if ($TriggerIf == 1){ 
		stringArrayInsertAtIndex( 0, $return, $lastItemInarray[0]);
	} 
	return $return; 
}
///////////////////////////////////////////////// ///////
proc string[] CreateCAMforIntCurveScript(){
	CreateCameraOnly;
	rename ZCURVEModelingCAM;
	lookThroughModelPanelClipped ZCURVEModelingCAM  modelPanel4 0.001 1000;
	nurbsPlane -ch on -o on -po 0 -ax 0 1 0 -w 1 -lr  1 -n "LiveSurfaceB";
	editDisplayLayerMembers -noRecurse  layerYZYXPlains "LiveSurfaceB";
	//////////////////
	string $CamConeLocator[];
	clear $CamConeLocator;
	curve -d 3 -p 0 0 0 -p 0 0 -4 -p 0 0 -8 -p 0 0 - 12 -k 0 -k 0 -k 0 -k 12 -k 12 -k 12 -n  Deletethiscurve ;
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	$objectZcurv = `ls -sl`;
	string $CurveSelection[]; 
	int $numCVs = `getAttr -size ($objectZcurv[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($objectZcurv[0] + ".cv[0]")  ;			
	$CurveSelection[1] = ($objectZcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
	string $each;
	for ($each in $CurveSelection) {
		float $eachCVpos[]; $eachCVpos =  `pointPosition -w ( $each  )`;
		string $MakespaceLocator[]; $MakespaceLocator =  `spaceLocator -p 0 0 0 -n LocatorA`;
		ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
		move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
	}
	string $objectZ[]; clear $objectZ; string  $MakespaceLocator[]; clear $MakespaceLocator ;  
	int $LocatorLoop = 0; int $LocatorLoopA = -1;
	while ($LocatorLoop++ < 7) {
		$LocatorLoopA = $LocatorLoopA +1; 
		if ($LocatorLoopA == 0){
			clear $objectZ; 
			stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
			stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
		}
		if ($LocatorLoopA > 0){
			clear $objectZ; 
			stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
			stringArrayInsertAtIndex(1, $objectZ,  $MakespaceLocator[0]);
		}
		if ($LocatorLoopA < 7){
			$MakespaceLocator = `spaceLocator -p 0 0 0 -n  LocatorMiddleDistance`;
			ArrayInsertAtEnd($CamConeLocator,  $MakespaceLocator[0]);
			averagingNode($objectZ[0], $MakespaceLocator[0],  $objectZ[1]);
		}
	}
	ArrayInsertAtEnd( $CamConeLocator,  $CamConeLocator[0]);
	stringArrayRemoveAtIndex(0, $CamConeLocator);
	parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA1 ;
	parentConstraint -mo -weight 1 ZCURVEModelingCAM  LocatorA;
	delete  Deletethiscurve;
	align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
	move -r -os -wd 0 5 5 ZCURVEModelingCAM ;
	setAttr "ZCURVEModelingCAM.rotateX" -45;
	setAttr "LiveSurfaceB.rotateX" (`getAttr  ("ZCURVEModelingCAM" + ".rotateX")`+90);
	setAttr "LiveSurfaceB.rotateY" `getAttr  ("ZCURVEModelingCAM" + ".rotateY")`;
	setAttr "LiveSurfaceB.rotateZ" `getAttr  ("ZCURVEModelingCAM" + ".rotateZ")`;
	align -atl -x Mid -y Mid -z Mid LiveSurfaceB  ZCURVEModelingCAM;
	move -r -os -wd 0 -0.7 0 LiveSurfaceB ;
	move -r -os -wd 0 0 0.210031 LiveSurfaceB ;
	parentConstraint -mo -weight 1 ZCURVEModelingCAM  LiveSurfaceB;
	setAttr "ZCURVEModelingCAM.translateX" 48 ;
	setAttr "ZCURVEModelingCAM.translateY" 41 ;
	setAttr "ZCURVEModelingCAM.translateZ" 48 ;
	setAttr "ZCURVEModelingCAM.rotateX" -25 ;
	setAttr "ZCURVEModelingCAM.rotateY" 45;
	setAttr "ZCURVEModelingCAM.rotateZ" 0;
	return $CamConeLocator;
}
///////////////////////////////////////////////// ///////
///////////////////////////////////////////////// ///////
proc Removefromsurface(){
	string $curves[] = `ls -sl`;
	string $buffer[];
	$numTokensz = `tokenize $curves[0] "->" $buffer`;
	print $buffer; 
	string $myCurve =  $buffer[1];
	string $CapsNewCurve = capitalizeString ($myCurve);
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $buffer[1];
	if (size($buffer) < 2 ){ $myCurve =  $curves[0];}
	string $CurveSelection[] = `ls -fl  ($myCurve+".cv[*]")`; 
	string $CurveEPzCount = size  ($CurveSelection);
	int $numEPs = size ($CurveSelection);
	print  ($numEPs + "\n"); 
	int $numEPrealNum = ( $numEPs -1 );
	int $numEPrealNum2 = ($numEPrealNum * 1.5); 
	string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
	string $spaceLocatorB[] = `spaceLocator -p 0 0 0  -n LocatorX`; 
	$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position")  ($spaceLocatorB[0] + ".translate")`;
	float $step = $numEPrealNum2;  
	$curve = "curve -d 1";
	int $a;
	for($a = 0; $a <= $step;$a++){
		$t =  $a/$step; 	
		setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t ;

		float $values[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;	
		if (($values[0] == 0.0 ) && ($values[1] == 0.0 )  && ($values[2] == 0.0 )){
			float $values[] = `pointPosition -w  $CurveSelection[$numEPrealNum]`;
			$curve += " -p "+$values[0]+" "+$values[1]+"  "+$values[2];
		} else { $curve += " -p "+$values[0]+" "+$values [1]+" "+$values[2];}
	}
	string $Newcurvez = `eval($curve)`;
	string $Newcurve[] = {$Newcurvez};
	delete $curves;
	delete $paramlocatorpointOnCurvex $spaceLocatorB; 
	string $renamedX = `rename $Newcurve  $CapsNewCurve`;  
	$Newcurve = {$renamedX};
	rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.001 $Newcurve;
	select -r $Newcurve; 
}
proc ExtendCurveAlot(){
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
	extendCurvePresetArgList( "2", {"0",  "1","0","0","100","0","0","0","0","1","1","1"} );
}
////////////////////
proc string[] StartofCurveScriptIntersectZX(){
	Removefromsurface;
	
	string $digitalSkeleton[];
	$numInts = size($digitalSkeleton);
	if ( $numInts > 0 ){
		clear $digitalSkeleton;
	}
	string $objectcurv[];
	$objectcurv = `ls -sl`;
	ResetTranslation($objectcurv);
	///////////////GATHER ALL BUILDING  STRUCTURE/////////##
	appendStringArray($digitalSkeleton, $objectcurv,  1);
	///////////////////////////////////////////////// ////##
	string $CurveSelection[]; 
	int $numCVs = `getAttr -size ($objectcurv[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($objectcurv[0] + ".cv[0]")  ;			
	$CurveSelection[1] = ($objectcurv[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposA[];
	float $EACHCVposB[];	
	string $AllIntersectCurveZ[];
	$numInts = size($AllIntersectCurveZ);
	if ( $numInts > 0 ){
		clear $AllIntersectCurveZ;
	}
	string $IntersectCurves[];
	string $MakeExtrudeSurface[];
	string $MakeBirailSurface[];
	string $MakeXBetween[];
	string $MakeIntersectCurvez[];
	string $MakespaceLocator[];
	string $each;
	for ($each in $CurveSelection) {
		float $eachCVpos[];		
		$eachCVpos = `pointPosition -w ( $each   )`;
		$MakespaceLocator = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
		$MakeIntersectCurvez[0] = makeCurvePointDirectionLength(3000, {1.0, 0.0, 0.0}, {0.0, 0.0, 0.0});
		appendStringArray($AllIntersectCurveZ,  $MakeIntersectCurvez, 1);
		appendStringArray($digitalSkeleton,  $MakespaceLocator, 1);
		$numInts = size($AllIntersectCurveZ);
		move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakespaceLocator[0];
		move  -ws $eachCVpos[0] $eachCVpos[1] $eachCVpos [2] $MakeIntersectCurvez[0];
		aimConstraint -offset 0 0 0 -weight 0.5 - aimVector -1 0 0 -upVector 0 0 -1 -worldUpType  "vector" -worldUpVector 1 0 0 ZCURVEModelingCAM      $MakeIntersectCurvez[0];
		if ( $numInts == 1 ){
			$EACHCVposA = $eachCVpos;
		}
		if ( $numInts == 2 ){
			$EACHCVposB = $eachCVpos;
			$MakeXBetween[0] = `curve -d 1 -p $EACHCVposA[0]  $EACHCVposA[1] $EACHCVposA[2] -p $EACHCVposB[0]  $EACHCVposB[1] $EACHCVposB[2] -k 0 -k 2 -n      XCurveBetween`;
			appendStringArray($digitalSkeleton,  $MakeXBetween, 1);
		}
	}
	$MakeExtrudeSurface = `extrude -ch true -rn 0 -po  0 -et 0 -upn 0 -fixedPath 1 -d 0 0 0 -length 3 - rotation 0 -scale 1 -dl 3 -n CURVEZextrude      $objectcurv` ;
	$MakeBirailSurface = `singleProfileBirailSurface  -ch 1 -po 0 -tm 1 -tp1 0 -n SurfaceinterectCurves  CURVEZextrude.v[0] $AllIntersectCurveZ[0]      $AllIntersectCurveZ[1]`;
	string $curveFromSurfaceDup[] = `duplicateCurve  -ch 1 -rn 0 -local 0  "SurfaceinterectCurves.u [1]"` ;
	string $curveFromSurfaceLoft[] = `loft -ch 1 -u 1  -c 0 -ar 1 -d 3 -ss 4 -rn 1 -po 0 -rsn true -n  IntersectLoftZ $curveFromSurfaceDup[0]      $objectcurv` ;
	// GATHER ALL BUILDING STRUCTURE//
	appendStringArray($digitalSkeleton,  $curveFromSurfaceDup, 1);
	appendStringArray($digitalSkeleton,  $curveFromSurfaceLoft, 1);
	appendStringArray($digitalSkeleton,  $MakeExtrudeSurface, 1);
	appendStringArray($digitalSkeleton,  $MakeBirailSurface, 1);
	appendStringArray($digitalSkeleton,  $AllIntersectCurveZ, 2);
	return $digitalSkeleton; 
}
proc int ArrayInsertAtEnd( string $INarray[],  string $NewItem){ 
	int $SizeOfArray;
	$SizeOfArray = size($INarray);
	$INarray[$SizeOfArray] = ( $NewItem );
	return $SizeOfArray;
}
/////////////////////////////////
proc int SecondArrayInsertAtEndofArray( string  $INarray[], string $NewItem[]){ 
	int $SizeOfArray;
	$SizeOfArray = size($INarray);
	$INarray[$SizeOfArray] = ( $NewItem[0] );
	return $SizeOfArray;
}
proc string[] RemoveNoLongerExistingFromArray (string $EdgeCurveZ1[]){
	int $SizeOfArrayA = size($EdgeCurveZ1);
	if ( $SizeOfArrayA > 0){
		int $SizeOfArray = size($EdgeCurveZ1) -1;
		int $i = -1;
		int $E = -1;
		while( $E < $SizeOfArray ){
			$i++;
			$E++;
			if ( `objExists $EdgeCurveZ1[$i]` == 0  ) {
				stringArrayRemoveAtIndex($i, $EdgeCurveZ1);
				if ($i == 0) { $i = -1;} else { $i = $i -1;}   
			}
		}
		int $SizeOfArrayB = size($EdgeCurveZ1);
	}
	return $EdgeCurveZ1;
}
proc appendMultiStringArray( string  $copyTo[], string $copyFrom1[], string  $copyFrom2[]){
	$numberToCopy1 = size($copyFrom1);
	if( $numberToCopy1 > 0){
		int $i;
		int $j = size($copyTo);
		for( $i = 0; $i < $numberToCopy1; $i++,  $j++ ){
			$copyTo[$j] = $copyFrom1[$i]; }
	}
	$numberToCopy2 = size($copyFrom2);
	if( $numberToCopy2 > 0){
		int $k = size($copyTo);
		for( $i = 0; $i < $numberToCopy2; $i++,  $k++ ){
			$copyTo[$k] = $copyFrom2[$i]; }
	}
}
////////////////////////////////////
proc MoveZSURFACEModelingCAM(string  $ConeLocator[]){
	string $queryIntersectFormLayerA[] =  `editDisplayLayerMembers -q  IntersectFormLayerOutofRange`;
	string $queryIntersectFormLayerB[] =   `editDisplayLayerMembers -q  IntersectFormLayerINRange`  ;
	string $queryIntersectFormLayerC[];
	clear $queryIntersectFormLayerC; 
	appendMultiStringArray(  $queryIntersectFormLayerC,  $queryIntersectFormLayerA,  $queryIntersectFormLayerB );
	print $queryIntersectFormLayerC;
	if (size( $queryIntersectFormLayerC) > 0){
		string $listofallSurfaces[];
		$listofallSurfaces = $queryIntersectFormLayerC;
		string $ObjectsINcamLightCone[];
		string $OutofRange[];
		layerEditorRemoveObjects  IntersectFormLayerINRange ;
		editDisplayLayerMembers -noRecurse "defaultLayer"  $ObjectsINcamLightCone;
		layerEditorRemoveObjects  IntersectFormLayerOutofRange ;
		editDisplayLayerMembers -noRecurse "defaultLayer"  $OutofRange;
		clear $ObjectsINcamLightCone;
		string $objectZ[];
		if (size($objectZ) > 0){ clear $objectZ; }  
		stringArrayInsertAtIndex(0, $objectZ,"LocatorA");
		stringArrayInsertAtIndex(1, $objectZ,  "LocatorA1");
		float $pointA1[];
		float $pointA2[];
		$pointA1 = `xform -query -worldSpace - translation ( $objectZ[0])`;
		$pointA2 = `xform -query -worldSpace - translation ($objectZ[1])`;
		$dAx = $pointA1[0] - $pointA2[0];
		$dAy = $pointA1[1] - $pointA2[1];
		$dAz = $pointA1[2] - $pointA2[2];
		float $distanceAz;
		$distanceAz = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
		int $radiusZ;
		int $distanceAzNUM;
		$distanceAzNUM = $distanceAz;
		$radiusZ = $distanceAzNUM /2;
		int $loopLocatorsCam = 0;
		int $loopA = -1;
		int $z = -1;
		string $currentLocatorZ[];
		while ($loopLocatorsCam++ < 7){
			$loopA = $loopA +1;
			if ($loopA > 0){
				$distanceAzNUM = $radiusZ;
			}
			$radiusZ = $distanceAzNUM /2;
			$z = $z +1;
			string $currentLocatorZ[];
			$currentLocatorZ[0] = $ConeLocator[$z];
			//string all locators in order
			for ($each in $listofallSurfaces) {
				float $pointAZ1[];
				float $pointAZ2[];
				$pointAZ1 = `xform -query -worldSpace - translation ($currentLocatorZ)`;
				$pointAZ2 = `xform -query -worldSpace - translation ($each)`;
				$dAx = $pointAZ1[0] - $pointAZ2[0];
				$dAy = $pointAZ1[1] - $pointAZ2[1];
				$dAz = $pointAZ1[2] - $pointAZ2[2];
				float $distanceA2;
				$distanceA2 = `sqrt( ($dAx * $dAx) + ($dAy *  $dAy) + ($dAz * $dAz) )`;
				if ( $distanceA2 < $radiusZ ){
					stringArrayInsertAtIndex(0,  $ObjectsINcamLightCone, $each);
				}
			}
		}
		string $shorterList[] =  stringArrayRemoveDuplicates ($ObjectsINcamLightCone);
		$ObjectsINcamLightCone = $shorterList;
		$OutofRange = stringArrayRemoveExact ($ObjectsINcamLightCone, $listofallSurfaces);
		editDisplayLayerMembers -noRecurse  IntersectFormLayerOutofRange $OutofRange;
		editDisplayLayerMembers -noRecurse  IntersectFormLayerINRange $ObjectsINcamLightCone;
	}
}
proc LockModelingCAM(){
	setAttr -lock true "ZCURVEModelingCAM.tx";
	setAttr -lock true "ZCURVEModelingCAM.ty";
	setAttr -lock true "ZCURVEModelingCAM.tz";
	setAttr -lock true "ZCURVEModelingCAM.rx";
	setAttr -lock true "ZCURVEModelingCAM.ry";
	setAttr -lock true "ZCURVEModelingCAM.rz";
}
proc UnLockModelingCAM(){
	setAttr -lock false "ZCURVEModelingCAM.tx";
	setAttr -lock false "ZCURVEModelingCAM.ty";
	setAttr -lock false "ZCURVEModelingCAM.tz";
	setAttr -lock false "ZCURVEModelingCAM.rx";
	setAttr -lock false "ZCURVEModelingCAM.ry";
	setAttr -lock false "ZCURVEModelingCAM.rz";
}
proc int stringArrayMatch(string $item, string  $list[]){
	int $result = false;	
	string $listItem;
	string $listMatch;	
	for ($listItem in $list) {
		$listMatch = `match $item $listItem`;
		if ( size($listMatch) > 0){
			$result = true; break; }
	}	
	return $result;
}
//////////////////////////////////////////
//////////////////////////////////////////
proc int ISobjectSelectedTypeCurve2(){
	int $result = false;	
	string $C[];
	$C = `ls -sl`;
	string $nametypeZ[] = `ls -showType $C`;
	string $names1 = "curve";
	string $names2 = "Curve";
	string $names3 = "cv";
	string $names4 = "ep";
	int $zeroOR1A = stringArrayMatch($names1,  $nametypeZ);
	int $zeroOR1B = stringArrayMatch($names2,  $nametypeZ);
	int $zeroOR1C = stringArrayMatch($names3,  $nametypeZ);
	int $zeroOR1D = stringArrayMatch($names4,  $nametypeZ);
	int $zeroOR1B = stringArrayMatch($names1,  $nametypeZ);
	if (( $zeroOR1A == 1) || ( $zeroOR1B == 1)){
		if (( $zeroOR1C == 1) || ( $zeroOR1D == 1)){
			$result = false;
		} else { $result = true; }
	}
	return $result;
}
//-conditionTrue
//$scriptt_jobNum = `scriptJob -conditionTrue  ISobjectSelectedTypeCurve2 -compressUndo true - protected`;
//////////////////////////////////////////
proc int ISobjectSelectedTypeCurve(){
	string $C[];
	$C = `ls -sl`;
	string $nametypeZ[] = `ls -showType $C`;
	string $nameA;
	$nameA = `match "[a-zA-Z]+" $nametypeZ[0]`;
	int $zeroOR1Z = `gmatch "Curve" $nameA`;
	print $zeroOR1Z;
	return $zeroOR1Z;
}
//SWITCH///////////////////////////////////////// //////////////////////
global string $proc =  "StartofCurveScriptIntersectXYZ;";
proc stringsStart(){
	string $stringsStart = ("global string $proc = "  +"\"StartofCurveScriptIntersectXYZ;"+"\";");
	eval( $stringsStart );
	print $stringsStart;
}
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
proc stringsA(){
	string $stringsA = ("global string $proc = "  +"\"EvalDrawCurveDisConnectA;"+"\";");
	eval( $stringsA );
}
proc stringsB(){
	string $stringsB = ("global string $proc = "  +"\"EvalDrawCurveDisConnectB;"+"\";");
	eval( $stringsB );
}
proc stringsC(){
	string $stringsC = ("global string $proc = "  +"\"RUNprojectTAN;"+"\";");
	eval( $stringsC );
}
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
///////////////////////////////////////////////// ////////////////
proc EvalStart(){
	evalDeferred start; }
proc start(){
	stringsStart; }
///////////////////////////////////////////////// ////////////////
proc StartofCurveScriptIntersectXYZ(){
	string $deleteLiveCurveShape;
	string $deleteLiveCurve;
	int $firstcurveswitch;
	string $objectcurV[];
	clear $objectcurV;
	$objectcurV = `ls -sl`;
	ResetTranslation($objectcurV);
	string $objectSelection[] = { "Zcurvez",  "Xcurvez" };
	string $oneSelection[];
	clear $oneSelection;
	for ($each in $objectSelection) {
		int $ISTRUE03B = catchQuiet($intersectCurveZ03 =  `curveIntersect -ch 0 -ud 0 -tol 0.01 $objectcurV  $each`);
		int $numIntZ03 = size($intersectCurveZ03);
		if (($ISTRUE03B > 0) || ($numIntZ03 > 0))  {
			stringArrayInsertAtIndex(0, $oneSelection,  $each);
		}
	}
	int $getSize = size ($oneSelection);
	if ( $getSize > 1){
		print "wrong";
		//run once scriptjob... JUst run again
		$firstcurveswitch = 0;
	}
	if ( $getSize == 1){
		if ( `gmatch $oneSelection[0] "Zcurvez"` == 1){ 
			print "Zcurvez";
			$firstcurveswitch = 1;
		}
		if ( `gmatch $oneSelection[0] "Xcurvez"` == 1){ 
			print "Zcurvez";
			$firstcurveswitch = 2;
		}
	}
	switch($firstcurveswitch) {
	case 0:
		print "wrong";
		delete $objectcurV;
		EvalStart;
		break;
	case 1:
		select -r Zplane;
		rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 98 -du 3 -sv 98 -dv 3 -tol 0.001  -fr 0  -dir 2 "Zplane";
		select -cl  ;
		select -r Zplane;
		PAUSE;
		select -cl  ;
		PAUSE;
		select -r Zplane;
		PAUSE;
		select -cl  ;
		rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 1 -du 3 -sv 1 -dv 3 -tol 0.001 - fr 0  -dir 2 "Zplane";
		makeLive Zplane;
		delete $objectcurV;
		stringsA;
		break;
	case 2:
		select -r Xplane;
		rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 98 -du 3 -sv 98 -dv 3 -tol 0.001  -fr 0  -dir 2 "Xplane";
		select -cl  ;
		select -r Xplane;
		PAUSE;
		select -cl  ;
		PAUSE;
		select -r Xplane;
		PAUSE;
		select -cl  ;
		rebuildSurface -ch 0 -rpo 1 -rt 6 -end 1 -kr 2 - kcp 0 -kc 1 -su 1 -du 3 -sv 1 -dv 3 -tol 0.001 - fr 0  -dir 2 "Xplane";
		makeLive Xplane;
		delete $objectcurV;
		string $deleteLiveCurveShape;
		$deleteLiveCurveShape = "XplaneShape- >drawCurveShape";
		string $deleteLiveCurve;
		$deleteLiveCurve = "XplaneShape->drawCurve";
		stringsB;
		break;
	}
}
////////////////////////
proc DrawCurveDisConnectA(int $xii){
	global string $EdgeCurveZ2[];
	global int $xii;
	int $xi = $xii;
	rename drawCurve;
	duplicateCurve -ch 1 -rn 0 -local 0 ;
	rename drawCurveA;
	if ($xi == 0 ){
		DeleteHistory ZplaneShape->drawCurveShape;
		delete ZplaneShape->drawCurveShape;
		delete ZplaneShape->drawCurve;
	}
	string $Renamed1[];
	string $Renamed2[];
	$Renamed1[0] = `rename drawCurveA Curve`;
	ResetTranslation($Renamed1); 
	if ( `gmatch $Renamed1[0] "Curve"` == 1){
		$Renamed2[0] = `rename $Renamed1 Curve0`;
		$Renamed1 = $Renamed2;
	}
	ResetTranslation($Renamed1); 
	select -r $Renamed1;
	string $ParentArc[];
	$ParentArc = `Make_Middle_of_Curve_ParamlocatorZ ($Renamed1)`;
	delete $Renamed1;
	rename $ParentArc $Renamed1;
	sets -include ZEdgeCurvesSet $Renamed1;
	select -r ZEdgeCurvesSet;
	editDisplayLayerMembers -noRecurse  layerAllCurves1 $Renamed1;
	CurveIndexVecTracking($Renamed1);
	evalEdgecurvesZ2;
	EvalAddingCurves;
	RUNMoveZCURVEM;
	eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
	eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");
	makeLive LiveSurfaceB ;
	stringsC;
}
proc DrawCurveDisConnectB(int $xii){
	global string $EdgeCurveZ2[];
	global int $xii;
	int $xi = $xii;
	rename drawCurve;
	duplicateCurve -ch 1 -rn 0 -local 0 ;
	rename drawCurveA;
	if ($xi == 0 ){
		DeleteHistory XplaneShape->drawCurveShape;
		delete XplaneShape->drawCurveShape;
		delete XplaneShape->drawCurve;
	}
	string $Renamed1[];
	string $Renamed2[];
	$Renamed1[0] = `rename drawCurveA Curve`; 
	ResetTranslation($Renamed1); 
	int $trueORfalse = FindIfCurveCrossesZ ($Renamed1);
	print $trueORfalse;
	if ( $trueORfalse == 1){ 
		CutCurveIFConditionTRUETransitZ($Renamed1); }
	select -r $Renamed1;
	string $rebuildfirstcurve[];
	$rebuildfirstcurve = `rebuildCurve -ch 0 -rpo 1  -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 16 -d 3  -tol 0.001 $Renamed1`;
	string $ParentArc[];
	$ParentArc = `Make_Middle_of_Curve_ParamlocatorZ ($rebuildfirstcurve)`;
	print $ParentArc;
	delete $Renamed1;
	rename $ParentArc Curve;
	$ParentArc = {"Curve"};
	$Renamed1 = $ParentArc;
	if ( $trueORfalse == 1){ 
		sets -include ZEdgeCurvesSet $ParentArc;
	}
	if ( `gmatch $Renamed1[0] "Curve"` == 1){
		$Renamed2[0] = `rename $Renamed1 Curve0`;
		$Renamed1 = $Renamed2;
	}
	MirrorANDrename($Renamed1);
	editDisplayLayerMembers -noRecurse  layerAllCurves1 $Renamed1;
	CurveIndexVecTracking($Renamed1);
	select -r $Renamed1;
	evalEdgecurvesZ2;
	EvalAddingCurves;
	RUNMoveZCURVEM;
	eval(" $jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
	eval(" $jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");
	makeLive LiveSurfaceB ;
	stringsC;
}
/////////////////////
proc EvalDrawCurveDisConnectA(){
	eval("DrawCurveDisConnectA($xii);");
}
proc EvalDrawCurveDisConnectB(){
	eval("DrawCurveDisConnectB($xii);");
}
proc int ifCurveToolsCTX1(){
	string $whichCtx;
	$whichCtx = `currentCtx`;
	string $list[] = { "pencilContext"};   
	int $result = false;	
	string $listItem;
	string $listMatch;	
	for ($listItem in $list) {
		$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
			$result = true; break; }
	}	
	return $result;
}
///////////////
///////////////
proc int ifCurveToolsCTX2(){
	string $whichCtx;
	$whichCtx = `currentCtx`;
	string $list[] = {"curveContextEP",  "curveAddPtContext"};   
	int $result = false;	
	string $listItem;
	string $listMatch;	
	for ($listItem in $list) {
		$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
			$result = true; break; }
	}	
	return $result;
}
//
proc int ifCurveToolsCTX3(){
	string $whichCtx;
	$whichCtx = `currentCtx`;
	string $list[] = {"threePointArcContext"};   
	int $result = false;	
	string $listItem;
	string $listMatch;	
	for ($listItem in $list) {
		$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
			$result = true; break; }
	}	
	return $result;
}
///////////////
proc int ifCurveToolsCTX4(){
	string $whichCtx;
	$whichCtx = `currentCtx`;
	string $list[] = {"selectSuperContext",  "moveSuperContext", "lassoSelectContext",  "RotateSuperContext",
		"scaleSuperContext", "xformManipContext",  "softModContext" };   
	int $result = false;	
	string $listItem;
	string $listMatch;	
	for ($listItem in $list) {
		$listMatch = `match $whichCtx $listItem`;
		if ( size($listMatch) > 0){
			$result = true; break; }
	}	
	return $result;
}
/////////////////////////////////////
proc EvalAutoCurvesScripts(){
	int $IsCurveToolSelected1 = `ifCurveToolsCTX1`;
	if ($IsCurveToolSelected1 == 1){
		eval("$xii = 0;");
		eval("EVALKILLjobB ($scriptt_jobAllCurvesToolsNumB);");
		EvalAllCurvesTools; }
	int $IsCurveToolSelected2 = `ifCurveToolsCTX2`;
	if ($IsCurveToolSelected2 == 1){
		eval("$xii = 0;");
		eval("EVALKILLjobA ($scriptt_jobAllCurvesToolsNumA);");
		EvalAllCurvesTools2;
	}
	int $IsCurveToolSelected3 = `ifCurveToolsCTX3`;
	if ($IsCurveToolSelected3 == 1){
		eval("$xii = 1;");
		eval("EVALKILLjobA ($scriptt_jobAllCurvesToolsNumA);");
		EvalAllCurvesTools2;
	}
	int $IsCurveToolSelected4 = `ifCurveToolsCTX4`;
	if ($IsCurveToolSelected4 == 1){
		setAttr layerYZYXPlains.visibility 0;
		string $itemsCurrentlySelectedZ[] = `ls -sl`;
		select -cl  ;
		makeLive;
		select -r $itemsCurrentlySelectedZ; 
	} 
	if ($IsCurveToolSelected4 == 0){
		string $queryCURVESz[] =  `queryLayerRangeMembers`;
		if  (size($queryCURVESz) > 0){
			setAttr layerYZYXPlains.visibility 1;
			makeLive LiveSurfaceB;
		}
	}
}
///////////////
proc AutoCurveScripts(){
	int $ifCond_is_True =  `ISobjectSelectedTypeCurve2`;
	if ($ifCond_is_True == 1){
		//   This is just the curve script you need this  to be where the switch is
		eval"evalEcho($proc);";
	}
}
proc AutoCurveScripts2(){
	EvalKillToolChangedNum1;
	EvalCurveToolChanged2;
	evalDeferred("$script_jobToolChangedNum1 =  `scriptJob -event ToolChanged  EvalAutoCurvesScripts`;");
}
proc EvalAllCurvesTools(){
	eval("int $scriptt_jobAllCurvesToolsNumA =  `scriptJob -event DagObjectCreated  AutoCurveScripts -compressUndo true -protected  `;");
}
proc EvalAllCurvesTools2(){
	eval("int $scriptt_jobAllCurvesToolsNumB =  `scriptJob -event DagObjectCreated  AutoCurveScripts2 -compressUndo true -protected  `;");
}
proc EvalCurveToolChanged2(){
	eval("int $script_jobToolChangedNum2 = `scriptJob  -runOnce 1 -event ToolChanged  AutoCurveScripts`;");
}
proc EVALKILLjobA(int  $scriptt_jobAllCurvesToolsNumA ){
	if (! $scriptt_jobAllCurvesToolsNumA == 0  ) {
		EvalKilljobAllCurvesToolsNumA; }
}
proc EVALKILLjobB(int  $scriptt_jobAllCurvesToolsNumB ){
	if (! $scriptt_jobAllCurvesToolsNumB == 0  ) {
		EvalKilljobAllCurvesToolsNumB; }
}
proc EvalKilljobAllCurvesToolsNumA(){
	eval("scriptJob -kill  $scriptt_jobAllCurvesToolsNumA -force;");
}
proc EvalKilljobAllCurvesToolsNumB(){
	eval("scriptJob -kill  $scriptt_jobAllCurvesToolsNumB -force;");
}
proc EvalKillToolChangedNum1(){
	eval("scriptJob -kill $script_jobToolChangedNum1  -force;");
}
proc EvalRUNToolChangedNum1(){
	eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
}
proc RUNprojectTAN(){
	$runitA = "AdvancedCurveMODprojectTAN ($EdgeCurveZ2, $plainNum);";
	eval($runitA);
}
proc RUNMoveZCURVEM(){
	int $script_jobNumIdle_MoveZCURVEM = `scriptJob   -runOnce 1 -event idle EVALCamScripts`;
}
proc int addNumbers(){
	int $CreatedObjectCurve =  `ISobjectSelectedTypeCurve`;
	return $CreatedObjectCurve; 
}
proc int addedNumbers(int $addNumbersA){
	int $numerOfCreatedCurve = `addNumbers`;
	int $numerOfCreated = $numerOfCreatedCurve; 
	if ($numerOfCreated == 1){
		int $addNumberZ = $addNumbersA +  $numerOfCreatedCurve;
		$addNumbersA = $addNumberZ;
		print $addNumbersA;
	}
	return $addNumbersA;
}
proc EvalAddingCurves(){
	$runitA = "$addNumbersA = addedNumbers ($addNumbersA);";
	eval($runitA);
}
proc EvalcreatSphere(){
	$runitA = "creatSphere($addNumbersA);";
	eval($runitA);
}
proc evalEdgecurvesZ2(){
	eval("$EdgeCurveZ2 = `editDisplayLayerMembers -q  layerAllCurves1`;");
}
proc creatSphere(int $addNumbersA ){
	int $x = $addNumbersA;
	print ($addNumbersA + "\n");
	if ($x == 10){
		//LockModelingCAM;
		print "FOUR CURVES";
		MakeAutoBoundryUI;
	}
}
proc makeSurfaceAndclose(string $dialogBoxWin){
	eval("deleteUI $dialogBoxWin;");
	eval("int  $script_jobNumIdle_KILLtanCurveRUNautoboundry =  `scriptJob  -runOnce 1 -event idle  KILLtanCurveRUNautoboundry`;");
	eval("$addNumbersA = 0;");
}
proc SkipAutoBoundry(string $dialogBoxWin){
	eval("deleteUI $dialogBoxWin;");
	eval("$addNumbersA = 0;");
}
global proc MakeAutoBoundryUI(){
	global string $dialogBoxWin;
	$dialogBoxWin = `window 
	- title "JFS AutoBoundry" 
	-resizeToFitChildren true 
	-interactivePlacement 
	-toolbox true`;
	columnLayout -adjustableColumn true;
	nodeIconButton -style "iconAndTextHorizontal"
	-label "Make Surface From Curve Network"
	-width 90
	-height 40
	-image1 "skin.xpm"
	-command "makeSurfaceAndclose($dialogBoxWin)";
	string $button2 = `nodeIconButton -style  "textOnly"
	-label "Skip"
	-width 60
	-height 30
	-marginWidth 5
	-command "SkipAutoBoundry($dialogBoxWin)"`;
	showWindow $dialogBoxWin;
	eval("$dialogBoxWin = $dialogBoxWin;");
}
proc KILLtanCurveRUNautoboundry(){
	eval("scriptJob -kill $jobNumtranslateCAM - force;");
	eval("scriptJob -kill $jobNumrotateCAM -force;");
	eval("scriptJob -kill $script_jobToolChangedNum1  -force;");
	evalDeferred AutoBoundry2010;
}
proc TRIGGER_RUNjobNumTAN(){
	eval("$script_jobToolChangedNum1 = `scriptJob - event ToolChanged EvalAutoCurvesScripts`;");
	eval("$jobNumtranslateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.translate  RUNMoveZCURVEM`;");
	eval("$jobNumrotateCAM = `scriptJob - attributeChange ZCURVEModelingCAM.rotate  RUNMoveZCURVEM`;");
}
//////////////////////////////////
//////////////
proc string[] queryLayerRangeMembers(){
	string $query[];
	string $queryOutofRangeLayer[];
	string $queryINRangeLayer[];
	$queryOutofRangeLayer = `editDisplayLayerMembers  -q layerCurvesOutofRange1`;
	$queryINRangeLayer = `editDisplayLayerMembers -q  layerCurvesINRange1`;
	if (size($queryOutofRangeLayer) > 0){
		appendStringArray($query,  $queryOutofRangeLayer, size ($queryOutofRangeLayer));
	}
	if (size($queryINRangeLayer) > 0){
		appendStringArray($query, $queryINRangeLayer,  size($queryINRangeLayer));
	}  
	return $query;
}
proc BOUNDRYeveryNthCurve(){
	string $everyFirstCurveShapeset[];
	string $query[];
	clear $query;
	string $queryOutofRangeLayer[];
	string $queryINRangeLayer[];
	$queryOutofRangeLayer = `editDisplayLayerMembers  -q layerCurvesOutofRange1`;
	$queryINRangeLayer = `editDisplayLayerMembers -q  layerCurvesINRange1`;
	if (size($queryOutofRangeLayer) > 0){
		appendStringArray($query,  $queryOutofRangeLayer, size ($queryOutofRangeLayer));
	}
	if (size($queryINRangeLayer) > 0){
		appendStringArray($query, $queryINRangeLayer,  size($queryINRangeLayer));
	}  
	///////////////////////
	$everyFirstCurveShapeset = `ls -assemblies  $query`;
	string $newEdgeCurve[];
	clear $newEdgeCurve;
	select -r $everyFirstCurveShapeset;
	$newEdgeCurve = `AutoBoundryScript ($everyFirstCurveShapeset)`;
	print $newEdgeCurve; 
	layerEditorEmpty layerCurvesINRange1;
	layerEditorEmpty layerCurvesOutofRange1;
	layerEditorEmpty layerEdgeCurveZ1;
	editDisplayLayerMembers -noRecurse  layerEdgeCurveZ1 $newEdgeCurve;
	eval("$EdgeCurveZ2 = `editDisplayLayerMembers -q  layerEdgeCurveZ1`;");
	UnLockModelingCAM;
	evalDeferred TRIGGER_RUNjobNumTAN;
}
proc string[] AutoBoundryScript(string  $everyFirstCurveShapeset[]){
	string $EdgeCurveZ[];
	string $EdgeCurveZ2[];
	clear $EdgeCurveZ2;
	string $EdgeCurveZ3[];
	string $newallCurves[];
	$newallCurves = $everyFirstCurveShapeset;
	string $ZnewfoundEdge[];
	for ( $Zeachboundry in $newallCurves ) {
		string $ZselectedCurve[];
		clear $ZselectedCurve;
		$ZselectedCurve[0] = $Zeachboundry;
		string $ZfirstcurveRelatives[];
		$ZfirstcurveRelatives = `listRelatives -shapes  $ZselectedCurve`;
		string $ZfirstcurveConnectionsz[];
		$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
		string $Zfirstcurveshapes[];
		$Zfirstcurveshapes = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
		if (size($Zfirstcurveshapes) == 1){
			appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
		}
		if (size($Zfirstcurveshapes) == 0){
			appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
		}
	}
	$everyFirstCurveShapeset = $ZnewfoundEdge; 
	int $everycurveSize = size ($everyFirstCurveShapeset);
	while( size($everyFirstCurveShapeset) > 3 ){ 
		int $everycurveSizeIndex = size ($everyFirstCurveShapeset) -1;
		string $FirstCurvesZ[];
		$FirstCurvesZ[0] = $everyFirstCurveShapeset [$everycurveSizeIndex];
		string $firstcurveRelatives[];
		$firstcurveRelatives = `listRelatives -shapes  $FirstCurvesZ`;
		string $firstcurveConnectionsz[];
		$firstcurveConnectionsz = `listConnections  $firstcurveRelatives`;
		string $firstcurveshapes[];
		$firstcurveshapes = `listConnections -shapes 1  $firstcurveConnectionsz`;
		string $firstcurveConn[] = stringArrayRemove ($firstcurveRelatives, $firstcurveshapes);
		int $numberofconnections = size($firstcurveConn);
		if ( $numberofconnections >= 2 ) {
			stringArrayRemoveAtIndex($everycurveSizeIndex,  $everyFirstCurveShapeset);
			int $everycurveSizeIndex = size ($everyFirstCurveShapeset) -1;
			string $FirstCurvesZ[];
			$FirstCurvesZ[0] = $everyFirstCurveShapeset [$everycurveSizeIndex];
		}
		int $everycurveSize = size ($everyFirstCurveShapeset);
		int $divide;
		int $switchNumber;
		if (( $everycurveSize < 1000 ) && (  $everycurveSize >= 500 )){
			$divide = $everycurveSize / 50;
			$switchNumber = 0; 
			print $divide;}
		if (( $everycurveSize < 500 ) && (  $everycurveSize >= 250 )){
			$divide = $everycurveSize / 25; 
			$switchNumber = 0;}
		if (( $everycurveSize < 250 ) && (  $everycurveSize >= 100 )){
			$divide = $everycurveSize / 12; }
		if (( $everycurveSize < 100 ) && (  $everycurveSize >= 50 )){
			$divide = $everycurveSize / 5; 
			$switchNumber = 0;}
		if (( $everycurveSize < 50 ) && ( $everycurveSize  >= 20 )){
			$divide =$everycurveSize / 4; 
			$switchNumber = 0;}
		if (( $everycurveSize < 20 ) && ( $everycurveSize  > 18 )){
			$divide = $everycurveSize / 2;
			$switchNumber = 0;
			print $divide;
		}
		if ( $everycurveSize <= 18 ){
			$switchNumber = 1;
		}
		int $n;
		switch($switchNumber) 
		{
		case 0:
			int $n = $divide;
			string $NearestCurvesZ[] =  (NearestObjectArray($n,  $everyFirstCurveShapeset));
			int $n2 = $n * 2;
			string $NearestCurvesZn2[] =  (NearestObjectArray($n2,  $everyFirstCurveShapeset));
			break;
		case 1:
			string $NearestCurvesZ[] =  $everyFirstCurveShapeset;
			string $NearestCurvesZn2[] =  $everyFirstCurveShapeset;
			break;
		}
		print $NearestCurvesZ; 
		string $TEMPzCurveAAb[];
		if ( size($TEMPzCurveAAb) > 0){
			clear $TEMPzCurveAAb;
		}
		int $ISTRUE0A1;
		int $numIntZZ;
		for ( $eachZ in $NearestCurvesZ ) {
			int $ISTRUE0A1 = catchQuiet($intersectCurveZ0 =  `curveIntersect -ch 0 -ud 0 -tol 0.01  $FirstCurvesZ $eachZ`);
			int $numIntZZ = size($intersectCurveZ0);
			if (($ISTRUE0A1 > 0) || ($numIntZZ > 0))  {
				stringArrayInsertAtIndex(0, $TEMPzCurveAAb,  $eachZ);
			}
		}
		$NearestCurvesZ = $TEMPzCurveAAb;
		string $TEMPzCurveA[0];
		$numInts2 = size($TEMPzCurveA);
		if ( $numInts2 > 0 ){
			clear $TEMPzCurveA;
		}
		string $diff[];
		if ( size($diff) > 0){
			clear $diff;
		}
		$diff = stringArrayRemove($NearestCurvesZ,  $NearestCurvesZn2);
		int $switchNumberA;
		if( size($diff) == 0 ) {
			clear $everyFirstCurveShapeset;
			clear $NearestCurvesZ; 
			$switchNumberA = 0;
		} else if( size($diff) > 0 ){
			$switchNumberA = 1;
		} 
		if(( size($NearestCurvesZ) == 3 ) &&  ($everycurveSize == 3)) {
			$switchNumberA = 0; }
		switch($switchNumberA) 
		{
		case 0:
			print "done";
			break;
		case 1:
			for ( $eachAB in $diff ) {
				int $ISTRUE0B = catchQuiet($intersectCurveZ1 =  `curveIntersect -ch 0 -ud 0 -tol 0.01  $FirstCurvesZ $eachAB`);
				int $numIntZZZ = size($intersectCurveZ1);
				if (($ISTRUE0B > 0) || ($numIntZZZ > 0))  {
					stringArrayInsertAtIndex(0, $TEMPzCurveA,  $eachAB);
				}
			}
			string $NearestCurvesZA[];
			int $numInts2a;
			$numInts2a = size($NearestCurvesZA);
			if ( $numInts2a > 0 ){
				clear $NearestCurvesZA;
			} 
			$NearestCurvesZA = stringArrayCatenate ($NearestCurvesZ, $TEMPzCurveA);
			$NearestCurvesZ = $NearestCurvesZA;
			string $diffremove[];
			int $numInts2a;
			$numInts2a = size($diffremove);
			if ( $numInts2a > 0 ){
				clear $diffremove;
			} 
			$diffremove = stringArrayRemove($TEMPzCurveA,  $diff);
			string $TEMPAlldiffCurveZBBBB[];
			$numInts = size($TEMPAlldiffCurveZBBBB);
			if ( $numInts > 0 ){
				clear $TEMPAlldiffCurveZBBBB;
			} 
			$TEMPAlldiffCurveZBBBB = $diffremove;
			///////////////////////////////////////////////// /////
			string $diffX[]; clear $diffX; string  $boundaryCurves[]; clear $boundaryCurves; 
			int $numIntxZB; string $OtherCurves[]; clear  $OtherCurves; string $oneboundaryCurve[]; clear  $oneboundaryCurve;
			string $boundaryCurvesAA[]; string  $oneboundaryCurve[]; clear $oneboundaryCurve;
			string $boundaryCurves[]; 
			clear $boundaryCurves;
			string $boundaryCurves1[]; 
			clear $boundaryCurves1;
			int $X = 1;
			int $ENDLOOPA;
			int $i = 1;
			int $ENDLOOP;
			int $B = 0;
			int $ISTRUE0A001;
			int $numIntZZA;
			int $numIntZZAB;
			int $ISTRUE0B002;
			int $endtrigger = 0;
			while (size($NearestCurvesZ) > 0 ){
				if ( $endtrigger == 2 ){ 
					clear $NearestCurvesZ;
					size($NearestCurvesZ); 
				} 
				for ( $each in $NearestCurvesZ ) {
					stringArrayInsertAtIndex(0, $boundaryCurves1,  $each);
					clear $oneboundaryCurve; 
					stringArrayInsertAtIndex(0, $oneboundaryCurve,  $boundaryCurves1[0]);
					$X = 1;
					$ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
					for ( $eachA in $TEMPAlldiffCurveZBBBB ) {
						stringArrayInsertAtIndex(0, $boundaryCurves1,  $each);
						clear $oneboundaryCurve; 
						stringArrayInsertAtIndex(0, $oneboundaryCurve,  $boundaryCurves1[0]);
						int $ISTRUE0A001 = catchQuiet($intersectCurveZ0A  = `curveIntersect -ch 0 -ud 0 -tol 1.0 $each  $eachA`);
						$ENDLOOPA = size($TEMPAlldiffCurveZBBBB);
						$X++;
						int $numIntZZA = size($intersectCurveZ0A);
						if ((($ISTRUE0A001 == 0) && ( $X == $ENDLOOPA))  || (($numIntZZA == 0) && ( $X == $ENDLOOPA))) {
							string $removecurveAz2[];
							$removecurveAz2[0] = $each;
							$NearestCurvesZ = stringArrayRemove ($removecurveAz2, $NearestCurvesZ);
						} else if (($ISTRUE0A001 > 0) || ($numIntZZA >  0)){
							string $diffX[];
							clear $diffX;
							$diffX = stringArrayRemoveExact ($oneboundaryCurve, $NearestCurvesZ);
							$ENDLOOP = size($diffX);
							for ( $eachB in $diffX ) {
								if ( $endtrigger == 2 ){ 
									clear $NearestCurvesZ; } 
								int $ISTRUE0B002 = catchQuiet ($intersectCurveZAB = `curveIntersect -ch 0 -ud 0  -tol 0.001 $eachA $eachB`);
								int $numIntZZAB = size($intersectCurveZAB);
								int $numsizeNearest = size($NearestCurvesZ); 
								if (( $endtrigger == 0 ) && ( $numsizeNearest < 2  )){
									string $removeoneFromeveryFirstA[];
									$removeoneFromeveryFirstA = stringArrayRemove ($FirstCurvesZ, $everyFirstCurveShapeset);
									clear $NearestCurvesZ; }
								if (($ISTRUE0B002 > 0) || ($numIntZZAB >  0)) {
									///////
									string $Intersectboundarycurves[];
									string $myIntersector = `stringArrayIntersector`;
									string $Foundboundarycurves[];
									clear $Foundboundarycurves;
									stringArrayInsertAtIndex(0, $Foundboundarycurves,  $FirstCurvesZ[0]);
									stringArrayInsertAtIndex(0, $Foundboundarycurves,  $each);
									stringArrayInsertAtIndex(0, $Foundboundarycurves,  $eachA);
									stringArrayInsertAtIndex(0, $Foundboundarycurves,  $eachB);
									for ( $eachboundry in $Foundboundarycurves ) {
										string $selectedCurve[];
										clear $selectedCurve;
										$selectedCurve[0] = $eachboundry;
										string $firstcurveRelatives[];
										$firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
										string $firstcurveConnectionsz[];
										$firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
										string $firstcurveshapes[];
										$firstcurveshapes = `listConnections -shapes 1 - type nurbsSurface $firstcurveConnectionsz`;
										stringArrayIntersector -edit -allowDuplicates  false -intersect $firstcurveshapes  $myIntersector;
									}
									$Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;
									stringArrayIntersector -edit -reset  $myIntersector;
									if (size($Intersectboundarycurves) == 0){
										///////	
										boundary -ch 1 -or 0 -ep 1 -rn 1 -po 0 - ept 0.1 $FirstCurvesZ $each $eachA $eachB;
										string $objectA[] =`ls -sl`;
										MirrorANDrename($objectA);
										editDisplayLayerMembers -noRecurse  IntersectFormLayerINRange $objectA;
									}
									$endtrigger = $endtrigger +1;
									if ( $endtrigger == 1 || $endtrigger == 2 ) {
										stringArrayInsertAtIndex(0, $boundaryCurves,  $each);
										stringArrayInsertAtIndex(0, $boundaryCurves,  $eachB);
										stringArrayInsertAtIndex(0, $boundaryCurves,  $eachA);
									}
									if ( $endtrigger < 2 ){
										string $removecurveAz[]; string $removecurveBz[];  string $removecurveCz[]; 
										$removecurveAz[0] = $each;	
										$removecurveBz[0] = $eachB;
										$removecurveCz[0] = $eachA;
										string $NearestCurvesZ[] = stringArrayRemove ($removecurveAz, $NearestCurvesZ);
										string $NearestCurvesZ[] = stringArrayRemove ($removecurveBz, $NearestCurvesZ);
										string $TEMPAlldiffCurveZBBBB[] =  stringArrayRemove($removecurveCz,  $TEMPAlldiffCurveZBBBB); }
									else if ( $endtrigger == 2 ){ 
										clear $NearestCurvesZ; }

								} 
							}
							//end of if
						}
						//end of For
					}
				}
			}
			int $boundaryCurvessize = size($boundaryCurves); 
			if( $boundaryCurvessize > 0 ) {
				for ( $eachboundry in $boundaryCurves ) {
					string $selectedCurve[];
					clear $selectedCurve;
					$selectedCurve[0] = $eachboundry;
					string $firstcurveRelatives[];
					$firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
					string $firstcurveConnectionsz[];
					$firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
					string $firstcurveshapes[];
					$firstcurveshapes = `listConnections -shapes 1 - type nurbsSurface $firstcurveConnectionsz`;
					int $numberofconnections = size ($firstcurveshapes);
					if ( $numberofconnections == 2 ) {
						string $firstcurveConn[] = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);
						$everyFirstCurveShapeset = $firstcurveConn;
					}
				}
			}
			string $removeoneFromeveryFirst[];
			$removeoneFromeveryFirst = stringArrayRemove ($FirstCurvesZ, $everyFirstCurveShapeset);
			$everyFirstCurveShapeset =  $removeoneFromeveryFirst;
			clear $FirstCurvesZ; 
			break;
		}
	}
	return $newallCurves;
}
/////////////////////////////////////
/////////////////////////////////////
//string  $objectCurveSelected[] =`ls -sl`;
proc string[]  Make_Middle_of_Curve_ParamlocatorZMirror(string  $objectCurveSelected[], string $MakeArcLocatorZ []){
	float $posA[];
	float $posB[];
	float $posC[];
	$posA = `pointOnCurve -turnOnPercentage 1 -pr 0.0 -p $objectCurveSelected[0]`;
	$posB = `pointOnCurve -turnOnPercentage 1 -pr 0.5 -p $objectCurveSelected[0]`;
	$posC = `pointOnCurve -turnOnPercentage 1 -pr 1.0 -p $objectCurveSelected[0]`;
	string $locA[] = `spaceLocator -p 0 0 0`;
	setAttr ($locA[0]+".translate") $posB[0] $posB[1] $posB[2];
	$MakeArcLocatorZ = $locA;
	////////////////////// Moved ParamLoc to middle
	string $CircularArcFromCurve[];
	$CircularArcFromCurve[0] = `createNode  makeThreePointCircularArc`;
	setAttr ($CircularArcFromCurve[0] + ".pt1")  $posA[0] $posA[1] $posA[2] ;
	setAttr ($CircularArcFromCurve[0] + ".pt2")  $posB[0] $posB[1] $posB[2];
	setAttr ($CircularArcFromCurve[0] + ".pt3")  $posC[0] $posC[1] $posC[2];
	setAttr ($CircularArcFromCurve[0] + ".d") 3;
	setAttr ($CircularArcFromCurve[0] + ".s") 8;
	string $ArcCurve[];
	$ArcCurve[0] = `createNode nurbsCurve` ; 
	connectAttr ($CircularArcFromCurve[0] + ".oc")  ($ArcCurve[0] +".cr");
	//delete $objectCurveSelected; 
	string $ParentArc[];
	$ParentArc = `listRelatives -parent $ArcCurve`;
	ResetTranslation($ParentArc);
	$ConnectLocToPoint2 = `connectAttr -f  ($locA[0] + ".translate") (  $CircularArcFromCurve[0] + ".pt2")`;
	string $ArcZ[];
	$ArcZ[0] = `rename $ParentArc  $objectCurveSelected`; 
	delete $objectCurveSelected;
	return $ArcZ; 
}
global proc int stringArrayGmatch(string $item,  string $list[]){
	int $result = false;	
	string $listItem;
	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` ==  1){
			$result = true;
			break;	}
	}	
	return $result;
}
///////////////////////
//returns the first single Item array if string  matches that item  
//EX. string "red"  match array { "bluered",  "blueblue", "greenblue" } returns "bluered" as a  string array[].
//string $testGmatch = "red";  string  $matcharrayTest[] = { "red", "blueblue",  "greenblue" };
//string $matchedinArray[] =  stringArrayGmatchToArray($testGmatch,  $matcharrayTest);
// Result: red // 
global proc string[] stringArrayGmatchToArray (string $item, string $list[]){
	int $result = false;	
	string $listItem;
	string $MatchedItem[];	
	for ($listItem in $list) {
		if ( `gmatch $listItem $item` ==  1){
			$result = true;
			if ($result == true ){ $MatchedItem =  {$listItem};}
			break;	}
	}	
	return $MatchedItem;
}
/////////////////////
proc string[] StraitCurvesSCRIPTZ() {
	//StraitCurves SCRIPT 5000
	string $ObjectCurve[];
	string $StraitCurve[];
	$ObjectCurve = `ls -selection`;
	xform -cp;
	ResetTrans;
	duplicatePreset (1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1);
	string $ObjectCurveduplicate[];
	$ObjectCurveduplicate = `ls -selection`;
	setAttr ($ObjectCurveduplicate[0] + ".translate")  0 0 0;
	setAttr ($ObjectCurveduplicate[0] + ".rotate") 0  0 0;
	playButtonStepForward; select -cl  ;
	float $rotationz[];
	$rotationz = `xform -q -rotation $ObjectCurve`;
	float $translationz[];
	$translationz = `xform -q -translation  $ObjectCurve`;
	float $bbox[] = `exactWorldBoundingBox  $ObjectCurveduplicate`;
	print("Bounding box ranges from: " +
	$bbox[0] + "," + $bbox[1] + "," + $bbox[2]  + ", to " +
	$bbox[3] + "," + $bbox[4] + "," + $bbox[5]  + ".\n");
	spaceLocator -p 0 0 0 -n BoxspaceLocatorA;
	move -ws $bbox[0] $bbox[1] $bbox[2]  BoxspaceLocatorA;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorB;
	move -ws $bbox[3] $bbox[4] $bbox[5]  BoxspaceLocatorB;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorC;
	move -ws $bbox[3] $bbox[1] $bbox[2]  BoxspaceLocatorC;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorD;
	move -ws $bbox[0] $bbox[4] $bbox[5]  BoxspaceLocatorD;
	spaceLocator -p 0 0 0 -n BoxspaceLocatorMiddle;
	// xform -query -worldSpace -translation;
	float $BoxPointA[] = {$bbox[0], $bbox[1], $bbox [2]};
	float $BoxPointB[] = {$bbox[3], $bbox[4], $bbox [5]};
	float $BoxPointC[] = {$bbox[3], $bbox[1], $bbox [2]};
	float $BoxPointD[] = {$bbox[0], $bbox[4], $bbox [5]};
	$BoxPointA = `MakeCleanFloats($BoxPointA)`;
	$BoxPointB = `MakeCleanFloats($BoxPointB)`;
	$BoxPointC = `MakeCleanFloats($BoxPointC)`;
	$BoxPointD = `MakeCleanFloats($BoxPointD)`;
	float $BoxMPointAC[] = MidPointBetween ($BoxPointA, $BoxPointC);
	float $BoxMPointBD[] = MidPointBetween ($BoxPointB, $BoxPointD);
	float $BoxMPointAD[] = MidPointBetween ($BoxPointA, $BoxPointD);
	float $BoxMPointBC[] = MidPointBetween ($BoxPointB, $BoxPointC);
	//   MoveObjectSelection($BoxMPointAC);
	///////////////////////////////
	///////////////////////////////
	float $CrossMPointAB[] = MidPointBetween ($BoxPointA, $BoxPointB);
	// BoxspaceLocatorMiddle CHANGES need here in the  future
	float $translationzMiddle[];
	$translationzMiddle = $CrossMPointAB;
	float $CurveCVzero[] = GetCurveCVposENDS ($ObjectCurveduplicate, 0);
	float $CurveCVLast[] = GetCurveCVposENDS ($ObjectCurveduplicate, 1);
	int $pA1 = PointsEquivalentTol ($CurveCVzero,$BoxPointA); 
	int $pA2 = PointsEquivalentTol ($CurveCVLast,$BoxPointA);
	int $pC1 = PointsEquivalentTol ($CurveCVzero,$BoxPointC); 
	int $pC2 = PointsEquivalentTol ($CurveCVLast,$BoxPointC); 
	int $AorC = 0;
	if (($pA1 == 3) || ($pA2 == 3)){
		$AorC = 1;
	}
	if (($pC1 == 3) || ($pC2 == 3)){
		$AorC = 2;
	}  
	float $distanceA = PointsGetDistanceFLOAT ($BoxPointA, $BoxPointC);
	float $distanceB = PointsGetDistanceFLOAT ($BoxPointB, $BoxPointC);
	float $distanceAverage =  (($distanceA +  $distanceB) * (0.5)) ;
	float $radiusX = ( $distanceAverage / 2.0);
	float $squarePercentA;
	float $squarePercentB;
	if ( $distanceA > $distanceAverage) {
		$squarePercentA = (( $distanceAverage /  $distanceA ) * (100));
	}
	if ( $distanceA < $distanceAverage) {
		$squarePercentA = (( $distanceA /  $distanceAverage ) * (100));
	}
	if ( $distanceB > $distanceAverage) {
		$squarePercentB = (( $distanceAverage /  $distanceB ) * (100));
	}
	if ( $distanceB < $distanceAverage) {
		$squarePercentB = (( $distanceB /  $distanceAverage ) * (100));
	}
	/////////////////////
	int $squareA = 0;
	int $squareB = 0;
	if ( $squarePercentA > 55){
		$squareA = 1; 
	}
	if ( $squarePercentB > 55){
		$squareB =  1; 
	}
	string $StraitCurve[];
	$addSquareResults = ($squareA + $squareB);
	if ( $addSquareResults == 2 ){
		//Eval Diaginal curve
		// USE $radiusX for curve points
		if ( $AorC == 1){
			$StraitCurve[0] = `curve -d 1 -p $BoxPointA[0]  $BoxPointA[1] $BoxPointA[2] -p $BoxPointB[0]  $BoxPointB[1] $BoxPointB[2]`;
		}
		if ( $AorC == 2){
			$StraitCurve[0] = `curve -d 1 -p $BoxPointC[0]  $BoxPointC[1] $BoxPointC[2] -p $BoxPointD[0]  $BoxPointD[1] $BoxPointD[2]`;
		}
	} else { 
		// Not Diagonal curves
		int $XZ = 0;
		if ( $distanceA > $distanceB) {
			$XZ = 1;
		}
		if ( $distanceA < $distanceB) {
			$XZ = 2;
		}
		if ($XZ == 1){
			//$BoxMPointAD  $BoxMPointBC
			$StraitCurve[0] = `curve -d 1 -p $BoxMPointAD[0]  $BoxMPointAD[1] $BoxMPointAD[2] -p $BoxMPointBC [0] $BoxMPointBC[1] $BoxMPointBC[2]`;
		}
		if ($XZ == 2){
			//$BoxMPointAC $BoxMPointBD
			$StraitCurve[0] = `curve -d 1 -p $BoxMPointAC[0]  $BoxMPointAC[1] $BoxMPointAC[2] -p $BoxMPointBD [0] $BoxMPointBD[1] $BoxMPointBD[2]`;
		}
	}
	setAttr ($StraitCurve[0] + ".rotateX")  $rotationz[0];
	setAttr ($StraitCurve[0] + ".rotateY")  $rotationz[1];
	setAttr ($StraitCurve[0] + ".rotateZ")  $rotationz[2];
	setAttr ($StraitCurve[0] + ".translateX")  $translationz[0];
	setAttr ($StraitCurve[0] + ".translateY")  $translationz[1];
	setAttr ($StraitCurve[0] + ".translateZ")  $translationz[2];
	select -r $ObjectCurve $ObjectCurveduplicate  BoxspaceLocatorA BoxspaceLocatorB  BoxspaceLocatorC BoxspaceLocatorD  BoxspaceLocatorMiddle;
	delete;
	select -r $StraitCurve;
	return $StraitCurve;
}
/////////////////////
//////////////////////////
/////////////////////////
proc StartupItems(){
	optionVar -fv "totalAnimateRollTime" 0.9;
	select -r  Text_byxDrawingxaxLinexOverxOnexofxThexCurves_1;
	allViewFit(0);
	allViewFit(1);
	select -cl  ;
	goToView -1;
	pause -sec 2;
	optionVar -fv "totalAnimateRollTime" 2.5;
	goToView -1;
	optionVar -fv "totalAnimateRollTime" 0.4;
	setAttr "ZCURVEModelingCAM.centerOfInterest"  72.916917;
	eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
	PencilCurveTool;
	curveSketchCtx -e -d 3 `currentCtx`;
	setAttr layerYZYXPlains.visibility 1;
}
proc StartupItemsPart2(){
	setAttr "ZCURVEModelingCAM.centerOfInterest"  72.916917;
	eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
	PencilCurveTool;
	curveSketchCtx -e -d 3 `currentCtx`;
	setAttr layerYZYXPlains.visibility 1;
}
proc StartupItemsPart3(){
	setAttr "ZCURVEModelingCAM.centerOfInterest"  72.916917;
	//eval("int $script_jobToolChangedNum1 = `scriptJob  -event ToolChanged EvalAutoCurvesScripts`;");
	PencilCurveTool;
	curveSketchCtx -e -d 3 `currentCtx`;
	setAttr layerYZYXPlains.visibility 1;
}
///////////////////////////////////////////////// ///////////////
proc ResetTransEachSL(){
	string $oneItemz[] = `ls -sl`;
	for ($each in $oneItemz){
		xform -cp $each;
		vector $worldPos = `xform -q -ws -rp  $each`;
		move -rpr 0 0 0 $each;
		makeIdentity -apply true  -t 1 -r 0 -s 0 $each;
		xform -t ($worldPos.x)  ($worldPos.y) ($worldPos.z) $each;
	}
}
//ResetTransEachSL;
proc FlattenCurveOnMesh( string $curve[], string  $Mesh[], string $myCPOMb){
	string $PolygonShapeZ1[0] = {$Mesh[0]};
	string $CurveZOne[0] = {$curve[0]};
	string $CurveSelection[] = `ls -fl ($CurveZOne[0]  +".ep[0:*]")`; 

	for ($Eachep in $CurveSelection ) {
		float $pointPos[];
		$pointPos = `pointPosition -w ($Eachep)`;
		setAttr ($myCPOMb+".inPosition") $pointPos[0] $pointPos[1] $pointPos[2];
		float $valuesB[] = `getAttr  ($myCPOMb+".position")`;
		move -ws $valuesB[0] $valuesB[1] $valuesB[2]  $Eachep;
	}
	$Newcurvez = $CurveZOne;
}
//////////////////////////////////////////////
proc int NumberOFSurf(string $Zeachboundry){
	int $XnumOFcurveConnections;
	string $ZfirstcurveRelatives[];
	$ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
	string $ZfirstcurveConnectionsz[];
	$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
	int $historyShapes = `size($ZfirstcurveConnectionsz)`;
	if ($historyShapes > 0){
		string $Zfirstcurveshapes[];
		$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
		$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
		$XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
	}else{ $XnumOFcurveConnections = 0;}
	return $XnumOFcurveConnections;
}
//////////////////////////////////////////////
proc string[] ForAllCurvesFindSurfaceEdges(string $newallCurves[]){
	string $ZnewfoundEdge[];
	for ( $Zeachboundry in $newallCurves ) {
		string $ZselectedCurve[];
		$ZselectedCurve[0] = $Zeachboundry;
		int $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
		if ($Zfirstcurveshapesi == 1){
			appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
		}
		if ($Zfirstcurveshapesi == 0){
			appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
		}
	}
	return $ZnewfoundEdge;
}
proc FindNumOfConnectionsToCurveRemove(string $boundaryCurves[], int $XiC, string $everyFirstCurveShapeset[]){
	for ( $eachboundry in $boundaryCurves ) {
		string $selectedCurve[];
		int $numberofconnections = NumberOFSurf($eachboundry);
		if ( $numberofconnections == $XiC ) {
			string $firstcurveConn[] = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);
			$everyFirstCurveShapeset = $firstcurveConn;
		}
	}
}
proc vector[] GetVectorArrayBetweenCurveEnds(string $CurveItem[]){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[]; float $EACHCVposBZ[]; int $numIntZB = 0; string $MakeXBetweenB[];
	for ($eachZA in $CurveSelection) {
		float $eachCVpos[];	 $eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
		if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
	}
	vector $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	vector $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;	
	vector $CurveAB[]; $CurveAB[0] = $CurveA; $CurveAB[1] = $CurveB;
	return $CurveAB; 
}
proc int  PtsEquivalentF( float $posA[],  float $posB[], float $TRange){
	int $pX = equivalentTol($posA[0], $posB[0], $TRange);
	int $pY = equivalentTol($posA[1], $posB[1], $TRange);
	int $pZ = equivalentTol($posA[2], $posB[2], $TRange);
	int $addedResults = $pX + $pY + $pZ;
	if ($addedResults == 3 ){ print "Points  equivalent"; 
		return 1;
	}else{
		return 0;}
}
proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
	int $pX = equivalentTol($posA[0], $posB[0],  0.01);
	int $pY = equivalentTol($posA[1], $posB[1],  0.01);
	int $pZ = equivalentTol($posA[2], $posB[2],  0.01);
	int $addedResults = $pX + $pY + $pZ;
	if ($addedResults == 3 ){ print "Points  equivalent"; 
	}
	return $addedResults;
}
proc int FindifCurveEndsMeet(vector $CurveA1[], vector $CurveA2[]){
	int $CurveMeetsTrue = 0;
	int $indexN = 0;
	int $indexN2 = 0;
	while ($indexN < 2){
		float $firstC[];
		$firstC = $CurveA1[$indexN];
		float $SecondCA[];
		$SecondC = $CurveA2[0];
		float $SecondCA[];
		$SecondCA = $CurveA2[1];
		int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
		int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
		if (($NumberE == 3)||($NumberE2 == 3)){$CurveMeetsTrue = $CurveMeetsTrue +1; }
		if ($indexN==1){$indexN1 = 1;}
		$indexN++;
	}
	return $CurveMeetsTrue;
}
proc int ValueOfCurveSurfInterConnections(string $Zeachboundry[]){
	int $NumberofConnectionZ = 0;
	string $myIntersector = `stringArrayIntersector`;
	for ( $eachboundry in $Zeachboundry ) {
		string $ZfirstcurveRelatives[];
		$ZfirstcurveRelatives = `listRelatives -shapes $eachboundry`;
		string $ZfirstcurveConnectionsz[];
		$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
		int $historyShapes = `size($ZfirstcurveConnectionsz)`;
		if ($historyShapes > 0){
			string $Zfirstcurveshapes[];
			$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
			$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
			int $CA = `size($ZfirstcurveshapesA)`;
			int $CB = `size($ZfirstcurveshapesB)`;
			if (($CA > 0) || ($CB > 0)){
				if ($CA > 0){
					$NumberofConnectionZ++;
					stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesA $myIntersector;
				}
				if ($CB > 0){
					$NumberofConnectionZ++;
					stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesB $myIntersector;
				}
			}else{ //no shapes connections of anytype Exist ZERO
				$NumberofConnectionZ = 0;
			}
		}
	}
	string $Intersectboundarycurves[];
	$Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;
	stringArrayIntersector -edit -reset  $myIntersector;
	int $XnumOFcurveConnections = `size($Intersectboundarycurves)`;
	return $XnumOFcurveConnections;
}
proc int IfCurvesTouch(string $curveA, string $curveB){
	string $Acurve[];
	$Acurve = {$curveA};
	string $Bcurve[];
	$Bcurve = {$curveB};
	vector $CurveOne[] = GetVectorArrayBetweenCurveEnds($Acurve);
	vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds($Bcurve);
	int $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
	return $intIfTrue;
}
proc string[] StartofCurveScriptRetopo3 (string $PolygonShapeZ[], string  $ProjectionCurves[], string $CurveName[]){
	string $PolygonShape[];
	$PolygonShape[0] = $PolygonShapeZ[0];
	string $AllIntersectCurveZA[] =  $ProjectionCurves;
	//$PolygonShape[0] = $PolygonShapeZA[0]; 
	//string $AllIntersectCurveZA[] =  $retopoProjectionCurves;
	//print $retopoProjectionCurves;
	makeIdentity -apply true -t 0 -r 0 -s 1 -n 0  $PolygonShape;
	int $KillScript = 1;
	string $curve = "curve -d 3";
	string $Allcurves[];
	$Allcurves = $AllIntersectCurveZA;
	int $curvesNumber = size($Allcurves) -1;
	int $iY = -1; 
	float $ZeroDistanceAB = 0.0;
	int $switchN = 0;
	int $Xi = 1;
	string $curvePoints = "";
	float $step = 1;  
	string $crShape[];
	string $myCurve;
	while ($curvesNumber > $iY ){
		if ($KillScript == 0 ){$iY = 1000;}
		$iY++;
		int $a = 1;
		int $ADDSUB = 1;
		int $ADDSUB2 = 2;
		$b = 0;
		///////////////////
		$switchN = 0;
		//////////////////
		$Xi = 1;
		$step = 1;  
		float $arclenghtOne = `arclen $Allcurves[0]`;
		$myCurve =  $Allcurves[$iY];
		$cube = $PolygonShape[0];
		$myCPOM = `createNode closestPointOnMesh`;
		connectAttr ($cube+".worldMesh")  ($myCPOM+".inMesh");
		$LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
		$LocA = $LocatorResultA[0];
		connectAttr ($myCPOM+".position")  ($LocA+".translate");
		$LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
		$LocB = $LocatorResultB[0];
		connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");
		string $paramlocatorpointOnCurvex = `pointOnCurve  -ch on -pr 0.0 -p $myCurve`;
		$connectPositionToPointNode1 = `connectAttr  ($paramlocatorpointOnCurvex + ".position") ($LocB  + ".translate")`;
		$crShape = `listRelatives -s $myCurve`;
		int $XiX = 0;
		float $DistanceFourth;
		int $triggerA = 0;
		float $UnitDistance;
		float $DivideTotalWithUnit;
		int $RDivideTotalWithUnit;
		int $A2;
		float $UnitDistanceA;
		int $Gate2 = 0;
		int $Gate1 = 0;
		float $UnitDistanceFourth;
		float $UnitDistanceHalf;
		int $a3 = 1;
		int $Demo = 0;
		int $PassedTargetNum = 0;
		while($Xi > 0 ){
			$XiX++;
			if ($XiX == 1000){$Xi = 0; $KillScript = 0;}
			float $valuesC[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
			float $valuesD[] = `getAttr  ($myCPOM+".position")`;
			float $DistanceCD  = PointsGetDistanceFLOAT ($valuesC, $valuesD);
			////IF triggered ----- "$step = 40; $a = $a * 40" 
			// then --- $a = AddorSubtract($a ,$ADDSUB) which  adds 1 making t = 80/40 t = 81/40
			$a = AddorSubtract($a ,$ADDSUB);
			$t =  $a/$step;
			setAttr ($paramlocatorpointOnCurvex +  ".parameter") $t;
			$para = `getAttr ($paramlocatorpointOnCurvex +  ".parameter")`;
			float $valuesA[] = `getAttr  ($paramlocatorpointOnCurvex + ".position")`;
			float $valuesB[] = `getAttr  ($myCPOM+".position")`;
			float $DistanceAB  = PointsGetDistanceFLOAT ($valuesA, $valuesB);
			if ($XiX < 32){ $Gate1 = $XiX;}
			if ($XiX == 1){ $Gate2 = 1;
				$UnitDistanceFourth = $DistanceAB/4;
				$UnitDistanceA  = PointsGetDistanceFLOAT ($valuesC, $valuesA);
			}
			/*
$DivideTotalWithUnit = $DistanceCD /  $UnitDistance;
$RDivideTotalWithUnit = $DivideTotalWithUnit;
*/
			/////////////////////////////////////
			if ($XiX == $Gate2){ $Gate2 = $Gate1;
				$UnitDistance  = $UnitDistanceA;
				$UnitDistanceHalf = $UnitDistance/2;
				$DivideTotalWithUnit = ($DistanceAB/2) /  $UnitDistanceHalf;
				$A2 = ($DivideTotalWithUnit +1);
				if ($A2 >= 1){
					$a = $a + $A2;
				}else{ int $IFequivalent = equivalentTol ($DistanceAB, $ZeroDistanceAB, 0.1);
					if ($IFequivalent == 1){  
						$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
						select -r $LocB $LocA;
						delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
						$Xi = 0; 
					}}
			}
			///////////////////////////////////
			//if ( $DistanceAB > $DistanceCD ) { print ("0000  Passed Target Distance  0000" +  "\n"); $PassedTargetNum++;}
			//0000  Passed Target Distance  0000
			if ($switchN == 0){
				if ($triggerA == 0){
					if (( $DistanceAB <= $UnitDistanceHalf ) && (  $DistanceAB < $DistanceCD )) {$ADDSUB = 1; $step  = 40; $a = $a * 40; 
						$triggerA = 1; } 
				}
				if (!($XiX == $Gate2)){
					if($PassedTargetNum<1){
						if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 0;  $step = 20; $a = $a * 20; $switchN = 1;  
							print ("0000  Passed Target Distance  0000" +  "\n"); }
					}
				}
			}
			if ($switchN == 2){ 
				if ( $DistanceAB > 4){ $ADDSUB = 1;  $step = 1; $a = $a / 20; $switchN = 0; $PassedTargetNum++; print ("0000  Passed False Target  0000" +  "\n");}else{
					if ( $DistanceAB > $DistanceCD ) { $ADDSUB = 1;  $step = 40; $a = $a * 40;  $switchN = 3; 
						$ADDSUB2 = 1; }
				}
			}
			if ($switchN == 1){ $switchN = 2; }
			int $IFequivalent = equivalentTol($DistanceAB,  $ZeroDistanceAB, 0.1);
			if ($IFequivalent == 1){  
				$curve += " -p "+$valuesB[0]+"  "+$valuesB[1]+" "+$valuesB[2];
				select -r $LocB $LocA;
				delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;  
				$Xi = 0; 
			}
			$b = AddorSubtract($b ,$ADDSUB2);
			if ( $b > 10 ){ delete $myCPOM $LocA $LocB  $paramlocatorpointOnCurvex;
				$Xi = 0; }
			//////////////////////////////////
		}
	}
	string $Newcurvez = `eval($curve)`;
	rename $Newcurvez $CurveName[0];
	string $Newcurve[] = $CurveName;
	string $NewcurveA[] = `ls -sl`;
	delete $ProjectionCurves; 
	return $Newcurve; 
}
/////////////////////////////
/*
proc AdvancedCurveMODprojectOnSurface(string  $AllIntersectCurveSA[], string $INarrayA[],  string $PolygonShapeXi[]){
int $Error = 0;
$Error++;
print ("error Here "+$Error);
// string $polyShapRetopo[] = $PolygonShapeZA;
string $polyShapRetopo[] = $PolygonShapeXi;
float $eachCVposSTART[];
float $eachCVposEND[];
string $MakespaceLocatorSTART[];
string $MakespaceLocatorEND[];
string $digitalSkeletonA[];
string $NewStraitCurve[];
int $numInts;
$numInts = size($digitalSkeletonA);
if ( $numInts > 0 ){
clear $digitalSkeletonA;
}
string $AllIntersectCurveS[] =  $AllIntersectCurveSA;
//EvalSmoothCurves;
//$digitalSkeletonA =  `StartofCurveScriptIntersectZX`;
string $AllCurveZ[];
$numInts = size($AllCurveZ);
if ( $numInts > 0 ){
clear $AllCurveZ;
} 
string $AllSpaceLocatorZ[];
$numInts = size($AllSpaceLocatorZ);
if ( $numInts > 0 ){
clear $AllSpaceLocatorZ;
} 
string $renamed[];
string $rebuildit[];
string $ZIntersectionCurveZA[];
string $intersectionCurve[]; 
string $MakeSpaceLocator[];
string $objectLocaterz[];
string $AllparamlocatorZ[];
int $numparam;
string $MakespaceLocatorZSE[];
string $SEspaceLocSetofSetz; 
string $paramANDCurve3[];
string $paramANDCurve2[];
string $paramANDCurve[];
string $paramCurveNAMES[];
string $paramlocatorZ[];
$numInts = size($paramlocatorZ);
if ( $numInts > 0 ){
clear $paramlocatorZ;
} 
string $intersectZ[];
string $ZBetween[];
string $objectCurveA[];
string $objectCurve[];
clear  $objectCurve;
float $EACHCVposA[];
float $EACHCVposB[];
float $p1Z; 	
int $moveCurve = 0;
string $objectSelection[];
$numInts = size($objectSelection);
if ( $numInts > 0 ){
clear $objectSelection;
} 
$objectSelection = `editDisplayLayerMembers -q  layerCurvesINRange1`;
int $numparam;
int $EdgecurvesizeNUM = size($objectSelection);
///errors here
if ($EdgecurvesizeNUM > 0){
float $tol = 0.45;
float $dir[3] ;	
		$dir = nurbsViewDirectionVector (0) ;
float $dirX, $dirY, $dirZ;
$dirX = $dir[0];
$dirY = $dir[1];
$dirZ = $dir[2];
string $eachZ;
string $curveIntersectZA;
int $Xxi = -1;
for ( $eachZ in $objectSelection ){
$objectCurve[0] = $eachZ;	
$Xxi++;
print $Xxi ;
$curveIntersectZA = `curveIntersect -ch off - useDirection on -direction $dirX $dirY $dirZ  $objectSelection[$Xxi] $AllIntersectCurveS`;
int $numTokens;		
string $tokens[];
$numTokens = `tokenize $curveIntersectZA " "  $tokens`;
print $numTokens;
if ($numTokens == 2){
///////////////GATHER ALL BUILDING  STRUCTURE/////////##
$objectCurve[0] = $eachZ;
appendStringArray($AllCurveZ, $objectCurve, 1);
string $buffer[];
$numTokens = `tokenize $curveIntersectZA " "  $buffer`;
$paramlocatorZ[0] = eval("paramLocator " +   $objectCurve[0] + ".u[" + $buffer[0] + "]");
appendStringArray($AllparamlocatorZ,  $paramlocatorZ, 1);
appendStringArray($digitalSkeletonA,  $paramlocatorZ, 1);
		float $intersectposA[];	
	$intersectposA = `pointPosition -w  $paramlocatorZ[0]`;
string $objectLocaterzA[];
$objectLocaterzA = `spaceLocator -p 0 0 0 -n  IntersectZLocaterZ3D`;
move  -ws $intersectposA[0] $intersectposA[1]  $intersectposA[2] $objectLocaterzA[0];
appendStringArray($AllSpaceLocatorZ,  $objectLocaterzA, 1);
clear $objectCurve; 
}
}
appendStringArray($digitalSkeletonA,  $AllSpaceLocatorZ, size($AllSpaceLocatorZ));
string $shorterList[] =  stringArrayRemoveDuplicates($AllCurveZ);
$AllCurveZ = $shorterList;
int $CurvesCUTinto = size($AllCurveZ);
if ($CurvesCUTinto == 1){string $oneLocatorZ[] =  {$AllparamlocatorZ[0]}; $AllparamlocatorZ =  $oneLocatorZ; }
$numparam = size($AllparamlocatorZ);
if (($CurvesCUTinto == 2) && ($numparam == 4)){
string $oneLocatorZa[] = {$AllparamlocatorZ[0]}; 
string $oneLocatorZb[] = {$AllparamlocatorZ[1]}; 
$AllparamlocatorZ = {$oneLocatorZa[0],  $oneLocatorZb[0]}; 
}
$numparam = size($AllparamlocatorZ);
int $numInts = size($AllSpaceLocatorZ);
if (($CurvesCUTinto == 2) && ($numInts == 4)){
string $oneLocatorZ2a[] = {$AllSpaceLocatorZ[0]}; 
string $oneLocatorZ2b[] = {$AllSpaceLocatorZ[1]}; 
$AllSpaceLocatorZ = {$oneLocatorZ2a[0],  $oneLocatorZ2b[0]}; 
}
$numInts = size($AllSpaceLocatorZ);
if ( $numparam > 0 ){
string $shorterList[] =  stringArrayRemoveDuplicates($AllparamlocatorZ);
$AllparamlocatorZ = $shorterList;
}
$numparam = size($AllparamlocatorZ);
$numInts = size($AllSpaceLocatorZ);
select -cl  ;
print $AllparamlocatorZ;
$SEspaceLocSetofSetz = `sets -name  SEspaceLocSetofSets`;	
$paramANDCurve3 = `paramToCurvePts3(  $AllparamlocatorZ )`;
$paramANDCurve2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
$paramANDCurve = `paramToCurvePts(  $AllparamlocatorZ )`;
$paramCurveNAMES = `tokenizeparam( $paramANDCurve  )`;
$MakespaceLocatorZSE = EvalMoveCurvesTOend ($paramANDCurve, $paramCurveNAMES,  $paramANDCurve3, $AllparamlocatorZ,  $SEspaceLocSetofSetz);
if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
int $setsNumber = `sets -q -size  $SEspaceLocSetofSetz`;
if ($setsNumber > 0){
string $subsets[];
$subsets = `sets -q $SEspaceLocSetofSetz`;
//appendStringArray($digitalSkeletonA, $subsets,  size($subsets));
}
/////////////////////
// end of if Size of Curves are greater then ONE 
}
print $numparam;
/////////////////////
/////////////////////
/////////////////////
	if ( $numparam == 0 ){
int $trueORfalse = 0;
int $trueORfalse2 = 0;
string $oldName = $AllIntersectCurveS[0];
$trueORfalse = FindIfCurveCrossesZ ($AllIntersectCurveS);
string $newname[]; 
if ($trueORfalse == 1){
$newname = CutCurveIFConditionTRUETransitZ ($AllIntersectCurveS);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $oldName;
$AllIntersectCurveS = {$oldName}; 
}
if ($trueORfalse == 0){
ResetTranslation($AllIntersectCurveS);
}
select -r $AllIntersectCurveS;
MirrorANDrename($AllIntersectCurveS);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $AllIntersectCurveS;
} else if ( $numparam == 1 ){
///START OF CURVE = 1
string $renamed[]; 
$renamed[0] = $AllIntersectCurveS[0];
ResetTranslation($renamed);
float $arclenghtDrawCurve = `arclen  $AllIntersectCurveS[0]`;
float $arcLenCurveFrac = $arclenghtDrawCurve/5;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($renamed[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($renamed[0] + ".cv[0]") ;		 	
$CurveSelection[1] = ($renamed[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
}
select -r $renamed $AllCurveZ;
	string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;
cutCurvePreset(1,1,0.001,2,0.4982,0.8536,0.1523,2,2);
	$afterCut = `ls -sl`;
				// Now, One of these are  bad, One is OK:
			if( `getAttr ($afterCut [0] + ".spans")` < `getAttr ($afterCut [1] + ".spans")`){ delete $afterCut[0];
	$numTokensZ = `tokenize $afterCut[1] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0];
} else { delete $afterCut[1];		
$numTokensZ = `tokenize $afterCut[0] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		
// print $bufferCutCurve;
string $ZIntersectionCurveZA[];
$ZIntersectionCurveZA = `listRelatives -shapes  $bufferCutCurve[0]`;
$renamed[0] = `rename $ZIntersectionCurveZ[0] $renamed[0]`;
ResetTranslation($renamed);
print $renamed;
if (size($MakespaceLocatorZSE) > 0){
int $ZEROorONE;
int $foundA = stringArrayGmatch ("SEspaceLocatorSTART3DZ*",  $MakespaceLocatorZSE);
int $foundB = stringArrayGmatch ("SEspaceLocatorEND3DZ*", $MakespaceLocatorZSE);
if (( $foundA == 1 ) || ( $foundB == 1 )) {
float $eachCVposSTART[] = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
float $movePIVOT[];
$ZEROorONE = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTART);
string $pointEP;
if ( $ZEROorONE == 0){ $movePIVOT = $EACHCVposAZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[0];  }
if ( $ZEROorONE == 1){ $movePIVOT = $EACHCVposBZ;  move $movePIVOT[0] $movePIVOT[1] $movePIVOT[2]  ($renamed[0] + ".scalePivot") ($renamed[0] +  ".rotatePivot") ; $pointEP = $CurveSelection[1];  }
//ADD SOFT SELECT HERE
select -r $pointEP;
softSelect -e -softSelectEnabled true;
softSelect -e -softSelectDistance  $arcLenCurveFrac;
move -rpr $eachCVposSTART[0] $eachCVposSTART[1]  $eachCVposSTART[2];
xform -cp $renamed[0];
softSelect -e -softSelectEnabled false;
FlattenCurveOnMesh( $AllIntersectCurveS,  $polyShapRetopo);
}
}
if (size($MakespaceLocatorZSE) == 0){
float $eachCVposSTARTB[] = `pointPosition -w  ($AllparamlocatorZ[0])`;
float $CurveEndFloat[];
$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVposSTARTB);
string $pointEP;
if ( $ZEROorONEB == 0){ $pointEP = $CurveSelection[0];  $CurveEndFloat = $EACHCVposAZ;}
if ( $ZEROorONEB == 1){ $pointEP = $CurveSelection[1];  $CurveEndFloat = $EACHCVposBZ;}
//print $pointEP;
//print $CurveEndFloat;
$eachCVposSTARTB = `MakeCleanFloats($eachCVposSTARTB)`;
$CurveEndFloat = `MakeCleanFloats($CurveEndFloat)`;
int $CurveANDIntersectIsTrue = PointsEquivalentTol ($eachCVposSTARTB, $CurveEndFloat); 
if ($CurveANDIntersectIsTrue == 0){
move -rpr $eachCVposSTARTB[0] $eachCVposSTARTB[1]  $eachCVposSTARTB[2] $pointEP;
}
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $CurveNameA[] = `paramToCurvePts3(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $AllCurveZA = ("A"+ $CurveNameA[0]+"A");
string $TwoCutCurveZ[] = `ls -sl`;
delete $AllCurveZA;
delete $CurveNameA;
string $AllCurveZ2[];
string $newCurveZA[];
string $newCurveBB[];
int $AllCurveNumA = `size($AllCurveZ)`;
int $detachCurveNumA = `size($detachCurve1)`;
int $OriginalCurveNum = ($AllCurveNumA + $detachCurveNumA);
RemoveNoLongerExistingFromArray ($AllCurveZ);
RemoveNoLongerExistingFromArray ($detachCurve1);
int $AllCurveNumB = `size($AllCurveZ)`;
int $detachCurveNumB = `size($detachCurve1)`;
int $CurveNumB = ($AllCurveNumB + $detachCurveNumB);
string $NewCurvesCut[];
if($CurveNumB == 2){
if (!($CurveNumB == $OriginalCurveNum)&&(($AllCurveNumB > 0)&&($detachCurveNumB > 0))){
appendStringArray($NewCurvesCut, $AllCurveZ, size($AllCurveZ));
appendStringArray($NewCurvesCut, $detachCurve1, size($detachCurve1));
}
}
if (($AllCurveNumB == 0) && ($detachCurveNumB == 2)){
appendStringArray($NewCurvesCut, $detachCurve1, size($detachCurve1));
}
if (($AllCurveNumB == 2) && ($detachCurveNumB == 0)){
appendStringArray($NewCurvesCut, $AllCurveZ, size($AllCurveZ));
}
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
}
ResetTranslation($NewCurvesCut);
for ($each in $NewCurvesCut){
string $newCurveBB[];
$newCurveBB[0] = `rename $each Curve`;
select -r $newCurveBB[0];
MirrorANDrename($newCurveBB);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveBB[0];
ArrayInsertAtEnd( $newCurveZA, $newCurveBB[0]);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurveZA[0]);
ArrayInsertAtEnd( $INarrayA,$newCurveZA[1]);
string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurveZA;
}
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA; }
ResetTranslation($renamed);
string $renamed2[];
$renamed2 = $renamed;
///////////////////////////////////////////////// ///////
// IF Drawn Curve is connected to the end of  another curve thast is in EdgeSet
// the curve drawn can be on a edge curve which  is eather protruding from the ZY plain 
// or it lies on the ZY plain. if it is at one of  the two ends of a protruding EdgeCurve
// then the drawn curve intersecting at  EdgeCurves Ends is eather also protruding from ZY  plain or 
// is positioned freely at the other end.. which  means it could be crossing the ZY plain which  means     
// It would need to be cut
int $ifNearEnds = 0;
if (size($MakespaceLocatorZSE) > 0){
$ifNearEnds = size($MakespaceLocatorZSE);
}
//int $ifNearEnds = size($MakespaceLocatorZSE);
int $AllCurveCVsZeroAndLast = FindIfCurveISonZ ($AllCurveZ);
if ( `objExists ZEdgeCurvesSet` == 0  ) {
string $newSet1 = `sets -name ZEdgeCurvesSet`;
}
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $ZeroX = 0;
if (( $ifNearEnds == 1) && (  $AllCurveCVsZeroAndLast == 1) && ( $edgeZsetA ==  1)) {
vector $AllCurveCVENDs[] = `VecCurveEnds ($AllCurveZ)`;
vector $renamed2CVENDs[] = `VecCurveEnds ($renamed2)`;
float $renamed2CVENDAs[] = $renamed2CVENDs[0];
float $renamed2CVENDBs[] = $renamed2CVENDs[1];
float $AllCurveCVENDAs[] = $AllCurveCVENDs[0];
float $AllCurveCVENDBs[] = $AllCurveCVENDs[1];
float $FloatZ1[] = $renamed2CVENDAs;
float $FloatZ2[] = $renamed2CVENDBs;
float $FloatZ3[] = $AllCurveCVENDAs;
float $FloatZ4[] = $AllCurveCVENDBs;
$renamed2CVENDAs = `MakeCleanFloats($FloatZ1)`;
$renamed2CVENDBs = `MakeCleanFloats($FloatZ2)`;
$AllCurveCVENDAs = `MakeCleanFloats($FloatZ3)`;
$AllCurveCVENDBs = `MakeCleanFloats($FloatZ4)`;
int $CombA = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDAs);
int $CombB = PointsEquivalentTol ($renamed2CVENDBs, $AllCurveCVENDBs);
int $CombC = PointsEquivalentTol ($renamed2CVENDAs, $AllCurveCVENDBs);
float $intersectFloat[];
if ($CombA == 3 ){ $intersectFloat =  $AllCurveCVENDAs;}
if ($CombB == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
if ($CombC == 3 ){ $intersectFloat =  $AllCurveCVENDBs;}
float $Zero0x = 0.0;
$ZeroX = equivalentTol($Zero0x, $intersectFloat [0], 0.001);
}
$intZplainF = 1;
if ($ZeroX == 1){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed);
}
}
if ($AllCurveCVsZeroAndLast == 2){
$intZplainF = `ZplainFlatten`;
if($intZplainF == 0){
FlattenCurveToZplain($renamed2);
}
}
int $trueORfalse = 0;
int $trueORfalse2 = 0;
if ($ZeroX == 0){
$trueORfalse = FindIfCurveCrossesZ($renamed2);
string $newname[]; 
if (($trueORfalse == 1) && ($ZeroX == 0)){
$newname = CutCurveIFConditionTRUETransitZ ($renamed2);
$trueORfalse2 = 1;
ResetTranslation($newname);
rename $newname $renamed2; 
}
}  
string $newnamed[0] = {$renamed2[0]};
ResetTranslation($newnamed);
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 
if($intZplainF > 0)  {
select -r $newnamed;
MirrorANDrename($newnamed);
}
if (($ZeroX == 1) || ($trueORfalse2 == 1)){
sets -include ZEdgeCurvesSet $newnamed;
}
//ArrayInsertAtEnd( $INarrayA, $newnamed[0]);
print "check Here6";
ResetTranslation($newnamed);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newnamed;
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}
select -r $newnamed[0];
EvalAddingCurves;
EvalcreatSphere;
//////////////////////////////////////END OF ONE  CURVE
//////////////////////////////////////END OF ONE  CURVE
} else if ( $numparam > 2 ){
//IF INTETSECT MORE THEN 2CURVES can be changed here
// Buffers of u para of DrawnCurve placed in a  Array then Sorted. ///
if (size($MakespaceLocatorZSE) > 0){
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
}
delete $digitalSkeletonA;
} else if ( $numparam == 2 ){
//////////////////////////////////////
////NEW NEW NEW
$rebuildit = $AllIntersectCurveS;
print $rebuildit;
//NEW START//
//ResetTranslation($rebuildit);
select -r $AllIntersectCurveS $AllCurveZ[0];
	string $bufferCutCurve[];
	string $ZIntersectionCurveZ[];
	string $afterCut[];
	string $numTokensZ;
	int $n, $i;
cutCurvePreset(1,1,0.001,2,0.4982,0.8536,0.1523,2,2);
	$afterCut = `ls -sl`;
				// Now, One of these are  bad, One is OK:
			if( `getAttr ($afterCut [0] + ".spans")` < `getAttr ($afterCut [1] + ".spans")`){ delete $afterCut[0];
	$numTokensZ = `tokenize $afterCut[1] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0];
} else { delete $afterCut[1];		
$numTokensZ = `tokenize $afterCut[0] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		
// print $bufferCutCurve;
string $ZIntersectionCurveZA[];
$ZIntersectionCurveZA = `listRelatives -shapes  $bufferCutCurve[0]`;
select -r $ZIntersectionCurveZA $AllCurveZ[1];
cutCurvePreset(1,1,0.001,2,0.4982,0.8536,0.1523,2,2);
			$afterCut = `ls -sl`;
				// Now, One of these are  bad, One is OK:
			if( `getAttr ($afterCut [0] + ".spans")` < `getAttr ($afterCut [1] + ".spans")`){ delete $afterCut[0];
	$numTokensZ = `tokenize $afterCut[1] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0];
} else { delete $afterCut[1];		
$numTokensZ = `tokenize $afterCut[0] "."  $bufferCutCurve`;
$ZIntersectionCurveZ[0] = $bufferCutCurve[0]; }
		
// print $bufferCutCurve;
//THIS IS LIKELY WHERE OTHER PROBLEMS EXIST!!!!!!!!!!!!!!!!!!! DO NOT RENAME THE SHAPE NODE!!!!!
//THIS IS LIKELY WHERE OTHER PROBLEMS EXIST!!!!!!!!!!!!!!!!!!! DO NOT RENAME THE SHAPE NODE!!!!!
//THIS IS LIKELY WHERE OTHER PROBLEMS EXIST!!!!!!!!!!!!!!!!!!! DO NOT RENAME THE SHAPE NODE!!!!!
print $afterCut;
RemoveNoLongerExistingFromArray ($afterCut);
string $ZIntersectionCurveZB[];
$ZIntersectionCurveZB = `listRelatives -shapes $afterCut[0]`;
print $ZIntersectionCurveZB;
print $afterCut[0];
print $rebuildit[0];
$renamed[0] = `rename $afterCut[0] $rebuildit`;
string $ZIntersectionCurveZC[];
$ZIntersectionCurveZC = `listRelatives -shapes $renamed[0]`;
$rebuildit = $renamed;
ResetTranslation($rebuildit);
if ( size($MakespaceLocatorZSE) == 0  ) {
string $paramANDCurveA2[];
$paramANDCurveA2 = `paramToCurvePts2(  $AllparamlocatorZ )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[0]`;
string $detachCurve2[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA2[1]`;
delete $AllCurveZ;
string $newCurves1[];
string $newCurves2[];
for ($each in $detachCurve1){
string $newCurveA;
$newCurveA = `rename $each Curve`;
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveA;
ArrayInsertAtEnd( $newCurves1, $newCurveA);
}
for ($each in $detachCurve2){
string $newCurveB;
$newCurveB = `rename $each Curve`;
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurveB;
ArrayInsertAtEnd( $newCurves2, $newCurveB);
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves2[1]);
ResetTranslationEach($newCurves1);
ResetTranslationEach($newCurves2);
string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
$AllCurveZ = $newCurves1;
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[0]);
ArrayInsertAtEnd( $AllCurveZ, $newCurves2[1]);
}
int $ONEspaceLOC = 0;
string $newCurves1[];
if (size($MakespaceLocatorZSE) == 1){
$ONEspaceLOC = 1;
string $subsetsA[];
$subsetsA = `sets -q $SEspaceLocSetofSetz`;
string $subsetsB[]; string $subsetsB2[];
$subsetsB = `sets -q $subsetsA`;
$subsetsB2[0] = $subsetsB[0];
$subsetsB3[0] = $subsetsB[1];
string $SetItemA = ($subsetsB2[0]);
string $SetItemB = ($subsetsB3[0]);
string $subsetItemNeeded[];
int $setATrueFalse = `gmatch $SetItemA "*->*"`;
int $setBTrueFalse = `gmatch $SetItemB "*->*"`;
if ($setATrueFalse == 1){
$subsetItemNeeded[0] = $subsetsB2[0];
}else{ $subsetItemNeeded[0] = $subsetsB3[0]; }
string $bufferZ[];
$numTokensX = `tokenize $subsetItemNeeded[0] "->"  $bufferZ`;
print $bufferZ; 
string $CurveLOCZ[] =  {$bufferZ[1]};
string $paramANDCurveA02[];
$paramANDCurveA02 = `paramToCurvePts2( $CurveLOCZ  )`;
string $detachCurve1[] = `detachCurve -ch off - replaceOriginal off $paramANDCurveA02[0]`;
delete $subsetsB[0];
string $newCurves1[];
for ($each in $detachCurve1){
string $newCurve;
$newCurve = `rename $each Curve`;
ArrayInsertAtEnd( $newCurves1, $newCurve);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $newCurve;
}
string $objectLayerCurvesRange[] =  `queryLayerRangeMembers`;
$INarrayA = $objectLayerCurvesRange;
ArrayInsertAtEnd( $INarrayA, $newCurves1[0]);
ArrayInsertAtEnd( $INarrayA, $newCurves1[1]);
string $diffdigitalSkeleton[] =  stringArrayRemoveExact($AllparamlocatorZ,  $digitalSkeletonA);
$digitalSkeletonA = $diffdigitalSkeleton;
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
delete $AllparamlocatorZ; 
}
if ( size($MakespaceLocatorZSE) > 0  ) {
appendStringArray($digitalSkeletonA,  $MakespaceLocatorZSE, size ($MakespaceLocatorZSE));
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($rebuildit[0] + ".cv[0]") ;	 		
$CurveSelection[1] = ($rebuildit[0] + ".cv[" +  $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
string $MakeXBetweenB[];
for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
$MakeXBetweenB[0] = `curve -d 1 -p $EACHCVposAZ [0] $EACHCVposAZ[1] $EACHCVposAZ[2] -p  $EACHCVposBZ[0] $EACHCVposBZ[1] $EACHCVposBZ[2]  -k 0 -k 2 -n                        XCurveBetweenB`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp  0 -kep 1 -kt 0 -s 0 -d 1 -tol 0.001  $MakeXBetweenB[0];
appendStringArray($digitalSkeletonA,  $MakeXBetweenB, 1);
}
}
wire -gw false -en 1.000000 -ce 0.000000 -li  1.000000 -w $MakeXBetweenB[0] -dds 0 50.000000  $rebuildit[0];
PAUSE;
string $CurveSelection[]; 
int $numCVs = `getAttr -size ($MakeXBetweenB[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );
$CurveSelection[0] = ($MakeXBetweenB[0] + ".cv [0]") ;			
$CurveSelection[1] = ($MakeXBetweenB[0] + ".cv["  + $numCVrealNum + "]") ;
float $EACHCVposAZ[];
float $EACHCVposBZ[];	
int $numIntZB = 0;
for ($eachZA in $CurveSelection) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
$numIntZB = $numIntZB + 1;
if ( $numIntZB == 1 ){
$EACHCVposAZ = $eachCVpos;
}
if ( $numIntZB == 2 ){
$EACHCVposBZ = $eachCVpos;
}
				}
int $ZEROorONEA;
int $ZEROorONEB;
string $locZSE0[];
string $locZSE1[];
int $foundAZ0;
int $foundBZ0;
int $foundAX1;
int $foundBX1;
int $i = 0;
int $iX = 0;
float $eachCVpos1[];
float $eachCVpos2[];
float $movePIVOT1[];
float $movePIVOT2[];
	if (size($MakespaceLocatorZSE) == 1){	 $i = 1; }
	if (size($MakespaceLocatorZSE) == 2){ 	 $iX = 2; }
	if (( $i == 1) || ( $iX == 2)){
$locZSE0[0] = $MakespaceLocatorZSE[0];
$eachCVpos1 = `pointPosition -w  ($MakespaceLocatorZSE[0])`;
	if ( $iX == 2){
$locZSE1[0] = $MakespaceLocatorZSE[1];
$eachCVpos2 = `pointPosition -w  ($MakespaceLocatorZSE[1])`;
	}
	if (( $i == 1) || ( $iX == 2)) {
$ZEROorONEA = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos1);
if ( $ZEROorONEA == 0){ $movePIVOT1 =  $eachCVpos1; print "cv ZERO"; }
if ( $ZEROorONEA == 1){ $movePIVOT1 =  $eachCVpos1; print "cv LAST"; }
if ( $iX == 2){
$ZEROorONEB = FindclosetTOcurveENDz($EACHCVposAZ,  $EACHCVposBZ, $eachCVpos2);
if ( $ZEROorONEB == 0){ $movePIVOT2 =  $eachCVpos2; print "cv ZERO"; }
if ( $ZEROorONEB == 1){ $movePIVOT2 =  $eachCVpos2; print "cv LAST"; }
move -ws $movePIVOT2[0] $movePIVOT2[1]  $movePIVOT2[2] $CurveSelection[$ZEROorONEB];
PAUSE;	}
move -ws $movePIVOT1[0] $movePIVOT1[1]  $movePIVOT1[2] $CurveSelection[$ZEROorONEA];
PAUSE;				}
delete -ch $rebuildit;
delete $digitalSkeletonA; 				 	}
}
/////////////////////////////
int $CVsZeroAndLast;
if ( size($MakespaceLocatorZSE) > 0  ) {
if ( `objExists ZEdgeCurvesSet` == 1  ) {
if ( $ONEspaceLOC == 0  ) {
int $edgeZsetA = `sets -im ZEdgeCurvesSet  $AllCurveZ[0]`;
int $edgeZsetB = `sets -im ZEdgeCurvesSet  $AllCurveZ[1]`;
$CVsZeroAndLast = FindIfCurveISonZ($rebuildit);
if (($edgeZsetA == 1) && ($edgeZsetB == 1)){
print "Intersects edgeZset Curves";
string $CurveSelectionZ[];
int $numCVs = `getAttr -size ($rebuildit[0] +  ".controlPoints")`;
int $numCVrealNum = ( $numCVs -1 );	
$CurveSelectionZ[0] = ($rebuildit[0] + ".cv[" +  "0:" + $numCVrealNum + "]") ;
if ($CVsZeroAndLast == 2){
string $CurveSelectionX[];
$CurveSelectionX = `ls -fl $CurveSelectionZ[0]`;
for ($eachZA in $CurveSelectionX) {
		float $eachCVpos[];		
	$eachCVpos = `pointPosition -w ( $eachZA   )`;
move -ws 0 $eachCVpos[1] $eachCVpos[2] $eachZA ; 
}
}
xform -cp;
}
}
}
}
FlattenCurveOnMesh( $rebuildit,  $polyShapRetopo);
ResetTranslation($rebuildit);
//string $ParentArc[];
//$ParentArc = Strait_ARC_or_FreeForm($rebuildit,  5.5, 2.5 );
//print $CVsZeroAndLast;
//FROM HERE DOWN all -- $rebuildit -- strings[]  WERE $ParentArc  
if($CVsZeroAndLast < 2){
select -r $rebuildit;
MirrorANDrename($rebuildit);
}
if ( $CVsZeroAndLast > 0){ 
sets -include ZEdgeCurvesSet $rebuildit;
}
ArrayInsertAtEnd( $INarrayA, $rebuildit[0]);
editDisplayLayerMembers -noRecurse  layerCurvesINRange1 $rebuildit;
select -r $rebuildit[0];
EvalAddingCurves;
EvalcreatSphere;
////////////////////TRIGGER###################### #######////////////////
}
RemoveNoLongerExistingFromArray ($digitalSkeletonA);
if (size($digitalSkeletonA) > 0){
delete $digitalSkeletonA;
}
RemoveNoLongerExistingFromArray ($AllparamlocatorZ);
if (size($AllparamlocatorZ) > 0){
delete $AllparamlocatorZ;
} 
if ( `objExists $SEspaceLocSetofSetz` == 1  ) { 	
select -r -ne $SEspaceLocSetofSetz;
delete;
}
}
*/
////END OF PROC////////////////////////////////////////////////////
proc AutoBoundry2010(){
	string $shortNameCurve = "Curve*";
	string $everyFirstCurveShapeset[];
	clear $everyFirstCurveShapeset;
	string $shortNameCurve = "Curve*";
	$everyFirstCurveShapeset = `ls -assemblies $shortNameCurve`;
	select -r $everyFirstCurveShapeset;
	PAUSE;
	string $CatureEveryCurve[], $CatureAllCur[], $everyCurve[], $AllCur[], $first[], $AllList[];
	string $Patches = "";
	clear $everyCurve;
	clear $AllCur;
	clear $first;
	clear $AllList;
	string $everyCurve[] = $everyFirstCurveShapeset;
	string $AllCur[] = $everyFirstCurveShapeset;
	$first = {$AllCur[0]};
	// Find if there are curves to boundry curves that already share 2 surfaces cannot be used //
	string $edgeCurves[] =  ForAllCurvesFindSurfaceEdges($everyCurve);
	$everyCurve = $edgeCurves;
	$AllList = $edgeCurves;
	if( size($everyCurve) >3){
		// 1st
		//Sort By distance run once for full array to make it faster
		string $FirstToENDendToFirst[] = CycleNumberString($everyCurve);
		string $NearestToFirstA[] = NearestObjectArray(`size( $FirstToENDendToFirst)`,  $FirstToENDendToFirst);
		//$everyCurve = $NearestToFirstA;
		string $myIntersector = `stringArrayIntersector`;
		float $SIzeA = `size($everyCurve)`;
		float $NumberofMaxSurfacesA = (($SIzeA/4 )+$SIzeA+1)/3;
		int $NumberofMaxSurfaces = $NumberofMaxSurfacesA;
		int $Numberofloops = `size($everyCurve)` *2;
		//start of loop
		//Max Boundry loops
		int $Cycles = 0;
		int $SizeRemaing;
		int $Loops = 1;
		int $trigger = 0;
		int $triggerEnd = 0;
		int $trigger1 = 0;
		//for($everOneCurve in $AllList){
		while(`size($AllList)`>1){
			// 2nd 
			if($Cycles>$NumberofMaxSurfaces){
				print "BREAK AT CYCLE TRIGGER"; print "BREAK AT CYCLE TRIGGER";
				break;
			}
			if($Loops>$Numberofloops){
				break; print "BREAK AT LOOP TRIGGER";
			}
			$CatureEveryCurve = $AllList;
			$CatureAllCur = $AllCur;
			if($trigger1==0){
				if(`size($AllList)`<3){
					print "SIZE LOW"; 
					$AllList =  ForAllCurvesFindSurfaceEdges($everyFirstCurveShapeset);
					$everyCurve = $AllList;
					$trigger1 = 1;
				}
			}
			$AllCur = $everyCurve;
			stringArrayIntersector -edit -intersect $everyCurve $myIntersector;
			stringArrayIntersector -edit -intersect $AllList $myIntersector;
			$AllList = `stringArrayIntersector -query $myIntersector`;
			clear $first;
			$first[0] = $AllList[0];
			$AllCur = stringArrayRemoveExact({$first[0]}, $AllCur);
			$AllList = stringArrayRemoveExact({$first[0]}, $AllList);
			stringArrayIntersector -edit -reset $myIntersector;
			$CatureEveryCurve = $AllList;
			$CatureAllCur = $AllCur;
			int $ifNumberisGreaterthenOne = FindNumOfConnectionsToCurveRemove($first, 2, $everyCurve);
			// 3rd  
			if($ifNumberisGreaterthenOne<2){
				string $Connecting[];
				clear $Connecting;
				int $intIfTrueA;
				for ($eachZ in $AllCur){
					$intIfTrueA = IfCurvesTouch($eachZ, $first[0]);
					if($intIfTrueA == 1){
						appendStringArray($Connecting, {$eachZ},  1);
					}
				}
				string $ConnectMinusRemaining[] = stringArrayRemoveExact($Connecting, $AllCur);
				string $ConnAndFirst[];
				$ConnAndFirst = $ConnectMinusRemaining;
				stringArrayInsertAtIndex(`size($ConnAndFirst)`, $ConnAndFirst, $first[0]);
				string $NearestToFirst[] = NearestObjectArray((`size($ConnAndFirst)`)-1, $ConnAndFirst);
				$ConnAndFirst = $NearestToFirst;
				//find what curves that are connected share a surface if any.. that way you 
				//remove alot and make the script much much faster
				//Remove Connecting curves to first curve that share and make up a surface
				string $SurfaceName[] = GetSurfConnectNameIfexists($first[0]);
				if(`size($SurfaceName)` >0){
					RemoveCurvesThatshareNamedSurface($Connecting, $SurfaceName[0]);
				}
				if(`size($Connecting)`<1){
					$everyCurve = stringArrayRemoveExact($first , $everyCurve); }
				if(`size($Connecting)`<2){
					$everyCurve = stringArrayRemoveExact($first , $everyCurve);
				}else if(`size($Connecting)`>1){
					int $Bounded =0;
					string $ConnectPatch[];
					clear $ConnectPatch;
					int $intIfTrueA;
					int $intIfTrueB;
					int $intIfTrueC;
					string $diffeachConnected[];
					clear $diffeachConnected;
					int $intIfTrueB;
					$Patches = "";
					for ($each in $NearestToFirst){
						if($Bounded==2){
							$everyCurve = stringArrayRemoveExact($first , $everyCurve);
							break; }
						for ($eachConnected in $Connecting){
							$intIfTrueA = IfCurvesTouch($eachConnected,$each);
							if($intIfTrueA==1){
								$diffeachConnected = stringArrayRemoveExact({$eachConnected}, $Connecting);
								select -r $eachConnected; PAUSE;
								for ($eachdiff in $diffeachConnected){
									$intIfTrueD = IfCurvesTouch($eachdiff,$eachConnected);
									if($intIfTrueD == 0){
										$intIfTrueB = IfCurvesTouch($eachdiff,$each);
										if(($intIfTrueA == 1)&&( $intIfTrueB == 1)){
											$intIfTrueC = IfCurvesTouch($eachdiff,$eachConnected);
											if($intIfTrueC == 0){
												appendStringArray($ConnectPatch, {$each},  1);
												appendStringArray($ConnectPatch, {$eachdiff},  1);
												appendStringArray($ConnectPatch, {$eachConnected},  1);
												$Patches += $each+" "+$eachdiff+" "+$eachConnected+" "+$first[0]+"P"; 
												$diffeachConnected = stringArrayRemoveExact($ConnectPatch , $diffeachConnected);
												$Connecting = stringArrayRemoveExact($ConnectPatch , $Connecting);
												$NearestToFirst = stringArrayRemoveExact($ConnectPatch , $NearestToFirst);
												$ifFalseBound = FindifFourCurvesShareSurface($ConnectPatch);
												if($ifFalseBound==0){
													boundary -ch 1 -or 0 -ep 0 -rn 0 -po 1 -ept 0.1 $ConnectPatch[0] $ConnectPatch[2] $ConnectPatch[1] $first[0];
													select -r $ConnectPatch; PAUSE;
													$Cycles++; 
													clear $ConnectPatch;
												}
												$Bounded++; 
												if($Bounded==2){
													$everyCurve = stringArrayRemoveExact($first , $everyCurve);
												}	
												break;
											}
										}
									}
								}
							}
							if(($intIfTrueA == 1)&&( $intIfTrueB == 1)&&($intIfTrueC==0)){
								break;
							}
						}
					}
				}
				//## 3rd 
			}
			//////////
			$Loops++;
			$CatureEveryCurve = $AllList;
			$CatureAllCur = $AllCur;
			//## 2nd 
		}
		deleteUI $myIntersector;
		// 1st 
	}
	TRIGGER_RUNjobNumTAN;
}
proc int FindifFourCurvesShareSurface(string $Foundboundarycurves[]){
	string $Intersectboundarycurves[];
	string $myIntersector = `stringArrayIntersector`;
	for ( $eachboundry in $Foundboundarycurves ) {
		string $selectedCurve[];
		clear $selectedCurve;
		$selectedCurve[0] = $eachboundry;
		string $firstcurveRelatives[];
		$firstcurveRelatives = `listRelatives -shapes  $selectedCurve`;
		string $firstcurveConnectionsz[];
		$firstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true $firstcurveRelatives`;
		int $historyShapes = `size($firstcurveConnectionsz)`;
		if ($historyShapes > 0){
			string $ZfirstcurveshapesA[];
			string $ZfirstcurveshapesB[];
			$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $firstcurveConnectionsz`;
			$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $firstcurveConnectionsz`;
			$XnumConnectionsN = `size($ZfirstcurveshapesA)`;
			$XnumConnectionsM = `size($ZfirstcurveshapesB)`;
			$XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
			if($XnumConnectionsN > 0){stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesA  $myIntersector;}
			if($XnumConnectionsM > 0){stringArrayIntersector -edit -allowDuplicates  false -intersect $ZfirstcurveshapesB  $myIntersector;}
		}
	}
	$Intersectboundarycurves =  `stringArrayIntersector -query $myIntersector`;
	stringArrayIntersector -edit -reset  $myIntersector;
	int $trueorFalse=0;
	if (`size($Intersectboundarycurves)` == 0){
		$trueorFalse=0;}else{$trueorFalse=1;}
	return $trueorFalse;
}
//RemoveCurvesThatshareNamedSurface($Connecting, $SurfaceName[0]);
proc int NumberOFSurf(string $Zeachboundry){
	int $XnumOFcurveConnections;
	string $ZfirstcurveRelatives[];
	$ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
	string $ZfirstcurveConnectionsz[];
	$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
	int $historyShapes = `size($ZfirstcurveConnectionsz)`;
	if ($historyShapes > 0){
		string $Zfirstcurveshapes[];
		$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
		$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
		$XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
	}else{ $XnumOFcurveConnections = 0;}
	return $XnumOFcurveConnections;
}
proc string[] ForAllCurvesFindSurfaceEdges(string $newallCurves[]){
	string $ZnewfoundEdge[];
	for ( $Zeachboundry in $newallCurves ) {
		string $ZselectedCurve[];
		$ZselectedCurve[0] = $Zeachboundry;
		int $Zfirstcurveshapesi = `NumberOFSurf($Zeachboundry)`;
		if ($Zfirstcurveshapesi == 1){
			appendStringArray($ZnewfoundEdge, $ZselectedCurve, 1);
		}
		if ($Zfirstcurveshapesi == 0){
			appendStringArray($ZnewfoundEdge,  $ZselectedCurve, 1);
		}
	}
	return $ZnewfoundEdge;
}
proc int FindNumOfConnectionsToCurveRemove(string $boundaryCurves[], int $XiC, string $everyFirstCurveShapeset[]){
	string $selectedCurve[];
	int $numberofconnections;
	for ( $eachboundry in $boundaryCurves ) {
		$selectedCurve[0] = $eachboundry;
		$numberofconnections += NumberOFSurf($eachboundry);
		if ( $numberofconnections == $XiC ) {
			string $firstcurveConn[] = stringArrayRemove ($selectedCurve, $everyFirstCurveShapeset);
			$everyFirstCurveShapeset = $firstcurveConn;
		}
	}
	return  $numberofconnections;
}
proc vector[] GetVectorArrayBetweenCurveEnds(string $CurveItem[]){
	string $CurveSelection[];
	int $numCVs = `getAttr -size ($CurveItem[0] +  ".controlPoints")`;
	int $numCVrealNum = ( $numCVs -1 );
	$CurveSelection[0] = ($CurveItem[0] + ".cv[0]") ;	 		
	$CurveSelection[1] = ($CurveItem[0] + ".cv[" +  $numCVrealNum + "]") ;
	float $EACHCVposAZ[]; float $EACHCVposBZ[]; int $numIntZB = 0; string $MakeXBetweenB[];
	for ($eachZA in $CurveSelection) {
		float $eachCVpos[];	 $eachCVpos = `pointPosition -w ( $eachZA   )`;
		$numIntZB = $numIntZB + 1;
		if ( $numIntZB == 1 ){$EACHCVposAZ = $eachCVpos;}
		if ( $numIntZB == 2 ){$EACHCVposBZ = $eachCVpos;}
	}
	vector $CurveA = << $EACHCVposAZ[0], $EACHCVposAZ[1], $EACHCVposAZ[2] >>;
	vector $CurveB = << $EACHCVposBZ[0], $EACHCVposBZ[1], $EACHCVposBZ[2] >>;	
	vector $CurveAB[]; $CurveAB[0] = $CurveA; $CurveAB[1] = $CurveB;
	return $CurveAB; 
}
proc int  PointsEquivalentTol( float $posA[],  float $posB[]){
	int $pX = equivalentTol($posA[0], $posB[0],  0.01);
	int $pY = equivalentTol($posA[1], $posB[1],  0.01);
	int $pZ = equivalentTol($posA[2], $posB[2],  0.01);
	int $addedResults = $pX + $pY + $pZ;
	return $addedResults;
}
proc int FindifCurveEndsMeet(vector $CurveA1[], vector $CurveA2[]){
	int $CurveMeetsTrue = 0;
	int $indexN = 0;
	int $indexN2 = 0;
	while ($indexN < 2){
		float $firstC[];
		$firstC = $CurveA1[$indexN];
		float $SecondCA[];
		$SecondC = $CurveA2[0];
		float $SecondCA[];
		$SecondCA = $CurveA2[1];
		int $NumberE = PointsEquivalentTol( $firstC, $SecondC);
		int $NumberE2 = PointsEquivalentTol( $firstC, $SecondCA);
		if (($NumberE == 3)||($NumberE2 == 3)){$CurveMeetsTrue = $CurveMeetsTrue +1; }
		if ($indexN==1){$indexN1 = 1;}
		$indexN++;
	}
	return $CurveMeetsTrue;
}
proc int IfCurvesTouch(string $curveA, string $curveB){
	string $Acurve[];
	$Acurve = {$curveA};
	string $Bcurve[];
	$Bcurve = {$curveB};
	vector $CurveOne[] = GetVectorArrayBetweenCurveEnds($Acurve);
	vector $CurveTwo[] = GetVectorArrayBetweenCurveEnds($Bcurve);
	int $intIfTrue = FindifCurveEndsMeet($CurveOne, $CurveTwo);
	return $intIfTrue;
}
///////////////
proc string [] GetSurfConnectNameIfexists(string $Zeachboundry){
	//string $Zeachboundry = $first[0];
	string $connectionSurfaceName[];
	int $XnumOFcurveConnections;
	int $XnumConnectionsM;
	int $XnumConnectionsN;
	string $ZfirstcurveRelatives[];
	$ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
	string $ZfirstcurveConnectionsz[];
	$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
	int $historyShapes = `size($ZfirstcurveConnectionsz)`;
	if ($historyShapes > 0){
		string $ZfirstcurveshapesA[];
		string $ZfirstcurveshapesB[];
		$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
		$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
		$XnumConnectionsN = `size($ZfirstcurveshapesA)`;
		$XnumConnectionsM = `size($ZfirstcurveshapesB)`;
		$XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
		if($XnumConnectionsN > 0){$connectionSurfaceName[size($connectionSurfaceName)] = $ZfirstcurveshapesA[0] ;}
		if($XnumConnectionsM > 0){$connectionSurfaceName[size($connectionSurfaceName)] = $ZfirstcurveshapesB[0] ;}
	} 
	return $connectionSurfaceName;
}
proc RemoveCurvesThatshareNamedSurface(string $ConnectingA[], string $foundFirstSurface){
	string $ConnectingZ[] = $ConnectingA;
	string $ConnectingB[] = $ConnectingA;
	string $connectionSurfaceName[];
	string $connectSur;
	for($Zeachboundry in $ConnectingZ){
		int $XnumOFcurveConnections;
		int $XnumConnectionsM;
		int $XnumConnectionsN;
		string $ZfirstcurveRelatives[];
		$ZfirstcurveRelatives = `listRelatives -shapes $Zeachboundry`;
		string $ZfirstcurveConnectionsz[];
		$ZfirstcurveConnectionsz = ` listHistory -future  true -pruneDagObjects true  $ZfirstcurveRelatives`;
		int $historyShapes = `size($ZfirstcurveConnectionsz)`;
		if ($historyShapes > 0){
			string $ZfirstcurveshapesA[];
			string $ZfirstcurveshapesB[];
			$ZfirstcurveshapesA = `listConnections -shapes 1  -type nurbsSurface $ZfirstcurveConnectionsz`;
			$ZfirstcurveshapesB = `listConnections -shapes 1  -type mesh $ZfirstcurveConnectionsz`;
			$XnumConnectionsN = `size($ZfirstcurveshapesA)`;
			$XnumConnectionsM = `size($ZfirstcurveshapesB)`;
			$XnumOFcurveConnections = (`size($ZfirstcurveshapesA)`) + (`size($ZfirstcurveshapesB)`) ;
			if($XnumConnectionsN > 0){$connectSur = $ZfirstcurveshapesA[0] ;}
			if($XnumConnectionsM > 0){$connectSur = $ZfirstcurveshapesB[0] ;}
			if($XnumOFcurveConnections > 0){
				string $SurfC = $connectSur;
				int $True = `gmatch $SurfC $foundFirstSurface`;
				if($True == 1){
					$ConnectingB = stringArrayRemoveExact({$Zeachboundry}, $ConnectingB);
				}
			}
		}
	} 
	$ConnectingA = $ConnectingB;
}
proc StartupItems(){
	optionVar -fv "totalAnimateRollTime" 0.9;
	select -r   Text_byxDrawingxaxLinexOverxOnexofxThexCurves_1;
	allViewFit(0);
	allViewFit(1);
	select -cl  ;
	goToView -1;
	pause -sec 2;
	optionVar -fv "totalAnimateRollTime" 2.5;
	goToView -1;
	optionVar -fv "totalAnimateRollTime" 0.4;
	setAttr "ZCURVEModelingCAM.centerOfInterest"   72.916917;
	eval("int $script_jobToolChangedNum1 = `scriptJob   -event ToolChanged EvalAutoCurvesScripts`;");
	PencilCurveTool;
	curveSketchCtx -e -d 3 `currentCtx`;
	setAttr layerYZYXPlains.visibility 1;
}
/////////////////////////////
/////////////////////////////
//////////
//////////
//////////
//////////
/*
file -f -options "v=0"  -typ "mayaBinary" -o   "C:/Users/johnny/Documents/maya/projects/default/  scenes/RetopoMakeworkToday2.mb";addRecentFile   ("C:/Users/johnny/Documents/maya/projects/default  /scenes/RetopoMakeworkToday2.mb", "mayaBinary");
scriptJob -killAll -force;
select -r LiveSurfaceB ;
MakeLive;
select -r pCube1 ;
string $PolygonShapeZA[] = `ls -sl`;
PencilCurveTool;
DisplayWireframe;
/////Stiner
int $n = 12;
float $angleArray = 360/$n;
*/
/////////////////////////////////////////////////  ///////////////
proc ResetTransEachSL(){
	string $oneItemz[] = `ls -sl`;
	for ($each in $oneItemz){
		xform -cp $each;
		vector $worldPos = `xform -q -ws -rp   $each`;
		move -rpr 0 0 0 $each;
		makeIdentity -apply true   -t 1 -r 0 -s 0 $each;
		xform -t ($worldPos.x)   ($worldPos.y) ($worldPos.z) $each;
	}
}
//ResetTransEachSL;
/////////////////////////////////////////////////  ///////////////
/////////////////////////////////////////////////  ///////////////
/*
if ( `objExists ZCURVEModelingCAM` == 0  ) {
handleScriptEditorAction "toggleSuppressInfos";
handleScriptEditorAction  "toggleSuppressWarnings";
handleScriptEditorAction "toggleSuppressErrors";
setWireframeOnShadedOption 1 modelPanel4;
//ONE or the other Below -
$CamConeLocator = `CreateCAMforIntCurveScript`;
if ( `objExists CamConeLocatorSet` == 0  ) {
$newCAMSet1 = `sets -name CamConeLocatorSet`;
sets -include CamConeLocatorSet $CamConeLocator;
}
createStageOneForRetopo;
select -r $CamConeLocator;
HideSelectedObjects;
shadingNode -asShader lambert;
$material = `shadingNode -asShader lambert -name  LIVEsurfaceslambert`;
	$sg = `sets -renderable true - noSurfaceShader true -empty -name ($material +  "SG")`;
setAttr "LIVEsurfaceslambert.transparency" -type  double3 1 1 1 ;
defaultNavigation -source LIVEsurfaceslambert - destination  |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "LiveSurfaceBShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert - destination |Zplane|ZplaneShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "ZplaneShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert - destination |Xplane|XplaneShape.instObjGroups[0]  -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",  "XplaneShape.instObjGroups[0]");
//createStageOne;
}
if (( `objExists ZCURVEModelingCAM` == 1  )&& (  `objExists layerCurvesINRange1` == 1 )) {
if ( `objExists CamConeLocatorSet` == 1  ) {
eval( "global string $CamConeLocator[];");
eval( "$CamConeLocator= `sets -q  CamConeLocatorSet`;");
}
}
//CHANGES MADE
proc FlattenCurveOnMesh( string $curve[], string  $Mesh[]){
string $PolygonShapeZ1[0] = {$Mesh[0]};
string $CurveZOne[0] = {$curve[0]};
string $CurveSelection[] = `ls -fl ($CurveZOne[0]  +".ep[0:*]")`; 
	string $PolyX = $PolygonShapeZ1[0];
	$myCPOM = `createNode closestPointOnMesh`;
	connectAttr ($PolyX+".worldMesh")  ($myCPOM+".inMesh");
	$LocatorResultA = `spaceLocator -p 0 0 0 -n  LocA`;
	$LocA = $LocatorResultA[0];
	connectAttr ($myCPOM+".position")  ($LocA+".translate");
	$LocatorResultB = `spaceLocator -p 0 0 0 -n  LocB`;
	$LocB = $LocatorResultB[0];
	connectAttr ($LocB+".translate")  ($myCPOM+".inPosition");
for ($Eachep in $CurveSelection ) {
	float $pointPos[];
	$pointPos = `pointPosition -w ($Eachep)`;
move -ws $pointPos[0] $pointPos[1] $pointPos[2]  $LocB;
float $valuesB[] = `getAttr  ($myCPOM+".position")`;
move -ws $valuesB[0] $valuesB[1] $valuesB[2]  $Eachep;
}
delete  $myCPOM $LocA $LocB;
$Newcurvez = $CurveZOne;
}
proc createStageOne(){
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Zplane;
rotate -r -os 0 0 -90 ;
setAttr "Zplane.scaleX" 3000;
setAttr "Zplane.scaleY" 3000;
setAttr "Zplane.scaleZ" 3000; 
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Xplane;
setAttr "Xplane.scaleX" 3000;
setAttr "Xplane.scaleY" 3000;
setAttr "Xplane.scaleZ" 3000;
editDisplayLayerMembers -noRecurse  NurbsPlanes "Zplane";
editDisplayLayerMembers -noRecurse  NurbsPlanes "Xplane";
layerEditorLayerButtonVisibilityChange NurbsPlanes;
textCurves -ch 0 -f "Courier New|h-19|w700|c0" -t  "Select The Z Axis OR the X Axis ";
rotate -r -os 0 90 0 ;
move -r 0 0 59.5 ;
move -r 0 19 0 ;
textCurves -ch 0 -f "Courier New|h-19|w700|c0" -t  "by Drawing a Line Over One of The Curves";
rotate -r -os 0 90 0 ;
move -r 0 0 59.5 ;
move -r 0 12.5 0 ;
string $Zc[];
string $Xc[];
$Zc[0] = `curve -d 3 -p 0 0 0 -p 0 0 4 -p 0  0 8 -p 0 0 12 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n  Zcurvez`;
$Xc[0] = `curve -d 3 -p 0 0 0 -p 4 0 0 -p 8  0 0 -p 12 0 0 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n  Xcurvez`;
rename $Zc "Zcurvez" ;
rename $Xc "Xcurvez" ;
if ( `objExists layerZcurvez` == 0  ) {
createDisplayLayer -name "layerZcurvez" -number 1  -empty;
setAttr layerZcurvez.color 6;
editDisplayLayerMembers -noRecurse layerZcurvez  Zcurvez;
}
//
if ( `objExists layerXcurvez` == 0  ) {
createDisplayLayer -name "layerXcurvez" -number 1  -empty;
setAttr layerXcurvez.color 13;
editDisplayLayerMembers -noRecurse layerXcurvez  "Xcurvez";
}
//rename |Xcurvez|curveShape2 "XcurvezShape2" ;
//rename |Zcurvez|curveShape1 "ZcurvezShape1" ;
}
///////////////////////////////////////////////// //
proc createStageOneForRetopo(){
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Zplane;
//OLD editDisplayLayerMembers -noRecurse  layerYZYXPlains "Zplane";
rotate -r -os 0 0 -90 ;
setAttr "Zplane.scaleX" 3000;
setAttr "Zplane.scaleY" 3000;
setAttr "Zplane.scaleZ" 3000; 
nurbsPlane -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u  1 -v 1 -ch 1 -n Xplane;
setAttr "Xplane.scaleX" 3000;
setAttr "Xplane.scaleY" 3000;
setAttr "Xplane.scaleZ" 3000;
editDisplayLayerMembers -noRecurse  NurbsPlanes "Zplane";
editDisplayLayerMembers -noRecurse  NurbsPlanes "Xplane";
layerEditorLayerButtonVisibilityChange NurbsPlanes;
curve -d 3 -p 0 0 0 -p 0 0 4 -p 0 0 8 -p 0 0 12  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Zcurvez;
curve -d 3 -p 0 0 0 -p 4 0 0 -p 8 0 0 -p 12 0 0  -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 -n Xcurvez;
if ( `objExists layerZcurvez` == 0  ) {
createDisplayLayer -name "layerZcurvez" -number 1  -empty;
setAttr layerZcurvez.color 6;
editDisplayLayerMembers -noRecurse layerZcurvez  Zcurvez;
}
//
if ( `objExists layerXcurvez` == 0  ) {
createDisplayLayer -name "layerXcurvez" -number 1  -empty;
setAttr layerXcurvez.color 13;
editDisplayLayerMembers -noRecurse layerXcurvez  "Xcurvez";
}
}
proc StartupItemsPart2(){
setAttr "ZCURVEModelingCAM.centerOfInterest"   72.916917;
eval("int $script_jobToolChangedNum1 = `scriptJob   -event ToolChanged EvalAutoCurvesScripts`;");
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
setAttr layerYZYXPlains.visibility 1;
}
proc PreStartup1(){
setAttr "ZCURVEModelingCAM.centerOfInterest"   72.916917;
PencilCurveTool;
curveSketchCtx -e -d 3 `currentCtx`;
}
proc float PercentDiff(float $a, float $b){
float $c;
float $d;
if($a>$b){ $c=$a; $d=$b;}else{$c=$b; $d=$a;}
float $percent =  100/($c/$d);
if($a==$b){$percent=0;}
return $percent ;
}
///////////////////////////////////////////////
///////////////////////////////////////////////
//This IF statement checks if CurveScripts That   Build Setup have already been RUN 
//and Already Exist
global string $CamConeLocator[];
string $newCAMSet1;
//select -r $CamConeLocator;
if ( `objExists ZCURVEModelingCAM` == 0  ) {
handleScriptEditorAction "toggleSuppressInfos";
handleScriptEditorAction   "toggleSuppressWarnings";
handleScriptEditorAction "toggleSuppressErrors";
setWireframeOnShadedOption 1 modelPanel4;
//ONE or the other Below -
$CamConeLocator = `CreateCAMforIntCurveScript`;
if ( `objExists CamConeLocatorSet` == 0  ) {
$newCAMSet1 = `sets -name CamConeLocatorSet`;
sets -include CamConeLocatorSet $CamConeLocator;
}
//createStageOneForRetopo;
createStageOne;
select -r $CamConeLocator;
HideSelectedObjects;
shadingNode -asShader lambert;
$material = `shadingNode -asShader lambert -name   LIVEsurfaceslambert`;
	$sg = `sets -renderable true -  noSurfaceShader true -empty -name ($material +   "SG")`;
setAttr "LIVEsurfaceslambert.transparency" -type   double3 1 1 1 ;
defaultNavigation -source LIVEsurfaceslambert -  destination   |LiveSurfaceB|LiveSurfaceBShape.instObjGroups[0]   -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",   "LiveSurfaceBShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert -  destination |Zplane|ZplaneShape.instObjGroups[0]   -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",   "ZplaneShape.instObjGroups[0]");
defaultNavigation -source LIVEsurfaceslambert -  destination |Xplane|XplaneShape.instObjGroups[0]   -connectToExisting;
connectNodeToAttrOverride("LIVEsurfaceslambert",   "XplaneShape.instObjGroups[0]");
//createStageOne;
}
if (( `objExists ZCURVEModelingCAM` == 1  )&& (   `objExists layerCurvesINRange1` == 1 )) {
if ( `objExists CamConeLocatorSet` == 1  ) {
eval( "global string $CamConeLocator[];");
eval( "$CamConeLocator= `sets -q   CamConeLocatorSet`;");
}
}
//ONE or the other Below -
////////////////////////////////////////////////////////////////////////////////////
//START
//PreStartup1;
//select -r Xplane;
//evalDeferred StartupItemsPart2;
/////////////////////////////////////////////////////////////////////////////////////
//evalDeferred StartupItems;
*/
